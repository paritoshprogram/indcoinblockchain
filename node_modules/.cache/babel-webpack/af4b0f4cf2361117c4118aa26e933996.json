{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/createClass\");\n\nvar SHA256 = require('crypto-js/sha256');\n\nvar EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\n\nvar Transaction = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param {string} fromAddress\n   * @param {string} toAddress\n   * @param {number} amount\n   */\n  function Transaction(fromAddress, toAddress, amount) {\n    _classCallCheck(this, Transaction);\n\n    this.fromAddress = fromAddress;\n    this.toAddress = toAddress;\n    this.amount = amount;\n    this.timestamp = Date.now();\n  }\n  /**\n   * Creates a SHA256 hash of the transaction\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(Transaction, [{\n    key: \"calculateHash\",\n    value: function calculateHash() {\n      return SHA256(this.fromAddress + this.toAddress + this.amount + this.timestamp).toString();\n    }\n    /**\n     * Signs a transaction with the given signingKey (which is an Elliptic keypair\n     * object that contains a private key). The signature is then stored inside the\n     * transaction object and later stored on the blockchain.\n     *\n     * @param {string} signingKey\n     */\n\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(signingKey) {\n      // You can only send a transaction from the wallet that is linked to your\n      // key. So here we check if the fromAddress matches your publicKey\n      if (signingKey.getPublic('hex') !== this.fromAddress) {\n        throw new Error('You cannot sign transactions for other wallets!');\n      } // Calculate the hash of this transaction, sign it with the key\n      // and store it inside the transaction obect\n\n\n      var hashTx = this.calculateHash();\n      var sig = signingKey.sign(hashTx, 'base64');\n      this.signature = sig.toDER('hex');\n    }\n    /**\n     * Checks if the signature is valid (transaction has not been tampered with).\n     * It uses the fromAddress as the public key.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      // If the transaction doesn't have a from address we assume it's a\n      // mining reward and that it's valid. You could verify this in a\n      // different way (special field for instance)\n      if (this.fromAddress === null) return true;\n\n      if (!this.signature || this.signature.length === 0) {\n        throw new Error('No signature in this transaction');\n      }\n\n      var publicKey = ec.keyFromPublic(this.fromAddress, 'hex');\n      return publicKey.verify(this.calculateHash(), this.signature);\n    }\n  }]);\n\n  return Transaction;\n}();\n\nvar Block = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param {number} timestamp\n   * @param {Transaction[]} transactions\n   * @param {string} previousHash\n   */\n  function Block(timestamp, transactions) {\n    var previousHash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n    _classCallCheck(this, Block);\n\n    this.previousHash = previousHash;\n    this.timestamp = timestamp;\n    this.transactions = transactions;\n    this.nonce = 0;\n    this.hash = this.calculateHash();\n  }\n  /**\n   * Returns the SHA256 of this block (by processing all the data stored\n   * inside this block)\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(Block, [{\n    key: \"calculateHash\",\n    value: function calculateHash() {\n      return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();\n    }\n    /**\n     * Starts the mining process on the block. It changes the 'nonce' until the hash\n     * of the block starts with enough zeros (= difficulty)\n     *\n     * @param {number} difficulty\n     */\n\n  }, {\n    key: \"mineBlock\",\n    value: function mineBlock(difficulty) {\n      while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {\n        this.nonce++;\n        this.hash = this.calculateHash();\n      }\n\n      console.log(\"Block mined: \".concat(this.hash));\n    }\n    /**\n     * Validates all the transactions inside this block (signature + hash) and\n     * returns true if everything checks out. False if the block is invalid.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasValidTransactions\",\n    value: function hasValidTransactions() {\n      var _iterator = _createForOfIteratorHelper(this.transactions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var tx = _step.value;\n\n          if (!tx.isValid()) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }]);\n\n  return Block;\n}();\n\nvar Blockchain = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Blockchain() {\n    _classCallCheck(this, Blockchain);\n\n    this.chain = [this.createGenesisBlock()];\n    this.difficulty = 2;\n    this.pendingTransactions = [];\n    this.miningReward = 100;\n  }\n  /**\n   * @returns {Block}\n   */\n\n\n  _createClass(Blockchain, [{\n    key: \"createGenesisBlock\",\n    value: function createGenesisBlock() {\n      return new Block(Date.parse('2017-01-01'), [], '0');\n    }\n    /**\n     * Returns the latest block on our chain. Useful when you want to create a\n     * new Block and you need the hash of the previous Block.\n     *\n     * @returns {Block[]}\n     */\n\n  }, {\n    key: \"getLatestBlock\",\n    value: function getLatestBlock() {\n      return this.chain[this.chain.length - 1];\n    }\n    /**\n     * Takes all the pending transactions, puts them in a Block and starts the\n     * mining process. It also adds a transaction to send the mining reward to\n     * the given address.\n     *\n     * @param {string} miningRewardAddress\n     */\n\n  }, {\n    key: \"minePendingTransactions\",\n    value: function minePendingTransactions(miningRewardAddress) {\n      var rewardTx = new Transaction(null, miningRewardAddress, this.miningReward);\n      this.pendingTransactions.push(rewardTx);\n      var block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash);\n      block.mineBlock(this.difficulty);\n      console.log('Block successfully mined!');\n      this.chain.push(block);\n      this.pendingTransactions = [];\n    }\n    /**\n     * Add a new transaction to the list of pending transactions (to be added\n     * next time the mining process starts). This verifies that the given\n     * transaction is properly signed.\n     *\n     * @param {Transaction} transaction\n     */\n\n  }, {\n    key: \"addTransaction\",\n    value: function addTransaction(transaction) {\n      if (!transaction.fromAddress || !transaction.toAddress) {\n        throw new Error('Transaction must include from and to address');\n      } // Verify the transactiion\n\n\n      if (!transaction.isValid()) {\n        throw new Error('Cannot add invalid transaction to chain');\n      }\n\n      if (transaction.amount <= 0) {\n        throw new Error('Transaction amount should be higher than 0');\n      }\n\n      this.pendingTransactions.push(transaction);\n    }\n    /**\n     * Returns the balance of a given wallet address.\n     *\n     * @param {string} address\n     * @returns {number} The balance of the wallet\n     */\n\n  }, {\n    key: \"getBalanceOfAddress\",\n    value: function getBalanceOfAddress(address) {\n      var balance = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(this.chain),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var block = _step2.value;\n\n          var _iterator3 = _createForOfIteratorHelper(block.transactions),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var trans = _step3.value;\n\n              if (trans.fromAddress === address) {\n                balance -= trans.amount;\n              }\n\n              if (trans.toAddress === address) {\n                balance += trans.amount;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return balance;\n    }\n    /**\n     * Returns a list of all transactions that happened\n     * to and from the given wallet address.\n     *\n     * @param  {string} address\n     * @return {Transaction[]}\n     */\n\n  }, {\n    key: \"getAllTransactionsForWallet\",\n    value: function getAllTransactionsForWallet(address) {\n      var txs = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this.chain),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var block = _step4.value;\n\n          var _iterator5 = _createForOfIteratorHelper(block.transactions),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var tx = _step5.value;\n\n              if (tx.fromAddress === address || tx.toAddress === address) {\n                txs.push(tx);\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return txs;\n    }\n    /**\n     * Loops over all the blocks in the chain and verify if they are properly\n     * linked together and nobody has tampered with the hashes. By checking\n     * the blocks it also verifies the (signed) transactions inside of them.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isChainValid\",\n    value: function isChainValid() {\n      // Check if the Genesis block hasn't been tampered with by comparing\n      // the output of createGenesisBlock with the first block on our chain\n      var realGenesis = JSON.stringify(this.createGenesisBlock());\n\n      if (realGenesis !== JSON.stringify(this.chain[0])) {\n        return false;\n      } // Check the remaining blocks on the chain to see if there hashes and\n      // signatures are correct\n\n\n      for (var i = 1; i < this.chain.length; i++) {\n        var currentBlock = this.chain[i];\n\n        if (!currentBlock.hasValidTransactions()) {\n          return false;\n        }\n\n        if (currentBlock.hash !== currentBlock.calculateHash()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return Blockchain;\n}();\n\nmodule.exports.Blockchain = Blockchain;\nmodule.exports.Block = Block;\nmodule.exports.Transaction = Transaction;","map":{"version":3,"sources":["/Users/paritoshdutta/node_modules/SavjeeCoin/src/blockchain.js"],"names":["SHA256","require","EC","ec","Transaction","fromAddress","toAddress","amount","timestamp","Date","now","toString","signingKey","getPublic","Error","hashTx","calculateHash","sig","sign","signature","toDER","length","publicKey","keyFromPublic","verify","Block","transactions","previousHash","nonce","hash","JSON","stringify","difficulty","substring","Array","join","console","log","tx","isValid","Blockchain","chain","createGenesisBlock","pendingTransactions","miningReward","parse","miningRewardAddress","rewardTx","push","block","getLatestBlock","mineBlock","transaction","address","balance","trans","txs","realGenesis","i","currentBlock","hasValidTransactions","module","exports"],"mappings":"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","sourcesContent":["const SHA256 = require('crypto-js/sha256');\nconst EC = require('elliptic').ec;\nconst ec = new EC('secp256k1');\n\nclass Transaction {\n  /**\n   * @param {string} fromAddress\n   * @param {string} toAddress\n   * @param {number} amount\n   */\n  constructor(fromAddress, toAddress, amount) {\n    this.fromAddress = fromAddress;\n    this.toAddress = toAddress;\n    this.amount = amount;\n    this.timestamp = Date.now();\n  }\n\n  /**\n   * Creates a SHA256 hash of the transaction\n   *\n   * @returns {string}\n   */\n  calculateHash() {\n    return SHA256(this.fromAddress + this.toAddress + this.amount + this.timestamp)\n      .toString();\n  }\n\n  /**\n   * Signs a transaction with the given signingKey (which is an Elliptic keypair\n   * object that contains a private key). The signature is then stored inside the\n   * transaction object and later stored on the blockchain.\n   *\n   * @param {string} signingKey\n   */\n  signTransaction(signingKey) {\n    // You can only send a transaction from the wallet that is linked to your\n    // key. So here we check if the fromAddress matches your publicKey\n    if (signingKey.getPublic('hex') !== this.fromAddress) {\n      throw new Error('You cannot sign transactions for other wallets!');\n    }\n    \n\n    // Calculate the hash of this transaction, sign it with the key\n    // and store it inside the transaction obect\n    const hashTx = this.calculateHash();\n    const sig = signingKey.sign(hashTx, 'base64');\n\n    this.signature = sig.toDER('hex');\n  }\n\n  /**\n   * Checks if the signature is valid (transaction has not been tampered with).\n   * It uses the fromAddress as the public key.\n   *\n   * @returns {boolean}\n   */\n  isValid() {\n    // If the transaction doesn't have a from address we assume it's a\n    // mining reward and that it's valid. You could verify this in a\n    // different way (special field for instance)\n    if (this.fromAddress === null) return true;\n\n    if (!this.signature || this.signature.length === 0) {\n      throw new Error('No signature in this transaction');\n    }\n\n    const publicKey = ec.keyFromPublic(this.fromAddress, 'hex');\n    return publicKey.verify(this.calculateHash(), this.signature);\n  }\n}\n\nclass Block {\n  /**\n   * @param {number} timestamp\n   * @param {Transaction[]} transactions\n   * @param {string} previousHash\n   */\n  constructor(timestamp, transactions, previousHash = '') {\n    this.previousHash = previousHash;\n    this.timestamp = timestamp;\n    this.transactions = transactions;\n    this.nonce = 0;\n    this.hash = this.calculateHash();\n  }\n\n  /**\n   * Returns the SHA256 of this block (by processing all the data stored\n   * inside this block)\n   *\n   * @returns {string}\n   */\n  calculateHash() {\n    return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();\n  }\n\n  /**\n   * Starts the mining process on the block. It changes the 'nonce' until the hash\n   * of the block starts with enough zeros (= difficulty)\n   *\n   * @param {number} difficulty\n   */\n  mineBlock(difficulty) {\n    while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {\n      this.nonce++;\n      this.hash = this.calculateHash();\n    }\n\n    console.log(`Block mined: ${this.hash}`);\n  }\n\n  /**\n   * Validates all the transactions inside this block (signature + hash) and\n   * returns true if everything checks out. False if the block is invalid.\n   *\n   * @returns {boolean}\n   */\n  hasValidTransactions() {\n    for (const tx of this.transactions) {\n      if (!tx.isValid()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nclass Blockchain {\n  constructor() {\n    this.chain = [this.createGenesisBlock()];\n    this.difficulty = 2;\n    this.pendingTransactions = [];\n    this.miningReward = 100;\n  }\n\n  /**\n   * @returns {Block}\n   */\n  createGenesisBlock() {\n    return new Block(Date.parse('2017-01-01'), [], '0');\n  }\n\n  /**\n   * Returns the latest block on our chain. Useful when you want to create a\n   * new Block and you need the hash of the previous Block.\n   *\n   * @returns {Block[]}\n   */\n  getLatestBlock() {\n    return this.chain[this.chain.length - 1];\n  }\n\n  /**\n   * Takes all the pending transactions, puts them in a Block and starts the\n   * mining process. It also adds a transaction to send the mining reward to\n   * the given address.\n   *\n   * @param {string} miningRewardAddress\n   */\n  minePendingTransactions(miningRewardAddress) {\n    const rewardTx = new Transaction(null, miningRewardAddress, this.miningReward);\n    this.pendingTransactions.push(rewardTx);\n\n    let block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash);\n    block.mineBlock(this.difficulty);\n\n    console.log('Block successfully mined!');\n    this.chain.push(block);\n\n    this.pendingTransactions = [];\n  }\n\n  /**\n   * Add a new transaction to the list of pending transactions (to be added\n   * next time the mining process starts). This verifies that the given\n   * transaction is properly signed.\n   *\n   * @param {Transaction} transaction\n   */\n  addTransaction(transaction) {\n    if (!transaction.fromAddress || !transaction.toAddress) {\n      throw new Error('Transaction must include from and to address');\n    }\n\n    // Verify the transactiion\n    if (!transaction.isValid()) {\n      throw new Error('Cannot add invalid transaction to chain');\n    }\n    \n    if (transaction.amount <= 0) {\n      throw new Error('Transaction amount should be higher than 0');\n    }\n\n    this.pendingTransactions.push(transaction);\n  }\n\n  /**\n   * Returns the balance of a given wallet address.\n   *\n   * @param {string} address\n   * @returns {number} The balance of the wallet\n   */\n  getBalanceOfAddress(address) {\n    let balance = 0;\n\n    for (const block of this.chain) {\n      for (const trans of block.transactions) {\n        if (trans.fromAddress === address) {\n          balance -= trans.amount;\n        }\n\n        if (trans.toAddress === address) {\n          balance += trans.amount;\n        }\n      }\n    }\n\n    return balance;\n  }\n\n  /**\n   * Returns a list of all transactions that happened\n   * to and from the given wallet address.\n   *\n   * @param  {string} address\n   * @return {Transaction[]}\n   */\n  getAllTransactionsForWallet(address) {\n    const txs = [];\n\n    for (const block of this.chain) {\n      for (const tx of block.transactions) {\n        if (tx.fromAddress === address || tx.toAddress === address) {\n          txs.push(tx);\n        }\n      }\n    }\n\n    return txs;\n  }\n\n  /**\n   * Loops over all the blocks in the chain and verify if they are properly\n   * linked together and nobody has tampered with the hashes. By checking\n   * the blocks it also verifies the (signed) transactions inside of them.\n   *\n   * @returns {boolean}\n   */\n  isChainValid() {\n    // Check if the Genesis block hasn't been tampered with by comparing\n    // the output of createGenesisBlock with the first block on our chain\n    const realGenesis = JSON.stringify(this.createGenesisBlock());\n\n    if (realGenesis !== JSON.stringify(this.chain[0])) {\n      return false;\n    }\n\n    // Check the remaining blocks on the chain to see if there hashes and\n    // signatures are correct\n    for (let i = 1; i < this.chain.length; i++) {\n      const currentBlock = this.chain[i];\n\n      if (!currentBlock.hasValidTransactions()) {\n        return false;\n      }\n\n      if (currentBlock.hash !== currentBlock.calculateHash()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nmodule.exports.Blockchain = Blockchain;\nmodule.exports.Block = Block;\nmodule.exports.Transaction = Transaction;\n"]},"metadata":{},"sourceType":"script"}