{"ast":null,"code":"import _defineProperty from \"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _assertThisInitialized from \"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _createForOfIteratorHelper from \"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _createClass from \"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/paritoshdutta/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license Angular v8.2.14\n * (c) 2010-2019 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { LocationStrategy, Location, PlatformLocation, APP_BASE_HREF, ViewportScroller, HashLocationStrategy, PathLocationStrategy, LOCATION_INITIALIZED } from '@angular/common';\nimport { Component, ɵisObservable, ɵisPromise, NgModuleRef, InjectionToken, NgModuleFactory, ɵConsole, NgZone, isDevMode, Directive, Attribute, Renderer2, ElementRef, Input, HostListener, HostBinding, Optional, ContentChildren, EventEmitter, ViewContainerRef, ComponentFactoryResolver, ChangeDetectorRef, Output, Injectable, NgModuleFactoryLoader, Compiler, Injector, ApplicationRef, SystemJsNgModuleLoader, NgProbeToken, ANALYZE_FOR_ENTRY_COMPONENTS, SkipSelf, Inject, APP_INITIALIZER, APP_BOOTSTRAP_LISTENER, NgModule, Version } from '@angular/core';\nimport { of, from, BehaviorSubject, Observable, EmptyError, combineLatest, defer, Subject, EMPTY } from 'rxjs';\nimport { map, concatAll, last as last$1, catchError, first, mergeMap, every, switchMap, take, startWith, scan, filter, concatMap, reduce, tap, finalize, mergeAll } from 'rxjs/operators';\nimport { ɵgetDOM } from '@angular/platform-browser';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * \\@usageNotes\n *\n * ```ts\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.pipe(\n *       filter(e => e instanceof RouterEvent)\n *     ).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * @see `Event`\n * \\@publicApi\n */\n\nvar RouterEvent =\n/**\n * @param {?} id\n * @param {?} url\n */\nfunction RouterEvent(id, url) {\n  _classCallCheck(this, RouterEvent);\n\n  this.id = id;\n  this.url = url;\n};\n\nif (false) {\n  /**\n   * A unique ID that the router assigns to every router navigation.\n   * @type {?}\n   */\n  RouterEvent.prototype.id;\n  /**\n   * The URL that is the destination for this navigation.\n   * @type {?}\n   */\n\n  RouterEvent.prototype.url;\n}\n/**\n * An event triggered when a navigation starts.\n *\n * \\@publicApi\n */\n\n\nvar NavigationStart = /*#__PURE__*/function (_RouterEvent) {\n  _inherits(NavigationStart, _RouterEvent);\n\n  var _super = _createSuper(NavigationStart);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?=} navigationTrigger\n   * @param {?=} restoredState\n   */\n  function NavigationStart(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url) {\n    var _this;\n\n    var navigationTrigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'imperative';\n    var restoredState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, NavigationStart);\n\n    _this = _super.call(this, id, url);\n    _this.navigationTrigger = navigationTrigger;\n    _this.restoredState = restoredState;\n    return _this;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"')\");\n    }\n  }]);\n\n  return NavigationStart;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   * @type {?}\n   */\n  NavigationStart.prototype.navigationTrigger;\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   * @type {?}\n   */\n\n  NavigationStart.prototype.restoredState;\n}\n/**\n * An event triggered when a navigation ends successfully.\n *\n * \\@publicApi\n */\n\n\nvar NavigationEnd = /*#__PURE__*/function (_RouterEvent2) {\n  _inherits(NavigationEnd, _RouterEvent2);\n\n  var _super2 = _createSuper(NavigationEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   */\n  function NavigationEnd(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url, urlAfterRedirects) {\n    var _this2;\n\n    _classCallCheck(this, NavigationEnd);\n\n    _this2 = _super2.call(this, id, url);\n    _this2.urlAfterRedirects = urlAfterRedirects;\n    return _this2;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"')\");\n    }\n  }]);\n\n  return NavigationEnd;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  NavigationEnd.prototype.urlAfterRedirects;\n}\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n *\n * This can happen when a [route guard](guide/router#milestone-5-route-guards)\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * \\@publicApi\n */\n\n\nvar NavigationCancel = /*#__PURE__*/function (_RouterEvent3) {\n  _inherits(NavigationCancel, _RouterEvent3);\n\n  var _super3 = _createSuper(NavigationCancel);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} reason\n   */\n  function NavigationCancel(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url, reason) {\n    var _this3;\n\n    _classCallCheck(this, NavigationCancel);\n\n    _this3 = _super3.call(this, id, url);\n    _this3.reason = reason;\n    return _this3;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationCancel, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationCancel(id: \".concat(this.id, \", url: '\").concat(this.url, \"')\");\n    }\n  }]);\n\n  return NavigationCancel;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  NavigationCancel.prototype.reason;\n}\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * \\@publicApi\n */\n\n\nvar NavigationError = /*#__PURE__*/function (_RouterEvent4) {\n  _inherits(NavigationError, _RouterEvent4);\n\n  var _super4 = _createSuper(NavigationError);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} error\n   */\n  function NavigationError(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url, error) {\n    var _this4;\n\n    _classCallCheck(this, NavigationError);\n\n    _this4 = _super4.call(this, id, url);\n    _this4.error = error;\n    return _this4;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(NavigationError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"NavigationError(id: \".concat(this.id, \", url: '\").concat(this.url, \"', error: \").concat(this.error, \")\");\n    }\n  }]);\n\n  return NavigationError;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  NavigationError.prototype.error;\n}\n/**\n * An event triggered when routes are recognized.\n *\n * \\@publicApi\n */\n\n\nvar RoutesRecognized = /*#__PURE__*/function (_RouterEvent5) {\n  _inherits(RoutesRecognized, _RouterEvent5);\n\n  var _super5 = _createSuper(RoutesRecognized);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function RoutesRecognized(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this5;\n\n    _classCallCheck(this, RoutesRecognized);\n\n    _this5 = _super5.call(this, id, url);\n    _this5.urlAfterRedirects = urlAfterRedirects;\n    _this5.state = state;\n    return _this5;\n  }\n  /**\n   * \\@docsNotRequired\n   * @return {?}\n   */\n\n\n  _createClass(RoutesRecognized, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RoutesRecognized(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return RoutesRecognized;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  RoutesRecognized.prototype.urlAfterRedirects;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  RoutesRecognized.prototype.state;\n}\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * \\@publicApi\n */\n\n\nvar GuardsCheckStart = /*#__PURE__*/function (_RouterEvent6) {\n  _inherits(GuardsCheckStart, _RouterEvent6);\n\n  var _super6 = _createSuper(GuardsCheckStart);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function GuardsCheckStart(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this6;\n\n    _classCallCheck(this, GuardsCheckStart);\n\n    _this6 = _super6.call(this, id, url);\n    _this6.urlAfterRedirects = urlAfterRedirects;\n    _this6.state = state;\n    return _this6;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(GuardsCheckStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"GuardsCheckStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return GuardsCheckStart;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  GuardsCheckStart.prototype.urlAfterRedirects;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  GuardsCheckStart.prototype.state;\n}\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * \\@publicApi\n */\n\n\nvar GuardsCheckEnd = /*#__PURE__*/function (_RouterEvent7) {\n  _inherits(GuardsCheckEnd, _RouterEvent7);\n\n  var _super7 = _createSuper(GuardsCheckEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   * @param {?} shouldActivate\n   */\n  function GuardsCheckEnd(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state, shouldActivate) {\n    var _this7;\n\n    _classCallCheck(this, GuardsCheckEnd);\n\n    _this7 = _super7.call(this, id, url);\n    _this7.urlAfterRedirects = urlAfterRedirects;\n    _this7.state = state;\n    _this7.shouldActivate = shouldActivate;\n    return _this7;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(GuardsCheckEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"GuardsCheckEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \", shouldActivate: \").concat(this.shouldActivate, \")\");\n    }\n  }]);\n\n  return GuardsCheckEnd;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  GuardsCheckEnd.prototype.urlAfterRedirects;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  GuardsCheckEnd.prototype.state;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  GuardsCheckEnd.prototype.shouldActivate;\n}\n/**\n * An event triggered at the the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * \\@publicApi\n */\n\n\nvar ResolveStart = /*#__PURE__*/function (_RouterEvent8) {\n  _inherits(ResolveStart, _RouterEvent8);\n\n  var _super8 = _createSuper(ResolveStart);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function ResolveStart(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this8;\n\n    _classCallCheck(this, ResolveStart);\n\n    _this8 = _super8.call(this, id, url);\n    _this8.urlAfterRedirects = urlAfterRedirects;\n    _this8.state = state;\n    return _this8;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ResolveStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ResolveStart(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return ResolveStart;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  ResolveStart.prototype.urlAfterRedirects;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  ResolveStart.prototype.state;\n}\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see `ResolveStart`.\n *\n * \\@publicApi\n */\n\n\nvar ResolveEnd = /*#__PURE__*/function (_RouterEvent9) {\n  _inherits(ResolveEnd, _RouterEvent9);\n\n  var _super9 = _createSuper(ResolveEnd);\n\n  /**\n   * @param {?} id\n   * @param {?} url\n   * @param {?} urlAfterRedirects\n   * @param {?} state\n   */\n  function ResolveEnd(\n  /** @docsNotRequired */\n  id,\n  /** @docsNotRequired */\n  url, urlAfterRedirects, state) {\n    var _this9;\n\n    _classCallCheck(this, ResolveEnd);\n\n    _this9 = _super9.call(this, id, url);\n    _this9.urlAfterRedirects = urlAfterRedirects;\n    _this9.state = state;\n    return _this9;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ResolveEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ResolveEnd(id: \".concat(this.id, \", url: '\").concat(this.url, \"', urlAfterRedirects: '\").concat(this.urlAfterRedirects, \"', state: \").concat(this.state, \")\");\n    }\n  }]);\n\n  return ResolveEnd;\n}(RouterEvent);\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  ResolveEnd.prototype.urlAfterRedirects;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  ResolveEnd.prototype.state;\n}\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * \\@publicApi\n */\n\n\nvar RouteConfigLoadStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   */\n  function RouteConfigLoadStart(route) {\n    _classCallCheck(this, RouteConfigLoadStart);\n\n    this.route = route;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouteConfigLoadStart, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RouteConfigLoadStart(path: \".concat(this.route.path, \")\");\n    }\n  }]);\n\n  return RouteConfigLoadStart;\n}();\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  RouteConfigLoadStart.prototype.route;\n}\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * \\@publicApi\n */\n\n\nvar RouteConfigLoadEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   */\n  function RouteConfigLoadEnd(route) {\n    _classCallCheck(this, RouteConfigLoadEnd);\n\n    this.route = route;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouteConfigLoadEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"RouteConfigLoadEnd(path: \".concat(this.route.path, \")\");\n    }\n  }]);\n\n  return RouteConfigLoadEnd;\n}();\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  RouteConfigLoadEnd.prototype.route;\n}\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see `ChildActivationEnd`\n * @see `ResolveStart`\n *\n * \\@publicApi\n */\n\n\nvar ChildActivationStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ChildActivationStart(snapshot) {\n    _classCallCheck(this, ChildActivationStart);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ChildActivationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ChildActivationStart(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ChildActivationStart;\n}();\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  ChildActivationStart.prototype.snapshot;\n}\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see `ChildActivationStart`\n * @see `ResolveStart` *\n * \\@publicApi\n */\n\n\nvar ChildActivationEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ChildActivationEnd(snapshot) {\n    _classCallCheck(this, ChildActivationEnd);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ChildActivationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ChildActivationEnd(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ChildActivationEnd;\n}();\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  ChildActivationEnd.prototype.snapshot;\n}\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see ActivationEnd`\n * @see `ResolveStart`\n *\n * \\@publicApi\n */\n\n\nvar ActivationStart = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ActivationStart(snapshot) {\n    _classCallCheck(this, ActivationStart);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ActivationStart, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ActivationStart(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ActivationStart;\n}();\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  ActivationStart.prototype.snapshot;\n}\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationStart`\n * @see `ResolveStart`\n *\n * \\@publicApi\n */\n\n\nvar ActivationEnd = /*#__PURE__*/function () {\n  /**\n   * @param {?} snapshot\n   */\n  function ActivationEnd(snapshot) {\n    _classCallCheck(this, ActivationEnd);\n\n    this.snapshot = snapshot;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ActivationEnd, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n      return \"ActivationEnd(path: '\".concat(path, \"')\");\n    }\n  }]);\n\n  return ActivationEnd;\n}();\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  ActivationEnd.prototype.snapshot;\n}\n/**\n * An event triggered by scrolling.\n *\n * \\@publicApi\n */\n\n\nvar Scroll = /*#__PURE__*/function () {\n  /**\n   * @param {?} routerEvent\n   * @param {?} position\n   * @param {?} anchor\n   */\n  function Scroll(routerEvent, position, anchor) {\n    _classCallCheck(this, Scroll);\n\n    this.routerEvent = routerEvent;\n    this.position = position;\n    this.anchor = anchor;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Scroll, [{\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var pos = this.position ? \"\".concat(this.position[0], \", \").concat(this.position[1]) : null;\n      return \"Scroll(anchor: '\".concat(this.anchor, \"', position: '\").concat(pos, \"')\");\n    }\n  }]);\n\n  return Scroll;\n}();\n\nif (false) {\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n  Scroll.prototype.routerEvent;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  Scroll.prototype.position;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  Scroll.prototype.anchor;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n\n\nvar ɵEmptyOutletComponent = function ɵEmptyOutletComponent() {\n  _classCallCheck(this, ɵEmptyOutletComponent);\n};\n\nɵEmptyOutletComponent.decorators = [{\n  type: Component,\n  args: [{\n    template: \"<router-outlet></router-outlet>\"\n  }]\n}];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The primary routing outlet.\n *\n * \\@publicApi\n * @type {?}\n */\n\nvar PRIMARY_OUTLET = 'primary';\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * \\@publicApi\n * @record\n */\n\nfunction ParamMap() {}\n\nif (false) {\n  /**\n   * Names of the parameters in the map.\n   * @type {?}\n   */\n  ParamMap.prototype.keys;\n  /**\n   * Reports whether the map contains a given parameter.\n   * @param {?} name The parameter name.\n   * @return {?} True if the map contains the given parameter, false otherwise.\n   */\n\n  ParamMap.prototype.has = function (name) {};\n  /**\n   * Retrieves a single value for a parameter.\n   * @param {?} name The parameter name.\n   * @return {?} The parameter's single value,\n   * or the first value if the parameter has multiple values,\n   * or `null` when there is no such parameter.\n   */\n\n\n  ParamMap.prototype.get = function (name) {};\n  /**\n   * Retrieves multiple values for a parameter.\n   * @param {?} name The parameter name.\n   * @return {?} An array containing one or more values,\n   * or an empty array if there is no such parameter.\n   *\n   */\n\n\n  ParamMap.prototype.getAll = function (name) {};\n}\n\nvar ParamsAsMap = /*#__PURE__*/function () {\n  /**\n   * @param {?} params\n   */\n  function ParamsAsMap(params) {\n    _classCallCheck(this, ParamsAsMap);\n\n    this.params = params || {};\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  _createClass(ParamsAsMap, [{\n    key: \"has\",\n    value: function has(name) {\n      return this.params.hasOwnProperty(name);\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      if (this.has(name)) {\n        /** @type {?} */\n        var v = this.params[name];\n        return Array.isArray(v) ? v[0] : v;\n      }\n\n      return null;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll(name) {\n      if (this.has(name)) {\n        /** @type {?} */\n        var v = this.params[name];\n        return Array.isArray(v) ? v : [v];\n      }\n\n      return [];\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return Object.keys(this.params);\n    }\n  }]);\n\n  return ParamsAsMap;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ParamsAsMap.prototype.params;\n}\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * \\@publicApi\n * @param {?} params The instance to convert.\n * @return {?} The new map instance.\n *\n */\n\n\nfunction convertToParamMap(params) {\n  return new ParamsAsMap(params);\n}\n/** @type {?} */\n\n\nvar NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n/**\n * @param {?} message\n * @return {?}\n */\n\nfunction navigationCancelingError(message) {\n  /** @type {?} */\n  var error = Error('NavigationCancelingError: ' + message);\n\n  /** @type {?} */\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  return error;\n}\n/**\n * @param {?} error\n * @return {?}\n */\n\n\nfunction isNavigationCancelingError(error) {\n  return error &&\n  /** @type {?} */\n  error[NAVIGATION_CANCELING_ERROR];\n} // Matches the route configuration (`route`) against the actual URL (`segments`).\n\n/**\n * @param {?} segments\n * @param {?} segmentGroup\n * @param {?} route\n * @return {?}\n */\n\n\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n  /** @type {?} */\n  var parts =\n  /** @type {?} */\n  route.path.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n  /** @type {?} */\n\n\n  var posParams = {}; // Check each config part against the actual URL\n\n  for (var index = 0; index < parts.length; index++) {\n    /** @type {?} */\n    var part = parts[index];\n    /** @type {?} */\n\n    var segment = segments[index];\n    /** @type {?} */\n\n    var isParameter = part.startsWith(':');\n\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {\n    consumed: segments.slice(0, parts.length),\n    posParams: posParams\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * A configuration object that defines a single route.\n * A set of routes are collected in a `Routes` array to define a `Router` configuration.\n * The router attempts to match segments of a given URL against each route,\n * using the configuration options defined in this object.\n *\n * Supports static, parameterized, redirect, and wildcard routes, as well as\n * custom route data and resolve methods.\n *\n * For detailed usage information, see the [Routing Guide](guide/router).\n *\n * \\@usageNotes\n *\n * ### Simple Configuration\n *\n * The following route specifies that when navigating to, for example,\n * `/team/11/user/bob`, the router creates the 'Team' component\n * with the 'User' child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * ### Multiple Outlets\n *\n * The following route creates sibling components with multiple outlets.\n * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to\n * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * ### Wild Cards\n *\n * The following route uses wild-card notation to specify a component\n * that is always instantiated regardless of where you navigate to.\n *\n * ```\n * [{\n *   path: '**',\n *   component: WildcardComponent\n * }]\n * ```\n *\n * ### Redirects\n *\n * The following route uses the `redirectTo` property to ignore a segment of\n * a given URL when looking for a child path.\n *\n * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment\n * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates\n * the Team component with the User child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * The redirect path can be relative, as shown in this example, or absolute.\n * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',\n * the result URL is also absolute, '/user/jim'.\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any URL segments.\n *\n * In the following configuration, when navigating to\n * `/team/11`, the router instantiates the 'AllUsers' component.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * Empty-path routes can have children. In the following example, when navigating\n * to `/team/11/user/jim`, the router instantiates the wrapper component with\n * the user component in it.\n *\n * Note that an empty path route inherits its parent's parameters and data.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * ### Matching Strategy\n *\n * The default path-match strategy is 'prefix', which means that the router\n * checks URL elements from the left to see if the URL matches a specified path.\n * For example, '/team/11/user' matches 'team/:id'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * You can specify the path-match strategy 'full' to make sure that the path\n * covers the whole unconsumed URL. It is important to do this when redirecting\n * empty-path routes. Otherwise, because an empty path is a prefix of any URL,\n * the router would apply the redirect even when navigating to the redirect destination,\n * creating an endless loop.\n *\n * In the following example, supplying the 'full' `pathMatch` strategy ensures\n * that the router applies the redirect if and only if navigating to '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * You can share parameters between sibling components.\n * For example, suppose that two sibling components should go next to each other,\n * and both of them require an ID parameter. You can accomplish this using a route\n * that does not specify a component at the top level.\n *\n * In the following example, 'MainChild' and 'AuxChild' are siblings.\n * When navigating to 'parent/10/(a//aux:b)', the route instantiates\n * the main child and aux child components next to each other.\n * For this to work, the application component must have the primary and aux outlets defined.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * The router merges the parameters, data, and resolve of the componentless\n * parent into the parameters, data, and resolve of the children.\n *\n * This is especially useful when child components are defined\n * with an empty path string, as in the following example.\n * With this configuration, navigating to '/parent/10' creates\n * the main child and aux components.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up application load time by splitting the application\n * into multiple bundles and loading them on demand.\n * To use lazy loading, provide the `loadChildren` property  instead of the `children` property.\n *\n * Given the following example route, the router will lazy load\n * the associated module on demand using the browser native import system.\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction Route() {}\n\nif (false) {\n  /**\n   * The path to match against. Cannot be used together with a custom `matcher` function.\n   * A URL string that uses router matching notation.\n   * Can be a wild card (`**`) that matches any URL (see Usage Notes below).\n   * Default is \"/\" (the root path).\n   *\n   * @type {?|undefined}\n   */\n  Route.prototype.path;\n  /**\n   * The path-matching strategy, one of 'prefix' or 'full'.\n   * Default is 'prefix'.\n   *\n   * By default, the router checks URL elements from the left to see if the URL\n   * matches a given  path, and stops when there is a match. For example,\n   * '/team/11/user' matches 'team/:id'.\n   *\n   * The path-match strategy 'full' matches against the entire URL.\n   * It is important to do this when redirecting empty-path routes.\n   * Otherwise, because an empty path is a prefix of any URL,\n   * the router would apply the redirect even when navigating\n   * to the redirect destination, creating an endless loop.\n   *\n   * @type {?|undefined}\n   */\n\n  Route.prototype.pathMatch;\n  /**\n   * A custom URL-matching function. Cannot be used together with `path`.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.matcher;\n  /**\n   * The component to instantiate when the path matches.\n   * Can be empty if child routes specify components.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.component;\n  /**\n   * A URL to which to redirect when a the path matches.\n   * Absolute if the URL begins with a slash (/), otherwise relative to the path URL.\n   * When not present, router does not redirect.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.redirectTo;\n  /**\n   * Name of a `RouterOutlet` object where the component can be placed\n   * when the path matches.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.outlet;\n  /**\n   * An array of dependency-injection tokens used to look up `CanActivate()`\n   * handlers, in order to determine if the current user is allowed to\n   * activate the component. By default, any user can activate.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.canActivate;\n  /**\n   * An array of DI tokens used to look up `CanActivateChild()` handlers,\n   * in order to determine if the current user is allowed to activate\n   * a child of the component. By default, any user can activate a child.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.canActivateChild;\n  /**\n   * An array of DI tokens used to look up `CanDeactivate()`\n   * handlers, in order to determine if the current user is allowed to\n   * deactivate the component. By default, any user can deactivate.\n   *\n   * @type {?|undefined}\n   */\n\n  Route.prototype.canDeactivate;\n  /**\n   * An array of DI tokens used to look up `CanLoad()`\n   * handlers, in order to determine if the current user is allowed to\n   * load the component. By default, any user can load.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.canLoad;\n  /**\n   * Additional developer-defined data provided to the component via\n   * `ActivatedRoute`. By default, no additional data is passed.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.data;\n  /**\n   * A map of DI tokens used to look up data resolvers. See `Resolve`.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.resolve;\n  /**\n   * An array of child `Route` objects that specifies a nested route\n   * configuration.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.children;\n  /**\n   * A `LoadChildren` object specifying lazy-loaded child routes.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.loadChildren;\n  /**\n   * Defines when guards and resolvers will be run. One of\n   * - `paramsOrQueryParamsChange` : Run when query parameters change.\n   * - `always` : Run on every execution.\n   * By default, guards and resolvers run only when the matrix\n   * parameters of the route change.\n   * @type {?|undefined}\n   */\n\n  Route.prototype.runGuardsAndResolvers;\n  /**\n   * Filled for routes with `loadChildren` once the module has been loaded\n   * \\@internal\n   * @type {?|undefined}\n   */\n\n  Route.prototype._loadedConfig;\n}\n\nvar LoadedRouterConfig =\n/**\n * @param {?} routes\n * @param {?} module\n */\nfunction LoadedRouterConfig(routes, module) {\n  _classCallCheck(this, LoadedRouterConfig);\n\n  this.routes = routes;\n  this.module = module;\n};\n\nif (false) {\n  /** @type {?} */\n  LoadedRouterConfig.prototype.routes;\n  /** @type {?} */\n\n  LoadedRouterConfig.prototype.module;\n}\n/**\n * @param {?} config\n * @param {?=} parentPath\n * @return {?}\n */\n\n\nfunction validateConfig(config) {\n  var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  // forEach doesn't iterate undefined values\n  for (var i = 0; i < config.length; i++) {\n    /** @type {?} */\n    var route = config[i];\n    /** @type {?} */\n\n    var fullPath = getFullPath(parentPath, route);\n    validateNode(route, fullPath);\n  }\n}\n/**\n * @param {?} route\n * @param {?} fullPath\n * @return {?}\n */\n\n\nfunction validateNode(route, fullPath) {\n  if (!route) {\n    throw new Error(\"\\n      Invalid configuration of route '\".concat(fullPath, \"': Encountered undefined route.\\n      The reason might be an extra comma.\\n\\n      Example:\\n      const routes: Routes = [\\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\\n        { path: 'detail/:id', component: HeroDetailComponent }\\n      ];\\n    \"));\n  }\n\n  if (Array.isArray(route)) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': Array cannot be specified\"));\n  }\n\n  if (!route.component && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': a componentless route without children or loadChildren cannot have a named outlet set\"));\n  }\n\n  if (route.redirectTo && route.children) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and children cannot be used together\"));\n  }\n\n  if (route.redirectTo && route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and loadChildren cannot be used together\"));\n  }\n\n  if (route.children && route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': children and loadChildren cannot be used together\"));\n  }\n\n  if (route.redirectTo && route.component) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': redirectTo and component cannot be used together\"));\n  }\n\n  if (route.path && route.matcher) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': path and matcher cannot be used together\"));\n  }\n\n  if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"'. One of the following must be provided: component, redirectTo, children or loadChildren\"));\n  }\n\n  if (route.path === void 0 && route.matcher === void 0) {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': routes must have either a path or a matcher specified\"));\n  }\n\n  if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': path cannot start with a slash\"));\n  }\n\n  if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n    /** @type {?} */\n    var exp = \"The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.\";\n    throw new Error(\"Invalid configuration of route '{path: \\\"\".concat(fullPath, \"\\\", redirectTo: \\\"\").concat(route.redirectTo, \"\\\"}': please provide 'pathMatch'. \").concat(exp));\n  }\n\n  if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n    throw new Error(\"Invalid configuration of route '\".concat(fullPath, \"': pathMatch can only be set to 'prefix' or 'full'\"));\n  }\n\n  if (route.children) {\n    validateConfig(route.children, fullPath);\n  }\n}\n/**\n * @param {?} parentPath\n * @param {?} currentRoute\n * @return {?}\n */\n\n\nfunction getFullPath(parentPath, currentRoute) {\n  if (!currentRoute) {\n    return parentPath;\n  }\n\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return \"\".concat(parentPath, \"/\");\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return \"\".concat(parentPath, \"/\").concat(currentRoute.path);\n  }\n}\n/**\n * Makes a copy of the config and adds any default required properties.\n * @param {?} r\n * @return {?}\n */\n\n\nfunction standardizeConfig(r) {\n  /** @type {?} */\n  var children = r.children && r.children.map(standardizeConfig);\n  /** @type {?} */\n\n  var c = children ? Object.assign({}, r, {\n    children: children\n  }) : Object.assign({}, r);\n\n  if (!c.component && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {\n    c.component = ɵEmptyOutletComponent;\n  }\n\n  return c;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction shallowEqualArrays(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction shallowEqual(a, b) {\n  // Casting Object.keys return values to include `undefined` as there are some cases\n  // in IE 11 where this can happen. Cannot provide a test because the behavior only\n  // exists in certain circumstances in IE 11, therefore doing this cast ensures the\n  // logic is correct for when this edge case is hit.\n\n  /** @type {?} */\n  var k1 =\n  /** @type {?} */\n  Object.keys(a);\n  /** @type {?} */\n\n  var k2 =\n  /** @type {?} */\n  Object.keys(b);\n\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  /** @type {?} */\n\n\n  var key;\n\n  for (var i = 0; i < k1.length; i++) {\n    key = k1[i];\n\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Flattens single-level nested arrays.\n * @template T\n * @param {?} arr\n * @return {?}\n */\n\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n/**\n * Return the last element of an array.\n * @template T\n * @param {?} a\n * @return {?}\n */\n\n\nfunction last(a) {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n/**\n * Verifys all booleans in an array are `true`.\n * @param {?} bools\n * @return {?}\n */\n\n\nfunction and(bools) {\n  return !bools.some(\n  /**\n  * @param {?} v\n  * @return {?}\n  */\n  function (v) {\n    return !v;\n  });\n}\n/**\n * @template K, V\n * @param {?} map\n * @param {?} callback\n * @return {?}\n */\n\n\nfunction forEach(map, callback) {\n  for (var prop in map) {\n    if (map.hasOwnProperty(prop)) {\n      callback(map[prop], prop);\n    }\n  }\n}\n/**\n * @template A, B\n * @param {?} obj\n * @param {?} fn\n * @return {?}\n */\n\n\nfunction waitForMap(obj, fn) {\n  if (Object.keys(obj).length === 0) {\n    return of({});\n  }\n  /** @type {?} */\n\n\n  var waitHead = [];\n  /** @type {?} */\n\n  var waitTail = [];\n  /** @type {?} */\n\n  var res = {};\n  forEach(obj,\n  /**\n  * @param {?} a\n  * @param {?} k\n  * @return {?}\n  */\n  function (a, k) {\n    /** @type {?} */\n    var mapped = fn(k, a).pipe(map(\n    /**\n    * @param {?} r\n    * @return {?}\n    */\n    function (r) {\n      return res[k] = r;\n    }));\n\n    if (k === PRIMARY_OUTLET) {\n      waitHead.push(mapped);\n    } else {\n      waitTail.push(mapped);\n    }\n  }); // Closure compiler has problem with using spread operator here. So we use \"Array.concat\".\n  // Note that we also need to cast the new promise because TypeScript cannot infer the type\n  // when calling the \"of\" function through \"Function.apply\"\n\n  return (\n    /** @type {?} */\n    of.apply(null, waitHead.concat(waitTail)).pipe(concatAll(), last$1(), map(\n    /**\n    * @return {?}\n    */\n    function () {\n      return res;\n    }))\n  );\n}\n/**\n * @template T\n * @param {?} value\n * @return {?}\n */\n\n\nfunction wrapIntoObservable(value) {\n  if (ɵisObservable(value)) {\n    return value;\n  }\n\n  if (ɵisPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\n\nfunction createEmptyUrlTree() {\n  return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} exact\n * @return {?}\n */\n\n\nfunction containsTree(container, containee, exact) {\n  if (exact) {\n    return equalQueryParams(container.queryParams, containee.queryParams) && equalSegmentGroups(container.root, containee.root);\n  }\n\n  return containsQueryParams(container.queryParams, containee.queryParams) && containsSegmentGroup(container.root, containee.root);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction equalQueryParams(container, containee) {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction equalSegmentGroups(container, containee) {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n\n  for (var c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c])) return false;\n  }\n\n  return true;\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction containsQueryParams(container, containee) {\n  // TODO: This does not handle array params correctly.\n  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(\n  /**\n  * @param {?} key\n  * @return {?}\n  */\n  function (key) {\n    return containee[key] === container[key];\n  });\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @return {?}\n */\n\n\nfunction containsSegmentGroup(container, containee) {\n  return containsSegmentGroupHelper(container, containee, containee.segments);\n}\n/**\n * @param {?} container\n * @param {?} containee\n * @param {?} containeePaths\n * @return {?}\n */\n\n\nfunction containsSegmentGroupHelper(container, containee, containeePaths) {\n  if (container.segments.length > containeePaths.length) {\n    /** @type {?} */\n    var current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n\n    for (var c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c])) return false;\n    }\n\n    return true;\n  } else {\n    /** @type {?} */\n    var _current = containeePaths.slice(0, container.segments.length);\n    /** @type {?} */\n\n\n    var next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, _current)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n  }\n}\n/**\n * \\@description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * \\@usageNotes\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * \\@publicApi\n */\n\n\nvar UrlTree = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} root\n   * @param {?} queryParams\n   * @param {?} fragment\n   */\n  function UrlTree(root, queryParams, fragment) {\n    _classCallCheck(this, UrlTree);\n\n    this.root = root;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlTree, [{\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = convertToParamMap(this.queryParams);\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return DEFAULT_SERIALIZER.serialize(this);\n    }\n  }]);\n\n  return UrlTree;\n}();\n\nif (false) {\n  /**\n   * \\@internal\n   * @type {?}\n   */\n  UrlTree.prototype._queryParamMap;\n  /**\n   * The root segment group of the URL tree\n   * @type {?}\n   */\n\n  UrlTree.prototype.root;\n  /**\n   * The query params of the URL\n   * @type {?}\n   */\n\n  UrlTree.prototype.queryParams;\n  /**\n   * The fragment of the URL\n   * @type {?}\n   */\n\n  UrlTree.prototype.fragment;\n}\n/**\n * \\@description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * \\@publicApi\n */\n\n\nvar UrlSegmentGroup = /*#__PURE__*/function () {\n  /**\n   * @param {?} segments\n   * @param {?} children\n   */\n  function UrlSegmentGroup(segments, children) {\n    var _this10 = this;\n\n    _classCallCheck(this, UrlSegmentGroup);\n\n    this.segments = segments;\n    this.children = children;\n    /**\n     * The parent node in the url tree\n     */\n\n    this.parent = null;\n    forEach(children,\n    /**\n    * @template THIS\n    * @this {THIS}\n    * @param {?} v\n    * @param {?} k\n    * @return {THIS}\n    */\n    function (v, k) {\n      return v.parent = _this10;\n    });\n  }\n  /**\n   * Whether the segment has child segments\n   * @return {?}\n   */\n\n\n  _createClass(UrlSegmentGroup, [{\n    key: \"hasChildren\",\n    value: function hasChildren() {\n      return this.numberOfChildren > 0;\n    }\n    /**\n     * Number of child segments\n     * @return {?}\n     */\n\n  }, {\n    key: \"numberOfChildren\",\n    get: function get() {\n      return Object.keys(this.children).length;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializePaths(this);\n    }\n  }]);\n\n  return UrlSegmentGroup;\n}();\n\nif (false) {\n  /**\n   * \\@internal\n   * @type {?}\n   */\n  UrlSegmentGroup.prototype._sourceSegment;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  UrlSegmentGroup.prototype._segmentIndexShift;\n  /**\n   * The parent node in the url tree\n   * @type {?}\n   */\n\n  UrlSegmentGroup.prototype.parent;\n  /**\n   * The URL segments of this group. See `UrlSegment` for more information\n   * @type {?}\n   */\n\n  UrlSegmentGroup.prototype.segments;\n  /**\n   * The list of children of this group\n   * @type {?}\n   */\n\n  UrlSegmentGroup.prototype.children;\n}\n/**\n * \\@description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * \\@usageNotes\n *  ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * \\@publicApi\n */\n\n\nvar UrlSegment = /*#__PURE__*/function () {\n  /**\n   * @param {?} path\n   * @param {?} parameters\n   */\n  function UrlSegment(path, parameters) {\n    _classCallCheck(this, UrlSegment);\n\n    this.path = path;\n    this.parameters = parameters;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlSegment, [{\n    key: \"parameterMap\",\n    get: function get() {\n      if (!this._parameterMap) {\n        this._parameterMap = convertToParamMap(this.parameters);\n      }\n\n      return this._parameterMap;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializePath(this);\n    }\n  }]);\n\n  return UrlSegment;\n}();\n\nif (false) {\n  /**\n   * \\@internal\n   * @type {?}\n   */\n  UrlSegment.prototype._parameterMap;\n  /**\n   * The path part of a URL segment\n   * @type {?}\n   */\n\n  UrlSegment.prototype.path;\n  /**\n   * The matrix parameters associated with a segment\n   * @type {?}\n   */\n\n  UrlSegment.prototype.parameters;\n}\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\n\n\nfunction equalSegments(as, bs) {\n  return equalPath(as, bs) && as.every(\n  /**\n  * @param {?} a\n  * @param {?} i\n  * @return {?}\n  */\n  function (a, i) {\n    return shallowEqual(a.parameters, bs[i].parameters);\n  });\n}\n/**\n * @param {?} as\n * @param {?} bs\n * @return {?}\n */\n\n\nfunction equalPath(as, bs) {\n  if (as.length !== bs.length) return false;\n  return as.every(\n  /**\n  * @param {?} a\n  * @param {?} i\n  * @return {?}\n  */\n  function (a, i) {\n    return a.path === bs[i].path;\n  });\n}\n/**\n * @template T\n * @param {?} segment\n * @param {?} fn\n * @return {?}\n */\n\n\nfunction mapChildrenIntoArray(segment, fn) {\n  /** @type {?} */\n  var res = [];\n  forEach(segment.children,\n  /**\n  * @param {?} child\n  * @param {?} childOutlet\n  * @return {?}\n  */\n  function (child, childOutlet) {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  forEach(segment.children,\n  /**\n  * @param {?} child\n  * @param {?} childOutlet\n  * @return {?}\n  */\n  function (child, childOutlet) {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n/**\n * \\@description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * \\@publicApi\n * @abstract\n */\n\n\nvar UrlSerializer = function UrlSerializer() {\n  _classCallCheck(this, UrlSerializer);\n};\n\nif (false) {\n  /**\n   * Parse a url into a `UrlTree`\n   * @abstract\n   * @param {?} url\n   * @return {?}\n   */\n  UrlSerializer.prototype.parse = function (url) {};\n  /**\n   * Converts a `UrlTree` into a url\n   * @abstract\n   * @param {?} tree\n   * @return {?}\n   */\n\n\n  UrlSerializer.prototype.serialize = function (tree) {};\n}\n/**\n * \\@description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * \\@publicApi\n */\n\n\nvar DefaultUrlSerializer = /*#__PURE__*/function () {\n  function DefaultUrlSerializer() {\n    _classCallCheck(this, DefaultUrlSerializer);\n  }\n\n  _createClass(DefaultUrlSerializer, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses a url into a `UrlTree`\n     * @param {?} url\n     * @return {?}\n     */\n    function parse(url) {\n      /** @type {?} */\n      var p = new UrlParser(url);\n      return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    }\n    /**\n     * Converts a `UrlTree` into a url\n     * @param {?} tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize(tree) {\n      /** @type {?} */\n      var segment = \"/\".concat(serializeSegment(tree.root, true));\n      /** @type {?} */\n\n      var query = serializeQueryParams(tree.queryParams);\n      /** @type {?} */\n\n      var fragment = typeof tree.fragment === \"string\" ? \"#\".concat(encodeUriFragment(\n      /** @type {?} */\n      tree.fragment)) : '';\n      return \"\".concat(segment).concat(query).concat(fragment);\n    }\n  }]);\n\n  return DefaultUrlSerializer;\n}();\n/** @type {?} */\n\n\nvar DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n/**\n * @param {?} segment\n * @return {?}\n */\n\nfunction serializePaths(segment) {\n  return segment.segments.map(\n  /**\n  * @param {?} p\n  * @return {?}\n  */\n  function (p) {\n    return serializePath(p);\n  }).join('/');\n}\n/**\n * @param {?} segment\n * @param {?} root\n * @return {?}\n */\n\n\nfunction serializeSegment(segment, root) {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    /** @type {?} */\n    var primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';\n    /** @type {?} */\n\n    var children = [];\n    forEach(segment.children,\n    /**\n    * @param {?} v\n    * @param {?} k\n    * @return {?}\n    */\n    function (v, k) {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(\"\".concat(k, \":\").concat(serializeSegment(v, false)));\n      }\n    });\n    return children.length > 0 ? \"\".concat(primary, \"(\").concat(children.join('//'), \")\") : primary;\n  } else {\n    /** @type {?} */\n    var _children = mapChildrenIntoArray(segment,\n    /**\n    * @param {?} v\n    * @param {?} k\n    * @return {?}\n    */\n    function (v, k) {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [\"\".concat(k, \":\").concat(serializeSegment(v, false))];\n    });\n\n    return \"\".concat(serializePaths(segment), \"/(\").concat(_children.join('//'), \")\");\n  }\n}\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriString(s) {\n  return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');\n}\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriQuery(s) {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriFragment(s) {\n  return encodeURI(s);\n}\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n * @param {?} s\n * @return {?}\n */\n\n\nfunction encodeUriSegment(s) {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction decode(s) {\n  return decodeURIComponent(s);\n} // Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\n\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction decodeQuery(s) {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n/**\n * @param {?} path\n * @return {?}\n */\n\n\nfunction serializePath(path) {\n  return \"\".concat(encodeUriSegment(path.path)).concat(serializeMatrixParams(path.parameters));\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction serializeMatrixParams(params) {\n  return Object.keys(params).map(\n  /**\n  * @param {?} key\n  * @return {?}\n  */\n  function (key) {\n    return \";\".concat(encodeUriSegment(key), \"=\").concat(encodeUriSegment(params[key]));\n  }).join('');\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction serializeQueryParams(params) {\n  /** @type {?} */\n  var strParams = Object.keys(params).map(\n  /**\n  * @param {?} name\n  * @return {?}\n  */\n  function (name) {\n    /** @type {?} */\n    var value = params[name];\n    return Array.isArray(value) ? value.map(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    function (v) {\n      return \"\".concat(encodeUriQuery(name), \"=\").concat(encodeUriQuery(v));\n    }).join('&') : \"\".concat(encodeUriQuery(name), \"=\").concat(encodeUriQuery(value));\n  });\n  return strParams.length ? \"?\".concat(strParams.join(\"&\")) : '';\n}\n/** @type {?} */\n\n\nvar SEGMENT_RE = /^[^\\/()?;=#]+/;\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchSegments(str) {\n  /** @type {?} */\n  var match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n/** @type {?} */\n\n\nvar QUERY_PARAM_RE = /^[^=?&#]+/; // Return the name of the query param at the start of the string or an empty string\n\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchQueryParams(str) {\n  /** @type {?} */\n  var match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n/** @type {?} */\n\n\nvar QUERY_PARAM_VALUE_RE = /^[^?&#]+/; // Return the value of the query param at the start of the string or an empty string\n\n/**\n * @param {?} str\n * @return {?}\n */\n\nfunction matchUrlQueryParamValue(str) {\n  /** @type {?} */\n  var match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nvar UrlParser = /*#__PURE__*/function () {\n  /**\n   * @param {?} url\n   */\n  function UrlParser(url) {\n    _classCallCheck(this, UrlParser);\n\n    this.url = url;\n    this.remaining = url;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(UrlParser, [{\n    key: \"parseRootSegment\",\n    value: function parseRootSegment() {\n      this.consumeOptional('/');\n\n      if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n        return new UrlSegmentGroup([], {});\n      } // The root segment group never has segments\n\n\n      return new UrlSegmentGroup([], this.parseChildren());\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseQueryParams\",\n    value: function parseQueryParams() {\n      /** @type {?} */\n      var params = {};\n\n      if (this.consumeOptional('?')) {\n        do {\n          this.parseQueryParam(params);\n        } while (this.consumeOptional('&'));\n      }\n\n      return params;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseFragment\",\n    value: function parseFragment() {\n      return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseChildren\",\n    value: function parseChildren() {\n      if (this.remaining === '') {\n        return {};\n      }\n\n      this.consumeOptional('/');\n      /** @type {?} */\n\n      var segments = [];\n\n      if (!this.peekStartsWith('(')) {\n        segments.push(this.parseSegment());\n      }\n\n      while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n        this.capture('/');\n        segments.push(this.parseSegment());\n      }\n      /** @type {?} */\n\n\n      var children = {};\n\n      if (this.peekStartsWith('/(')) {\n        this.capture('/');\n        children = this.parseParens(true);\n      }\n      /** @type {?} */\n\n\n      var res = {};\n\n      if (this.peekStartsWith('(')) {\n        res = this.parseParens(false);\n      }\n\n      if (segments.length > 0 || Object.keys(children).length > 0) {\n        res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n      }\n\n      return res;\n    } // parse a segment with its matrix parameters\n    // ie `name;k1=v1;k2`\n\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseSegment\",\n    value: function parseSegment() {\n      /** @type {?} */\n      var path = matchSegments(this.remaining);\n\n      if (path === '' && this.peekStartsWith(';')) {\n        throw new Error(\"Empty path url segment cannot have parameters: '\".concat(this.remaining, \"'.\"));\n      }\n\n      this.capture(path);\n      return new UrlSegment(decode(path), this.parseMatrixParams());\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseMatrixParams\",\n    value: function parseMatrixParams() {\n      /** @type {?} */\n      var params = {};\n\n      while (this.consumeOptional(';')) {\n        this.parseParam(params);\n      }\n\n      return params;\n    }\n    /**\n     * @private\n     * @param {?} params\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseParam\",\n    value: function parseParam(params) {\n      /** @type {?} */\n      var key = matchSegments(this.remaining);\n\n      if (!key) {\n        return;\n      }\n\n      this.capture(key);\n      /** @type {?} */\n\n      var value = '';\n\n      if (this.consumeOptional('=')) {\n        /** @type {?} */\n        var valueMatch = matchSegments(this.remaining);\n\n        if (valueMatch) {\n          value = valueMatch;\n          this.capture(value);\n        }\n      }\n\n      params[decode(key)] = decode(value);\n    } // Parse a single query parameter `name[=value]`\n\n    /**\n     * @private\n     * @param {?} params\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseQueryParam\",\n    value: function parseQueryParam(params) {\n      /** @type {?} */\n      var key = matchQueryParams(this.remaining);\n\n      if (!key) {\n        return;\n      }\n\n      this.capture(key);\n      /** @type {?} */\n\n      var value = '';\n\n      if (this.consumeOptional('=')) {\n        /** @type {?} */\n        var valueMatch = matchUrlQueryParamValue(this.remaining);\n\n        if (valueMatch) {\n          value = valueMatch;\n          this.capture(value);\n        }\n      }\n      /** @type {?} */\n\n\n      var decodedKey = decodeQuery(key);\n      /** @type {?} */\n\n      var decodedVal = decodeQuery(value);\n\n      if (params.hasOwnProperty(decodedKey)) {\n        // Append to existing values\n\n        /** @type {?} */\n        var currentVal = params[decodedKey];\n\n        if (!Array.isArray(currentVal)) {\n          currentVal = [currentVal];\n          params[decodedKey] = currentVal;\n        }\n\n        currentVal.push(decodedVal);\n      } else {\n        // Create a new value\n        params[decodedKey] = decodedVal;\n      }\n    } // parse `(a/b//outlet_name:c/d)`\n\n    /**\n     * @private\n     * @param {?} allowPrimary\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseParens\",\n    value: function parseParens(allowPrimary) {\n      /** @type {?} */\n      var segments = {};\n      this.capture('(');\n\n      while (!this.consumeOptional(')') && this.remaining.length > 0) {\n        /** @type {?} */\n        var path = matchSegments(this.remaining);\n        /** @type {?} */\n\n        var next = this.remaining[path.length]; // if is is not one of these characters, then the segment was unescaped\n        // or the group was not closed\n\n        if (next !== '/' && next !== ')' && next !== ';') {\n          throw new Error(\"Cannot parse url '\".concat(this.url, \"'\"));\n        }\n        /** @type {?} */\n\n\n        var outletName =\n        /** @type {?} */\n        undefined;\n\n        if (path.indexOf(':') > -1) {\n          outletName = path.substr(0, path.indexOf(':'));\n          this.capture(outletName);\n          this.capture(':');\n        } else if (allowPrimary) {\n          outletName = PRIMARY_OUTLET;\n        }\n        /** @type {?} */\n\n\n        var children = this.parseChildren();\n        segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);\n        this.consumeOptional('//');\n      }\n\n      return segments;\n    }\n    /**\n     * @private\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"peekStartsWith\",\n    value: function peekStartsWith(str) {\n      return this.remaining.startsWith(str);\n    } // Consumes the prefix when it is present and returns whether it has been consumed\n\n    /**\n     * @private\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"consumeOptional\",\n    value: function consumeOptional(str) {\n      if (this.peekStartsWith(str)) {\n        this.remaining = this.remaining.substring(str.length);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @private\n     * @param {?} str\n     * @return {?}\n     */\n\n  }, {\n    key: \"capture\",\n    value: function capture(str) {\n      if (!this.consumeOptional(str)) {\n        throw new Error(\"Expected \\\"\".concat(str, \"\\\".\"));\n      }\n    }\n  }]);\n\n  return UrlParser;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  UrlParser.prototype.remaining;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  UrlParser.prototype.url;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @template T\n */\n\n\nvar Tree = /*#__PURE__*/function () {\n  /**\n   * @param {?} root\n   */\n  function Tree(root) {\n    _classCallCheck(this, Tree);\n\n    this._root = root;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Tree, [{\n    key: \"root\",\n    get: function get() {\n      return this._root.value;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    value: function parent(t) {\n      /** @type {?} */\n      var p = this.pathFromRoot(t);\n      return p.length > 1 ? p[p.length - 2] : null;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    value: function children(t) {\n      /** @type {?} */\n      var n = findNode(t, this._root);\n      return n ? n.children.map(\n      /**\n      * @param {?} t\n      * @return {?}\n      */\n      function (t) {\n        return t.value;\n      }) : [];\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    value: function firstChild(t) {\n      /** @type {?} */\n      var n = findNode(t, this._root);\n      return n && n.children.length > 0 ? n.children[0].value : null;\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"siblings\",\n    value: function siblings(t) {\n      /** @type {?} */\n      var p = findPath(t, this._root);\n      if (p.length < 2) return [];\n      /** @type {?} */\n\n      var c = p[p.length - 2].children.map(\n      /**\n      * @param {?} c\n      * @return {?}\n      */\n      function (c) {\n        return c.value;\n      });\n      return c.filter(\n      /**\n      * @param {?} cc\n      * @return {?}\n      */\n      function (cc) {\n        return cc !== t;\n      });\n    }\n    /**\n     * \\@internal\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    value: function pathFromRoot(t) {\n      return findPath(t, this._root).map(\n      /**\n      * @param {?} s\n      * @return {?}\n      */\n      function (s) {\n        return s.value;\n      });\n    }\n  }]);\n\n  return Tree;\n}();\n\nif (false) {\n  /**\n   * \\@internal\n   * @type {?}\n   */\n  Tree.prototype._root;\n} // DFS for the node matching the value\n\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\n\n\nfunction findNode(value, node) {\n  if (value === node.value) return node;\n\n  var _iterator = _createForOfIteratorHelper(node.children),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n\n      /** @type {?} */\n      var _node = findNode(value, child);\n\n      if (_node) return _node;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n} // Return the path to the node with the given value using DFS\n\n/**\n * @template T\n * @param {?} value\n * @param {?} node\n * @return {?}\n */\n\n\nfunction findPath(value, node) {\n  if (value === node.value) return [node];\n\n  var _iterator2 = _createForOfIteratorHelper(node.children),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n\n      /** @type {?} */\n      var path = findPath(value, child);\n\n      if (path.length) {\n        path.unshift(node);\n        return path;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return [];\n}\n/**\n * @template T\n */\n\n\nvar TreeNode = /*#__PURE__*/function () {\n  /**\n   * @param {?} value\n   * @param {?} children\n   */\n  function TreeNode(value, children) {\n    _classCallCheck(this, TreeNode);\n\n    this.value = value;\n    this.children = children;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(TreeNode, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"TreeNode(\".concat(this.value, \")\");\n    }\n  }]);\n\n  return TreeNode;\n}();\n\nif (false) {\n  /** @type {?} */\n  TreeNode.prototype.value;\n  /** @type {?} */\n\n  TreeNode.prototype.children;\n} // Return the list of T indexed by outlet name\n\n/**\n * @template T\n * @param {?} node\n * @return {?}\n */\n\n\nfunction nodeChildrenAsMap(node) {\n  /** @type {?} */\n  var map = {};\n\n  if (node) {\n    node.children.forEach(\n    /**\n    * @param {?} child\n    * @return {?}\n    */\n    function (child) {\n      return map[child.value.outlet] = child;\n    });\n  }\n\n  return map;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * \\@usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see `ActivatedRoute`\n *\n * \\@publicApi\n */\n\n\nvar RouterState = /*#__PURE__*/function (_Tree) {\n  _inherits(RouterState, _Tree);\n\n  var _super10 = _createSuper(RouterState);\n\n  /**\n   * \\@internal\n   * @param {?} root\n   * @param {?} snapshot\n   */\n  function RouterState(root, snapshot) {\n    var _this11;\n\n    _classCallCheck(this, RouterState);\n\n    _this11 = _super10.call(this, root);\n    _this11.snapshot = snapshot;\n    setRouterState(\n    /** @type {?} */\n    _assertThisInitialized(_this11), root);\n    return _this11;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterState, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.snapshot.toString();\n    }\n  }]);\n\n  return RouterState;\n}(Tree);\n\nif (false) {\n  /**\n   * The current snapshot of the router state\n   * @type {?}\n   */\n  RouterState.prototype.snapshot;\n}\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\n\n\nfunction createEmptyState(urlTree, rootComponent) {\n  /** @type {?} */\n  var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n  /** @type {?} */\n\n  var emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  /** @type {?} */\n\n  var emptyParams = new BehaviorSubject({});\n  /** @type {?} */\n\n  var emptyData = new BehaviorSubject({});\n  /** @type {?} */\n\n  var emptyQueryParams = new BehaviorSubject({});\n  /** @type {?} */\n\n  var fragment = new BehaviorSubject('');\n  /** @type {?} */\n\n  var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode(activated, []), snapshot);\n}\n/**\n * @param {?} urlTree\n * @param {?} rootComponent\n * @return {?}\n */\n\n\nfunction createEmptyStateSnapshot(urlTree, rootComponent) {\n  /** @type {?} */\n  var emptyParams = {};\n  /** @type {?} */\n\n  var emptyData = {};\n  /** @type {?} */\n\n  var emptyQueryParams = {};\n  /** @type {?} */\n\n  var fragment = '';\n  /** @type {?} */\n\n  var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\n  return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * {\\@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * \\@publicApi\n */\n\n\nvar ActivatedRoute = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} params\n   * @param {?} queryParams\n   * @param {?} fragment\n   * @param {?} data\n   * @param {?} outlet\n   * @param {?} component\n   * @param {?} futureSnapshot\n   */\n  function ActivatedRoute(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {\n    _classCallCheck(this, ActivatedRoute);\n\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this._futureSnapshot = futureSnapshot;\n  }\n  /**\n   * The configuration used to match this route.\n   * @return {?}\n   */\n\n\n  _createClass(ActivatedRoute, [{\n    key: \"routeConfig\",\n    get: function get() {\n      return this._futureSnapshot.routeConfig;\n    }\n    /**\n     * The root of the router state.\n     * @return {?}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this._routerState.root;\n    }\n    /**\n     * The parent of this route in the router state tree.\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._routerState.parent(this);\n    }\n    /**\n     * The first child of this route in the router state tree.\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this._routerState.firstChild(this);\n    }\n    /**\n     * The children of this route in the router state tree.\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._routerState.children(this);\n    }\n    /**\n     * The path from the root of the router state tree to this route.\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    get: function get() {\n      return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * An Observable that contains a map of the required and optional parameters\n     * specific to the route.\n     * The map supports retrieving single and multiple values from the same parameter.\n     * @return {?}\n     */\n\n  }, {\n    key: \"paramMap\",\n    get: function get() {\n      if (!this._paramMap) {\n        this._paramMap = this.params.pipe(map(\n        /**\n        * @param {?} p\n        * @return {?}\n        */\n        function (p) {\n          return convertToParamMap(p);\n        }));\n      }\n\n      return this._paramMap;\n    }\n    /**\n     * An Observable that contains a map of the query parameters available to all routes.\n     * The map supports retrieving single and multiple values from the query parameter.\n     * @return {?}\n     */\n\n  }, {\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = this.queryParams.pipe(map(\n        /**\n        * @param {?} p\n        * @return {?}\n        */\n        function (p) {\n          return convertToParamMap(p);\n        }));\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.snapshot ? this.snapshot.toString() : \"Future(\".concat(this._futureSnapshot, \")\");\n    }\n  }]);\n\n  return ActivatedRoute;\n}();\n\nif (false) {\n  /**\n   * The current snapshot of this route\n   * @type {?}\n   */\n  ActivatedRoute.prototype.snapshot;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype._futureSnapshot;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype._routerState;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype._paramMap;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype._queryParamMap;\n  /**\n   * An observable of the URL segments matched by this route.\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype.url;\n  /**\n   * An observable of the matrix parameters scoped to this route.\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype.params;\n  /**\n   * An observable of the query parameters shared by all the routes.\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype.queryParams;\n  /**\n   * An observable of the URL fragment shared by all the routes.\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype.fragment;\n  /**\n   * An observable of the static and resolved data of this route.\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype.data;\n  /**\n   * The outlet name of the route, a constant.\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype.outlet;\n  /**\n   * The component of the route, a constant.\n   * @type {?}\n   */\n\n  ActivatedRoute.prototype.component;\n}\n/**\n * Returns the inherited params, data, and resolve for a given route.\n * By default, this only inherits values up to the nearest path-less or component-less route.\n * \\@internal\n * @param {?} route\n * @param {?=} paramsInheritanceStrategy\n * @return {?}\n */\n\n\nfunction inheritedParamsDataResolve(route) {\n  var paramsInheritanceStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'emptyOnly';\n\n  /** @type {?} */\n  var pathFromRoot = route.pathFromRoot;\n  /** @type {?} */\n\n  var inheritingStartingFrom = 0;\n\n  if (paramsInheritanceStrategy !== 'always') {\n    inheritingStartingFrom = pathFromRoot.length - 1;\n\n    while (inheritingStartingFrom >= 1) {\n      /** @type {?} */\n      var current = pathFromRoot[inheritingStartingFrom];\n      /** @type {?} */\n\n      var parent = pathFromRoot[inheritingStartingFrom - 1]; // current route is an empty path => inherits its parent's params and data\n\n      if (current.routeConfig && current.routeConfig.path === '') {\n        inheritingStartingFrom--; // parent is componentless => current route should inherit its params and data\n      } else if (!parent.component) {\n        inheritingStartingFrom--;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));\n}\n/**\n * \\@internal\n * @param {?} pathFromRoot\n * @return {?}\n */\n\n\nfunction flattenInherited(pathFromRoot) {\n  return pathFromRoot.reduce(\n  /**\n  * @param {?} res\n  * @param {?} curr\n  * @return {?}\n  */\n  function (res, curr) {\n    /** @type {?} */\n    var params = Object.assign({}, res.params, curr.params);\n    /** @type {?} */\n\n    var data = Object.assign({}, res.data, curr.data);\n    /** @type {?} */\n\n    var resolve = Object.assign({}, res.resolve, curr._resolvedData);\n    return {\n      params: params,\n      data: data,\n      resolve: resolve\n    };\n  },\n  /** @type {?} */\n  {\n    params: {},\n    data: {},\n    resolve: {}\n  });\n}\n/**\n * \\@description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * ```\n * \\@Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * \\@publicApi\n */\n\n\nvar ActivatedRouteSnapshot = /*#__PURE__*/function () {\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} params\n   * @param {?} queryParams\n   * @param {?} fragment\n   * @param {?} data\n   * @param {?} outlet\n   * @param {?} component\n   * @param {?} routeConfig\n   * @param {?} urlSegment\n   * @param {?} lastPathIndex\n   * @param {?} resolve\n   */\n  function ActivatedRouteSnapshot(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {\n    _classCallCheck(this, ActivatedRouteSnapshot);\n\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this.routeConfig = routeConfig;\n    this._urlSegment = urlSegment;\n    this._lastPathIndex = lastPathIndex;\n    this._resolve = resolve;\n  }\n  /**\n   * The root of the router state\n   * @return {?}\n   */\n\n\n  _createClass(ActivatedRouteSnapshot, [{\n    key: \"root\",\n    get: function get() {\n      return this._routerState.root;\n    }\n    /**\n     * The parent of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._routerState.parent(this);\n    }\n    /**\n     * The first child of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this._routerState.firstChild(this);\n    }\n    /**\n     * The children of this route in the router state tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._routerState.children(this);\n    }\n    /**\n     * The path from the root of the router state tree to this route\n     * @return {?}\n     */\n\n  }, {\n    key: \"pathFromRoot\",\n    get: function get() {\n      return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"paramMap\",\n    get: function get() {\n      if (!this._paramMap) {\n        this._paramMap = convertToParamMap(this.params);\n      }\n\n      return this._paramMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"queryParamMap\",\n    get: function get() {\n      if (!this._queryParamMap) {\n        this._queryParamMap = convertToParamMap(this.queryParams);\n      }\n\n      return this._queryParamMap;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      /** @type {?} */\n      var url = this.url.map(\n      /**\n      * @param {?} segment\n      * @return {?}\n      */\n      function (segment) {\n        return segment.toString();\n      }).join('/');\n      /** @type {?} */\n\n      var matched = this.routeConfig ? this.routeConfig.path : '';\n      return \"Route(url:'\".concat(url, \"', path:'\").concat(matched, \"')\");\n    }\n  }]);\n\n  return ActivatedRouteSnapshot;\n}();\n\nif (false) {\n  /**\n   * The configuration used to match this route *\n   * @type {?}\n   */\n  ActivatedRouteSnapshot.prototype.routeConfig;\n  /**\n   * \\@internal *\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype._urlSegment;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype._lastPathIndex;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype._resolve;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype._resolvedData;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype._routerState;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype._paramMap;\n  /**\n   * \\@internal\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype._queryParamMap;\n  /**\n   * The URL segments matched by this route\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype.url;\n  /**\n   * The matrix parameters scoped to this route\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype.params;\n  /**\n   * The query parameters shared by all the routes\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype.queryParams;\n  /**\n   * The URL fragment shared by all the routes\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype.fragment;\n  /**\n   * The static and resolved data of this route\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype.data;\n  /**\n   * The outlet name of the route\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype.outlet;\n  /**\n   * The component of the route\n   * @type {?}\n   */\n\n  ActivatedRouteSnapshot.prototype.component;\n}\n/**\n * \\@description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * \\@usageNotes\n * ### Example\n *\n * ```\n * \\@Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * \\@publicApi\n */\n\n\nvar RouterStateSnapshot = /*#__PURE__*/function (_Tree2) {\n  _inherits(RouterStateSnapshot, _Tree2);\n\n  var _super11 = _createSuper(RouterStateSnapshot);\n\n  /**\n   * \\@internal\n   * @param {?} url\n   * @param {?} root\n   */\n  function RouterStateSnapshot(url, root) {\n    var _this12;\n\n    _classCallCheck(this, RouterStateSnapshot);\n\n    _this12 = _super11.call(this, root);\n    _this12.url = url;\n    setRouterState(\n    /** @type {?} */\n    _assertThisInitialized(_this12), root);\n    return _this12;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterStateSnapshot, [{\n    key: \"toString\",\n    value: function toString() {\n      return serializeNode(this._root);\n    }\n  }]);\n\n  return RouterStateSnapshot;\n}(Tree);\n\nif (false) {\n  /**\n   * The url from which this snapshot was created\n   * @type {?}\n   */\n  RouterStateSnapshot.prototype.url;\n}\n/**\n * @template U, T\n * @param {?} state\n * @param {?} node\n * @return {?}\n */\n\n\nfunction setRouterState(state, node) {\n  node.value._routerState = state;\n  node.children.forEach(\n  /**\n  * @param {?} c\n  * @return {?}\n  */\n  function (c) {\n    return setRouterState(state, c);\n  });\n}\n/**\n * @param {?} node\n * @return {?}\n */\n\n\nfunction serializeNode(node) {\n  /** @type {?} */\n  var c = node.children.length > 0 ? \" { \".concat(node.children.map(serializeNode).join(', '), \" } \") : '';\n  return \"\".concat(node.value).concat(c);\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n * @param {?} route\n * @return {?}\n */\n\n\nfunction advanceActivatedRoute(route) {\n  if (route.snapshot) {\n    /** @type {?} */\n    var currentSnapshot = route.snapshot;\n    /** @type {?} */\n\n    var nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      /** @type {?} */\n      route.queryParams.next(nextSnapshot.queryParams);\n    }\n\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      /** @type {?} */\n      route.fragment.next(nextSnapshot.fragment);\n    }\n\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      /** @type {?} */\n      route.params.next(nextSnapshot.params);\n    }\n\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      /** @type {?} */\n      route.url.next(nextSnapshot.url);\n    }\n\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      /** @type {?} */\n      route.data.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot; // this is for resolved data\n\n    /** @type {?} */\n    route.data.next(route._futureSnapshot.data);\n  }\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction equalParamsAndUrlSegments(a, b) {\n  /** @type {?} */\n  var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  /** @type {?} */\n\n  var parentsMismatch = !a.parent !== !b.parent;\n  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent,\n  /** @type {?} */\n  b.parent));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\n\n\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n  /** @type {?} */\n  var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?=} prevState\n * @return {?}\n */\n\n\nfunction createNode(routeReuseStrategy, curr, prevState) {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    /** @type {?} */\n    var value = prevState.value;\n    value._futureSnapshot = curr.value;\n    /** @type {?} */\n\n    var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode(value, children); // retrieve an activated route that is used to be displayed, but is not currently displayed\n  } else {\n    /** @type {?} */\n    var detachedRouteHandle =\n    /** @type {?} */\n    routeReuseStrategy.retrieve(curr.value);\n\n    if (detachedRouteHandle) {\n      /** @type {?} */\n      var _tree = detachedRouteHandle.route;\n      setFutureSnapshotsOfActivatedRoutes(curr, _tree);\n      return _tree;\n    } else {\n      /** @type {?} */\n      var _value = createActivatedRoute(curr.value);\n      /** @type {?} */\n\n\n      var _children2 = curr.children.map(\n      /**\n      * @param {?} c\n      * @return {?}\n      */\n      function (c) {\n        return createNode(routeReuseStrategy, c);\n      });\n\n      return new TreeNode(_value, _children2);\n    }\n  }\n}\n/**\n * @param {?} curr\n * @param {?} result\n * @return {?}\n */\n\n\nfunction setFutureSnapshotsOfActivatedRoutes(curr, result) {\n  if (curr.value.routeConfig !== result.value.routeConfig) {\n    throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n  }\n\n  if (curr.children.length !== result.children.length) {\n    throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n  }\n\n  result.value._futureSnapshot = curr.value;\n\n  for (var i = 0; i < curr.children.length; ++i) {\n    setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n  }\n}\n/**\n * @param {?} routeReuseStrategy\n * @param {?} curr\n * @param {?} prevState\n * @return {?}\n */\n\n\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n  return curr.children.map(\n  /**\n  * @param {?} child\n  * @return {?}\n  */\n  function (child) {\n    var _iterator3 = _createForOfIteratorHelper(prevState.children),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var p = _step3.value;\n\n        if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n          return createNode(routeReuseStrategy, child, p);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return createNode(routeReuseStrategy, child);\n  });\n}\n/**\n * @param {?} c\n * @return {?}\n */\n\n\nfunction createActivatedRoute(c) {\n  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} route\n * @param {?} urlTree\n * @param {?} commands\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\n\n\nfunction _createUrlTree(route, urlTree, commands, queryParams, fragment) {\n  if (commands.length === 0) {\n    return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n  }\n  /** @type {?} */\n\n\n  var nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n  }\n  /** @type {?} */\n\n\n  var startingPosition = findStartingPosition(nav, urlTree, route);\n  /** @type {?} */\n\n  var segmentGroup = startingPosition.processChildren ? updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) : updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n  return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n}\n/**\n * @param {?} command\n * @return {?}\n */\n\n\nfunction isMatrixParams(command) {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * @param {?} oldSegmentGroup\n * @param {?} newSegmentGroup\n * @param {?} urlTree\n * @param {?} queryParams\n * @param {?} fragment\n * @return {?}\n */\n\n\nfunction tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\n  /** @type {?} */\n  var qp = {};\n\n  if (queryParams) {\n    forEach(queryParams,\n    /**\n    * @param {?} value\n    * @param {?} name\n    * @return {?}\n    */\n    function (value, name) {\n      qp[name] = Array.isArray(value) ? value.map(\n      /**\n      * @param {?} v\n      * @return {?}\n      */\n      function (v) {\n        return \"\".concat(v);\n      }) : \"\".concat(value);\n    });\n  }\n\n  if (urlTree.root === oldSegmentGroup) {\n    return new UrlTree(newSegmentGroup, qp, fragment);\n  }\n\n  return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);\n}\n/**\n * @param {?} current\n * @param {?} oldSegment\n * @param {?} newSegment\n * @return {?}\n */\n\n\nfunction replaceSegment(current, oldSegment, newSegment) {\n  /** @type {?} */\n  var children = {};\n  forEach(current.children,\n  /**\n  * @param {?} c\n  * @param {?} outletName\n  * @return {?}\n  */\n  function (c, outletName) {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nvar Navigation = /*#__PURE__*/function () {\n  /**\n   * @param {?} isAbsolute\n   * @param {?} numberOfDoubleDots\n   * @param {?} commands\n   */\n  function Navigation(isAbsolute, numberOfDoubleDots, commands) {\n    _classCallCheck(this, Navigation);\n\n    this.isAbsolute = isAbsolute;\n    this.numberOfDoubleDots = numberOfDoubleDots;\n    this.commands = commands;\n\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new Error('Root segment cannot have matrix parameters');\n    }\n    /** @type {?} */\n\n\n    var cmdWithOutlet = commands.find(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    function (c) {\n      return typeof c === 'object' && c != null && c.outlets;\n    });\n\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new Error('{outlets:{}} has to be the last command');\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Navigation, [{\n    key: \"toRoot\",\n    value: function toRoot() {\n      return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    }\n  }]);\n\n  return Navigation;\n}();\n\nif (false) {\n  /** @type {?} */\n  Navigation.prototype.isAbsolute;\n  /** @type {?} */\n\n  Navigation.prototype.numberOfDoubleDots;\n  /** @type {?} */\n\n  Navigation.prototype.commands;\n}\n/**\n * Transforms commands to a normalized `Navigation`\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction computeNavigation(commands) {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n  /** @type {?} */\n\n\n  var numberOfDoubleDots = 0;\n  /** @type {?} */\n\n  var isAbsolute = false;\n  /** @type {?} */\n\n  var res = commands.reduce(\n  /**\n  * @param {?} res\n  * @param {?} cmd\n  * @param {?} cmdIdx\n  * @return {?}\n  */\n  function (res, cmd, cmdIdx) {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        /** @type {?} */\n        var outlets = {};\n        forEach(cmd.outlets,\n        /**\n        * @param {?} commands\n        * @param {?} name\n        * @return {?}\n        */\n        function (commands, name) {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [].concat(_toConsumableArray(res), [{\n          outlets: outlets\n        }]);\n      }\n\n      if (cmd.segmentPath) {\n        return [].concat(_toConsumableArray(res), [cmd.segmentPath]);\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [].concat(_toConsumableArray(res), [cmd]);\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach(\n      /**\n      * @param {?} urlPart\n      * @param {?} partIndex\n      * @return {?}\n      */\n      function (urlPart, partIndex) {\n        if (partIndex == 0 && urlPart === '.') {// skip './a'\n        } else if (partIndex == 0 && urlPart === '') {\n          //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n      return res;\n    }\n\n    return [].concat(_toConsumableArray(res), [cmd]);\n  }, []);\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nvar Position =\n/**\n * @param {?} segmentGroup\n * @param {?} processChildren\n * @param {?} index\n */\nfunction Position(segmentGroup, processChildren, index) {\n  _classCallCheck(this, Position);\n\n  this.segmentGroup = segmentGroup;\n  this.processChildren = processChildren;\n  this.index = index;\n};\n\nif (false) {\n  /** @type {?} */\n  Position.prototype.segmentGroup;\n  /** @type {?} */\n\n  Position.prototype.processChildren;\n  /** @type {?} */\n\n  Position.prototype.index;\n}\n/**\n * @param {?} nav\n * @param {?} tree\n * @param {?} route\n * @return {?}\n */\n\n\nfunction findStartingPosition(nav, tree, route) {\n  if (nav.isAbsolute) {\n    return new Position(tree.root, true, 0);\n  }\n\n  if (route.snapshot._lastPathIndex === -1) {\n    return new Position(route.snapshot._urlSegment, true, 0);\n  }\n  /** @type {?} */\n\n\n  var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  /** @type {?} */\n\n  var index = route.snapshot._lastPathIndex + modifier;\n  return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n}\n/**\n * @param {?} group\n * @param {?} index\n * @param {?} numberOfDoubleDots\n * @return {?}\n */\n\n\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n  /** @type {?} */\n  var g = group;\n  /** @type {?} */\n\n  var ci = index;\n  /** @type {?} */\n\n  var dd = numberOfDoubleDots;\n\n  while (dd > ci) {\n    dd -= ci;\n    g =\n    /** @type {?} */\n    g.parent;\n\n    if (!g) {\n      throw new Error('Invalid number of \\'../\\'');\n    }\n\n    ci = g.segments.length;\n  }\n\n  return new Position(g, false, ci - dd);\n}\n/**\n * @param {?} command\n * @return {?}\n */\n\n\nfunction getPath(command) {\n  if (typeof command === 'object' && command != null && command.outlets) {\n    return command.outlets[PRIMARY_OUTLET];\n  }\n\n  return \"\".concat(command);\n}\n/**\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction getOutlets(commands) {\n  if (!(typeof commands[0] === 'object')) return _defineProperty({}, PRIMARY_OUTLET, commands);\n  if (commands[0].outlets === undefined) return _defineProperty({}, PRIMARY_OUTLET, commands);\n  return commands[0].outlets;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n  if (!segmentGroup) {\n    segmentGroup = new UrlSegmentGroup([], {});\n  }\n\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n  /** @type {?} */\n\n\n  var m = prefixedWith(segmentGroup, startIndex, commands);\n  /** @type {?} */\n\n  var slicedCommands = commands.slice(m.commandIndex);\n\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    /** @type {?} */\n    var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    /** @type {?} */\n    var outlets = getOutlets(commands);\n    /** @type {?} */\n\n    var children = {};\n    forEach(outlets,\n    /**\n    * @param {?} commands\n    * @param {?} outlet\n    * @return {?}\n    */\n    function (commands, outlet) {\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n    forEach(segmentGroup.children,\n    /**\n    * @param {?} child\n    * @param {?} childOutlet\n    * @return {?}\n    */\n    function (child, childOutlet) {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n  /** @type {?} */\n  var currentCommandIndex = 0;\n  /** @type {?} */\n\n  var currentPathIndex = startIndex;\n  /** @type {?} */\n\n  var noMatch = {\n    match: false,\n    pathIndex: 0,\n    commandIndex: 0\n  };\n\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    /** @type {?} */\n\n    var path = segmentGroup.segments[currentPathIndex];\n    /** @type {?} */\n\n    var curr = getPath(commands[currentCommandIndex]);\n    /** @type {?} */\n\n    var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n\n    currentPathIndex++;\n  }\n\n  return {\n    match: true,\n    pathIndex: currentPathIndex,\n    commandIndex: currentCommandIndex\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} startIndex\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n  /** @type {?} */\n  var paths = segmentGroup.segments.slice(0, startIndex);\n  /** @type {?} */\n\n  var i = 0;\n\n  while (i < commands.length) {\n    if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n      /** @type {?} */\n      var children = createNewSegmentChildren(commands[i].outlets);\n      return new UrlSegmentGroup(paths, children);\n    } // if we start with an object literal, we need to reuse the path part from the segment\n\n\n    if (i === 0 && isMatrixParams(commands[0])) {\n      /** @type {?} */\n      var p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, commands[0]));\n      i++;\n      continue;\n    }\n    /** @type {?} */\n\n\n    var curr = getPath(commands[i]);\n    /** @type {?} */\n\n    var next = i < commands.length - 1 ? commands[i + 1] : null;\n\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n\n  return new UrlSegmentGroup(paths, {});\n}\n/**\n * @param {?} outlets\n * @return {?}\n */\n\n\nfunction createNewSegmentChildren(outlets) {\n  /** @type {?} */\n  var children = {};\n  forEach(outlets,\n  /**\n  * @param {?} commands\n  * @param {?} outlet\n  * @return {?}\n  */\n  function (commands, outlet) {\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n/**\n * @param {?} params\n * @return {?}\n */\n\n\nfunction stringify(params) {\n  /** @type {?} */\n  var res = {};\n  forEach(params,\n  /**\n  * @param {?} v\n  * @param {?} k\n  * @return {?}\n  */\n  function (v, k) {\n    return res[k] = \"\".concat(v);\n  });\n  return res;\n}\n/**\n * @param {?} path\n * @param {?} params\n * @param {?} segment\n * @return {?}\n */\n\n\nfunction compare(path, params, segment) {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar activateRoutes =\n/**\n* @param {?} rootContexts\n* @param {?} routeReuseStrategy\n* @param {?} forwardEvent\n* @return {?}\n*/\nfunction activateRoutes(rootContexts, routeReuseStrategy, forwardEvent) {\n  return map(\n  /**\n  * @param {?} t\n  * @return {?}\n  */\n  function (t) {\n    new ActivateRoutes(routeReuseStrategy,\n    /** @type {?} */\n    t.targetRouterState, t.currentRouterState, forwardEvent).activate(rootContexts);\n    return t;\n  });\n};\n\nvar ActivateRoutes = /*#__PURE__*/function () {\n  /**\n   * @param {?} routeReuseStrategy\n   * @param {?} futureState\n   * @param {?} currState\n   * @param {?} forwardEvent\n   */\n  function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {\n    _classCallCheck(this, ActivateRoutes);\n\n    this.routeReuseStrategy = routeReuseStrategy;\n    this.futureState = futureState;\n    this.currState = currState;\n    this.forwardEvent = forwardEvent;\n  }\n  /**\n   * @param {?} parentContexts\n   * @return {?}\n   */\n\n\n  _createClass(ActivateRoutes, [{\n    key: \"activate\",\n    value: function activate(parentContexts) {\n      /** @type {?} */\n      var futureRoot = this.futureState._root;\n      /** @type {?} */\n\n      var currRoot = this.currState ? this.currState._root : null;\n      this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n      advanceActivatedRoute(this.futureState.root);\n      this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    } // De-activate the child route that are not re-used for the future state\n\n    /**\n     * @private\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateChildRoutes\",\n    value: function deactivateChildRoutes(futureNode, currNode, contexts) {\n      var _this13 = this;\n\n      /** @type {?} */\n      var children = nodeChildrenAsMap(currNode); // Recurse on the routes active in the future state to de-activate deeper children\n\n      futureNode.children.forEach(\n      /**\n      * @param {?} futureChild\n      * @return {?}\n      */\n      function (futureChild) {\n        /** @type {?} */\n        var childOutletName = futureChild.value.outlet;\n\n        _this13.deactivateRoutes(futureChild, children[childOutletName], contexts);\n\n        delete children[childOutletName];\n      }); // De-activate the routes that will not be re-used\n\n      forEach(children,\n      /**\n      * @param {?} v\n      * @param {?} childName\n      * @return {?}\n      */\n      function (v, childName) {\n        _this13.deactivateRouteAndItsChildren(v, contexts);\n      });\n    }\n    /**\n     * @private\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContext\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRoutes\",\n    value: function deactivateRoutes(futureNode, currNode, parentContext) {\n      /** @type {?} */\n      var future = futureNode.value;\n      /** @type {?} */\n\n      var curr = currNode ? currNode.value : null;\n\n      if (future === curr) {\n        // Reusing the node, check to see if the children need to be de-activated\n        if (future.component) {\n          // If we have a normal route, we need to go through an outlet.\n\n          /** @type {?} */\n          var context = parentContext.getContext(future.outlet);\n\n          if (context) {\n            this.deactivateChildRoutes(futureNode, currNode, context.children);\n          }\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.deactivateChildRoutes(futureNode, currNode, parentContext);\n        }\n      } else {\n        if (curr) {\n          // Deactivate the current route which will not be re-used\n          this.deactivateRouteAndItsChildren(currNode, parentContext);\n        }\n      }\n    }\n    /**\n     * @private\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRouteAndItsChildren\",\n    value: function deactivateRouteAndItsChildren(route, parentContexts) {\n      if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n        this.detachAndStoreRouteSubtree(route, parentContexts);\n      } else {\n        this.deactivateRouteAndOutlet(route, parentContexts);\n      }\n    }\n    /**\n     * @private\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"detachAndStoreRouteSubtree\",\n    value: function detachAndStoreRouteSubtree(route, parentContexts) {\n      /** @type {?} */\n      var context = parentContexts.getContext(route.value.outlet);\n\n      if (context && context.outlet) {\n        /** @type {?} */\n        var componentRef = context.outlet.detach();\n        /** @type {?} */\n\n        var contexts = context.children.onOutletDeactivated();\n        this.routeReuseStrategy.store(route.value.snapshot, {\n          componentRef: componentRef,\n          route: route,\n          contexts: contexts\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} route\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivateRouteAndOutlet\",\n    value: function deactivateRouteAndOutlet(route, parentContexts) {\n      var _this14 = this;\n\n      /** @type {?} */\n      var context = parentContexts.getContext(route.value.outlet);\n\n      if (context) {\n        /** @type {?} */\n        var children = nodeChildrenAsMap(route);\n        /** @type {?} */\n\n        var contexts = route.value.component ? context.children : parentContexts;\n        forEach(children,\n        /**\n        * @param {?} v\n        * @param {?} k\n        * @return {?}\n        */\n        function (v, k) {\n          return _this14.deactivateRouteAndItsChildren(v, contexts);\n        });\n\n        if (context.outlet) {\n          // Destroy the component\n          context.outlet.deactivate(); // Destroy the contexts for all the outlets that were in the component\n\n          context.children.onOutletDeactivated();\n        }\n      }\n    }\n    /**\n     * @private\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"activateChildRoutes\",\n    value: function activateChildRoutes(futureNode, currNode, contexts) {\n      var _this15 = this;\n\n      /** @type {?} */\n      var children = nodeChildrenAsMap(currNode);\n      futureNode.children.forEach(\n      /**\n      * @param {?} c\n      * @return {?}\n      */\n      function (c) {\n        _this15.activateRoutes(c, children[c.value.outlet], contexts);\n\n        _this15.forwardEvent(new ActivationEnd(c.value.snapshot));\n      });\n\n      if (futureNode.children.length) {\n        this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n      }\n    }\n    /**\n     * @private\n     * @param {?} futureNode\n     * @param {?} currNode\n     * @param {?} parentContexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"activateRoutes\",\n    value: function activateRoutes(futureNode, currNode, parentContexts) {\n      /** @type {?} */\n      var future = futureNode.value;\n      /** @type {?} */\n\n      var curr = currNode ? currNode.value : null;\n      advanceActivatedRoute(future); // reusing the node\n\n      if (future === curr) {\n        if (future.component) {\n          // If we have a normal route, we need to go through an outlet.\n\n          /** @type {?} */\n          var context = parentContexts.getOrCreateContext(future.outlet);\n          this.activateChildRoutes(futureNode, currNode, context.children);\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.activateChildRoutes(futureNode, currNode, parentContexts);\n        }\n      } else {\n        if (future.component) {\n          // if we have a normal route, we need to place the component into the outlet and recurse.\n\n          /** @type {?} */\n          var _context = parentContexts.getOrCreateContext(future.outlet);\n\n          if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n            /** @type {?} */\n            var stored =\n            /** @type {?} */\n            this.routeReuseStrategy.retrieve(future.snapshot);\n            this.routeReuseStrategy.store(future.snapshot, null);\n\n            _context.children.onOutletReAttached(stored.contexts);\n\n            _context.attachRef = stored.componentRef;\n            _context.route = stored.route.value;\n\n            if (_context.outlet) {\n              // Attach right away when the outlet has already been instantiated\n              // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n              _context.outlet.attach(stored.componentRef, stored.route.value);\n            }\n\n            advanceActivatedRouteNodeAndItsChildren(stored.route);\n          } else {\n            /** @type {?} */\n            var config = parentLoadedConfig(future.snapshot);\n            /** @type {?} */\n\n            var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n            _context.attachRef = null;\n            _context.route = future;\n            _context.resolver = cmpFactoryResolver;\n\n            if (_context.outlet) {\n              // Activate the outlet when it has already been instantiated\n              // Otherwise it will get activated from its `ngOnInit` when instantiated\n              _context.outlet.activateWith(future, cmpFactoryResolver);\n            }\n\n            this.activateChildRoutes(futureNode, null, _context.children);\n          }\n        } else {\n          // if we have a componentless route, we recurse but keep the same outlet map.\n          this.activateChildRoutes(futureNode, null, parentContexts);\n        }\n      }\n    }\n  }]);\n\n  return ActivateRoutes;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ActivateRoutes.prototype.routeReuseStrategy;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ActivateRoutes.prototype.futureState;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ActivateRoutes.prototype.currState;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ActivateRoutes.prototype.forwardEvent;\n}\n/**\n * @param {?} node\n * @return {?}\n */\n\n\nfunction advanceActivatedRouteNodeAndItsChildren(node) {\n  advanceActivatedRoute(node.value);\n  node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n/**\n * @param {?} snapshot\n * @return {?}\n */\n\n\nfunction parentLoadedConfig(snapshot) {\n  for (var s = snapshot.parent; s; s = s.parent) {\n    /** @type {?} */\n    var route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n    if (route && route.component) return null;\n  }\n\n  return null;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n * @template T\n * @param {?} v\n * @return {?}\n */\n\n\nfunction isFunction(v) {\n  return typeof v === 'function';\n}\n/**\n * @param {?} v\n * @return {?}\n */\n\n\nfunction isBoolean(v) {\n  return typeof v === 'boolean';\n}\n/**\n * @param {?} v\n * @return {?}\n */\n\n\nfunction isUrlTree(v) {\n  return v instanceof UrlTree;\n}\n/**\n * @param {?} guard\n * @return {?}\n */\n\n\nfunction isCanLoad(guard) {\n  return guard && isFunction(guard.canLoad);\n}\n/**\n * @param {?} guard\n * @return {?}\n */\n\n\nfunction isCanActivate(guard) {\n  return guard && isFunction(guard.canActivate);\n}\n/**\n * @param {?} guard\n * @return {?}\n */\n\n\nfunction isCanActivateChild(guard) {\n  return guard && isFunction(guard.canActivateChild);\n}\n/**\n * @template T\n * @param {?} guard\n * @return {?}\n */\n\n\nfunction isCanDeactivate(guard) {\n  return guard && isFunction(guard.canDeactivate);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar NoMatch =\n/**\n * @param {?=} segmentGroup\n */\nfunction NoMatch(segmentGroup) {\n  _classCallCheck(this, NoMatch);\n\n  this.segmentGroup = segmentGroup || null;\n};\n\nif (false) {\n  /** @type {?} */\n  NoMatch.prototype.segmentGroup;\n}\n\nvar AbsoluteRedirect =\n/**\n * @param {?} urlTree\n */\nfunction AbsoluteRedirect(urlTree) {\n  _classCallCheck(this, AbsoluteRedirect);\n\n  this.urlTree = urlTree;\n};\n\nif (false) {\n  /** @type {?} */\n  AbsoluteRedirect.prototype.urlTree;\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction noMatch(segmentGroup) {\n  return new Observable(\n  /**\n  * @param {?} obs\n  * @return {?}\n  */\n  function (obs) {\n    return obs.error(new NoMatch(segmentGroup));\n  });\n}\n/**\n * @param {?} newTree\n * @return {?}\n */\n\n\nfunction absoluteRedirect(newTree) {\n  return new Observable(\n  /**\n  * @param {?} obs\n  * @return {?}\n  */\n  function (obs) {\n    return obs.error(new AbsoluteRedirect(newTree));\n  });\n}\n/**\n * @param {?} redirectTo\n * @return {?}\n */\n\n\nfunction namedOutletsRedirect(redirectTo) {\n  return new Observable(\n  /**\n  * @param {?} obs\n  * @return {?}\n  */\n  function (obs) {\n    return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: '\".concat(redirectTo, \"'\")));\n  });\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction canLoadFails(route) {\n  return new Observable(\n  /**\n  * @param {?} obs\n  * @return {?}\n  */\n  function (obs) {\n    return obs.error(navigationCancelingError(\"Cannot load children because the guard of the route \\\"path: '\".concat(route.path, \"'\\\" returned false\")));\n  });\n}\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n * @param {?} moduleInjector\n * @param {?} configLoader\n * @param {?} urlSerializer\n * @param {?} urlTree\n * @param {?} config\n * @return {?}\n */\n\n\nfunction applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n  return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\n}\n\nvar ApplyRedirects = /*#__PURE__*/function () {\n  /**\n   * @param {?} moduleInjector\n   * @param {?} configLoader\n   * @param {?} urlSerializer\n   * @param {?} urlTree\n   * @param {?} config\n   */\n  function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\n    _classCallCheck(this, ApplyRedirects);\n\n    this.configLoader = configLoader;\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n    this.config = config;\n    this.allowRedirects = true;\n    this.ngModule = moduleInjector.get(NgModuleRef);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ApplyRedirects, [{\n    key: \"apply\",\n    value: function apply() {\n      var _this16 = this;\n\n      /** @type {?} */\n      var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n      /** @type {?} */\n\n      var urlTrees$ = expanded$.pipe(map(\n      /**\n      * @param {?} rootSegmentGroup\n      * @return {?}\n      */\n      function (rootSegmentGroup) {\n        return _this16.createUrlTree(rootSegmentGroup, _this16.urlTree.queryParams,\n        /** @type {?} */\n        _this16.urlTree.fragment);\n      }));\n      return urlTrees$.pipe(catchError(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      function (e) {\n        if (e instanceof AbsoluteRedirect) {\n          // after an absolute redirect we do not apply any more redirects!\n          _this16.allowRedirects = false; // we need to run matching, so we can fetch all lazy-loaded modules\n\n          return _this16.match(e.urlTree);\n        }\n\n        if (e instanceof NoMatch) {\n          throw _this16.noMatchError(e);\n        }\n\n        throw e;\n      }));\n    }\n    /**\n     * @private\n     * @param {?} tree\n     * @return {?}\n     */\n\n  }, {\n    key: \"match\",\n    value: function match(tree) {\n      var _this17 = this;\n\n      /** @type {?} */\n      var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n      /** @type {?} */\n\n      var mapped$ = expanded$.pipe(map(\n      /**\n      * @param {?} rootSegmentGroup\n      * @return {?}\n      */\n      function (rootSegmentGroup) {\n        return _this17.createUrlTree(rootSegmentGroup, tree.queryParams,\n        /** @type {?} */\n        tree.fragment);\n      }));\n      return mapped$.pipe(catchError(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      function (e) {\n        if (e instanceof NoMatch) {\n          throw _this17.noMatchError(e);\n        }\n\n        throw e;\n      }));\n    }\n    /**\n     * @private\n     * @param {?} e\n     * @return {?}\n     */\n\n  }, {\n    key: \"noMatchError\",\n    value: function noMatchError(e) {\n      return new Error(\"Cannot match any routes. URL Segment: '\".concat(e.segmentGroup, \"'\"));\n    }\n    /**\n     * @private\n     * @param {?} rootCandidate\n     * @param {?} queryParams\n     * @param {?} fragment\n     * @return {?}\n     */\n\n  }, {\n    key: \"createUrlTree\",\n    value: function createUrlTree(rootCandidate, queryParams, fragment) {\n      /** @type {?} */\n      var root = rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], _defineProperty({}, PRIMARY_OUTLET, rootCandidate)) : rootCandidate;\n      return new UrlTree(root, queryParams, fragment);\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentGroup\",\n    value: function expandSegmentGroup(ngModule, routes, segmentGroup, outlet) {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return this.expandChildren(ngModule, routes, segmentGroup).pipe(map(\n        /**\n        * @param {?} children\n        * @return {?}\n        */\n        function (children) {\n          return new UrlSegmentGroup([], children);\n        }));\n      }\n\n      return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\n    } // Recursively expand segment groups for all the child outlets\n\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandChildren\",\n    value: function expandChildren(ngModule, routes, segmentGroup) {\n      var _this18 = this;\n\n      return waitForMap(segmentGroup.children,\n      /**\n      * @param {?} childOutlet\n      * @param {?} child\n      * @return {?}\n      */\n      function (childOutlet, child) {\n        return _this18.expandSegmentGroup(ngModule, routes, child, childOutlet);\n      });\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} segments\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegment\",\n    value: function expandSegment(ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {\n      var _this19 = this;\n\n      return of.apply(void 0, _toConsumableArray(routes)).pipe(map(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      function (r) {\n        /** @type {?} */\n        var expanded$ = _this19.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n\n        return expanded$.pipe(catchError(\n        /**\n        * @param {?} e\n        * @return {?}\n        */\n        function (e) {\n          if (e instanceof NoMatch) {\n            // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -\n            // talk to Jason\n            return (\n              /** @type {?} */\n              of(null)\n            );\n          }\n\n          throw e;\n        }));\n      }), concatAll(), first(\n      /**\n      * @param {?} s\n      * @return {?}\n      */\n      function (s) {\n        return !!s;\n      }), catchError(\n      /**\n      * @param {?} e\n      * @param {?} _\n      * @return {?}\n      */\n      function (e, _) {\n        if (e instanceof EmptyError || e.name === 'EmptyError') {\n          if (_this19.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n            return of(new UrlSegmentGroup([], {}));\n          }\n\n          throw new NoMatch(segmentGroup);\n        }\n\n        throw e;\n      }));\n    }\n    /**\n     * @private\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"noLeftoversInUrl\",\n    value: function noLeftoversInUrl(segmentGroup, segments, outlet) {\n      return segments.length === 0 && !segmentGroup.children[outlet];\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} paths\n     * @param {?} outlet\n     * @param {?} allowRedirects\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentAgainstRoute\",\n    value: function expandSegmentAgainstRoute(ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {\n      if (getOutlet(route) !== outlet) {\n        return noMatch(segmentGroup);\n      }\n\n      if (route.redirectTo === undefined) {\n        return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n      }\n\n      if (allowRedirects && this.allowRedirects) {\n        return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);\n      }\n\n      return noMatch(segmentGroup);\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandSegmentAgainstRouteUsingRedirect\",\n    value: function expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {\n      if (route.path === '**') {\n        return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);\n      }\n\n      return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandWildCardWithParamsAgainstRouteUsingRedirect\",\n    value: function expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet) {\n      var _this20 = this;\n\n      /** @type {?} */\n      var newTree = this.applyRedirectCommands([],\n      /** @type {?} */\n      route.redirectTo, {});\n\n      if (\n      /** @type {?} */\n      route.redirectTo.startsWith('/')) {\n        return absoluteRedirect(newTree);\n      }\n\n      return this.lineralizeSegments(route, newTree).pipe(mergeMap(\n      /**\n      * @param {?} newSegments\n      * @return {?}\n      */\n      function (newSegments) {\n        /** @type {?} */\n        var group = new UrlSegmentGroup(newSegments, {});\n        return _this20.expandSegment(ngModule, group, routes, newSegments, outlet, false);\n      }));\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} segmentGroup\n     * @param {?} routes\n     * @param {?} route\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandRegularSegmentAgainstRouteUsingRedirect\",\n    value: function expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {\n      var _this21 = this;\n\n      var _match = match(segmentGroup, route, segments),\n          matched = _match.matched,\n          consumedSegments = _match.consumedSegments,\n          lastChild = _match.lastChild,\n          positionalParamSegments = _match.positionalParamSegments;\n\n      if (!matched) return noMatch(segmentGroup);\n      /** @type {?} */\n\n      var newTree = this.applyRedirectCommands(consumedSegments,\n      /** @type {?} */\n      route.redirectTo,\n      /** @type {?} */\n      positionalParamSegments);\n\n      if (\n      /** @type {?} */\n      route.redirectTo.startsWith('/')) {\n        return absoluteRedirect(newTree);\n      }\n\n      return this.lineralizeSegments(route, newTree).pipe(mergeMap(\n      /**\n      * @param {?} newSegments\n      * @return {?}\n      */\n      function (newSegments) {\n        return _this21.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\n      }));\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} rawSegmentGroup\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n\n  }, {\n    key: \"matchSegmentAgainstRoute\",\n    value: function matchSegmentAgainstRoute(ngModule, rawSegmentGroup, route, segments) {\n      var _this22 = this;\n\n      if (route.path === '**') {\n        if (route.loadChildren) {\n          return this.configLoader.load(ngModule.injector, route).pipe(map(\n          /**\n          * @param {?} cfg\n          * @return {?}\n          */\n          function (cfg) {\n            route._loadedConfig = cfg;\n            return new UrlSegmentGroup(segments, {});\n          }));\n        }\n\n        return of(new UrlSegmentGroup(segments, {}));\n      }\n\n      var _match2 = match(rawSegmentGroup, route, segments),\n          matched = _match2.matched,\n          consumedSegments = _match2.consumedSegments,\n          lastChild = _match2.lastChild;\n\n      if (!matched) return noMatch(rawSegmentGroup);\n      /** @type {?} */\n\n      var rawSlicedSegments = segments.slice(lastChild);\n      /** @type {?} */\n\n      var childConfig$ = this.getChildConfig(ngModule, route, segments);\n      return childConfig$.pipe(mergeMap(\n      /**\n      * @param {?} routerConfig\n      * @return {?}\n      */\n      function (routerConfig) {\n        /** @type {?} */\n        var childModule = routerConfig.module;\n        /** @type {?} */\n\n        var childConfig = routerConfig.routes;\n\n        var _split = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig),\n            segmentGroup = _split.segmentGroup,\n            slicedSegments = _split.slicedSegments;\n\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n          /** @type {?} */\n          var _expanded$ = _this22.expandChildren(childModule, childConfig, segmentGroup);\n\n          return _expanded$.pipe(map(\n          /**\n          * @param {?} children\n          * @return {?}\n          */\n          function (children) {\n            return new UrlSegmentGroup(consumedSegments, children);\n          }));\n        }\n\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n          return of(new UrlSegmentGroup(consumedSegments, {}));\n        }\n        /** @type {?} */\n\n\n        var expanded$ = _this22.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n\n        return expanded$.pipe(map(\n        /**\n        * @param {?} cs\n        * @return {?}\n        */\n        function (cs) {\n          return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);\n        }));\n      }));\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} route\n     * @param {?} segments\n     * @return {?}\n     */\n\n  }, {\n    key: \"getChildConfig\",\n    value: function getChildConfig(ngModule, route, segments) {\n      var _this23 = this;\n\n      if (route.children) {\n        // The children belong to the same module\n        return of(new LoadedRouterConfig(route.children, ngModule));\n      }\n\n      if (route.loadChildren) {\n        // lazy children belong to the loaded module\n        if (route._loadedConfig !== undefined) {\n          return of(route._loadedConfig);\n        }\n\n        return runCanLoadGuard(ngModule.injector, route, segments).pipe(mergeMap(\n        /**\n        * @param {?} shouldLoad\n        * @return {?}\n        */\n        function (shouldLoad) {\n          if (shouldLoad) {\n            return _this23.configLoader.load(ngModule.injector, route).pipe(map(\n            /**\n            * @param {?} cfg\n            * @return {?}\n            */\n            function (cfg) {\n              route._loadedConfig = cfg;\n              return cfg;\n            }));\n          }\n\n          return canLoadFails(route);\n        }));\n      }\n\n      return of(new LoadedRouterConfig([], ngModule));\n    }\n    /**\n     * @private\n     * @param {?} route\n     * @param {?} urlTree\n     * @return {?}\n     */\n\n  }, {\n    key: \"lineralizeSegments\",\n    value: function lineralizeSegments(route, urlTree) {\n      /** @type {?} */\n      var res = [];\n      /** @type {?} */\n\n      var c = urlTree.root;\n\n      while (true) {\n        res = res.concat(c.segments);\n\n        if (c.numberOfChildren === 0) {\n          return of(res);\n        }\n\n        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n          return namedOutletsRedirect(\n          /** @type {?} */\n          route.redirectTo);\n        }\n\n        c = c.children[PRIMARY_OUTLET];\n      }\n    }\n    /**\n     * @private\n     * @param {?} segments\n     * @param {?} redirectTo\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyRedirectCommands\",\n    value: function applyRedirectCommands(segments, redirectTo, posParams) {\n      return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    }\n    /**\n     * @private\n     * @param {?} redirectTo\n     * @param {?} urlTree\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"applyRedirectCreatreUrlTree\",\n    value: function applyRedirectCreatreUrlTree(redirectTo, urlTree, segments, posParams) {\n      /** @type {?} */\n      var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n      return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    }\n    /**\n     * @private\n     * @param {?} redirectToParams\n     * @param {?} actualParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createQueryParams\",\n    value: function createQueryParams(redirectToParams, actualParams) {\n      /** @type {?} */\n      var res = {};\n      forEach(redirectToParams,\n      /**\n      * @param {?} v\n      * @param {?} k\n      * @return {?}\n      */\n      function (v, k) {\n        /** @type {?} */\n        var copySourceValue = typeof v === 'string' && v.startsWith(':');\n\n        if (copySourceValue) {\n          /** @type {?} */\n          var sourceName = v.substring(1);\n          res[k] = actualParams[sourceName];\n        } else {\n          res[k] = v;\n        }\n      });\n      return res;\n    }\n    /**\n     * @private\n     * @param {?} redirectTo\n     * @param {?} group\n     * @param {?} segments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createSegmentGroup\",\n    value: function createSegmentGroup(redirectTo, group, segments, posParams) {\n      var _this24 = this;\n\n      /** @type {?} */\n      var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n      /** @type {?} */\n\n      var children = {};\n      forEach(group.children,\n      /**\n      * @param {?} child\n      * @param {?} name\n      * @return {?}\n      */\n      function (child, name) {\n        children[name] = _this24.createSegmentGroup(redirectTo, child, segments, posParams);\n      });\n      return new UrlSegmentGroup(updatedSegments, children);\n    }\n    /**\n     * @private\n     * @param {?} redirectTo\n     * @param {?} redirectToSegments\n     * @param {?} actualSegments\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"createSegments\",\n    value: function createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n      var _this25 = this;\n\n      return redirectToSegments.map(\n      /**\n      * @param {?} s\n      * @return {?}\n      */\n      function (s) {\n        return s.path.startsWith(':') ? _this25.findPosParam(redirectTo, s, posParams) : _this25.findOrReturn(s, actualSegments);\n      });\n    }\n    /**\n     * @private\n     * @param {?} redirectTo\n     * @param {?} redirectToUrlSegment\n     * @param {?} posParams\n     * @return {?}\n     */\n\n  }, {\n    key: \"findPosParam\",\n    value: function findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n      /** @type {?} */\n      var pos = posParams[redirectToUrlSegment.path.substring(1)];\n      if (!pos) throw new Error(\"Cannot redirect to '\".concat(redirectTo, \"'. Cannot find '\").concat(redirectToUrlSegment.path, \"'.\"));\n      return pos;\n    }\n    /**\n     * @private\n     * @param {?} redirectToUrlSegment\n     * @param {?} actualSegments\n     * @return {?}\n     */\n\n  }, {\n    key: \"findOrReturn\",\n    value: function findOrReturn(redirectToUrlSegment, actualSegments) {\n      /** @type {?} */\n      var idx = 0;\n\n      var _iterator4 = _createForOfIteratorHelper(actualSegments),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var s = _step4.value;\n\n          if (s.path === redirectToUrlSegment.path) {\n            actualSegments.splice(idx);\n            return s;\n          }\n\n          idx++;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return redirectToUrlSegment;\n    }\n  }]);\n\n  return ApplyRedirects;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ApplyRedirects.prototype.allowRedirects;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ApplyRedirects.prototype.ngModule;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ApplyRedirects.prototype.configLoader;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ApplyRedirects.prototype.urlSerializer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ApplyRedirects.prototype.urlTree;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ApplyRedirects.prototype.config;\n}\n/**\n * @param {?} moduleInjector\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\n\n\nfunction runCanLoadGuard(moduleInjector, route, segments) {\n  /** @type {?} */\n  var canLoad = route.canLoad;\n  if (!canLoad || canLoad.length === 0) return of(true);\n  /** @type {?} */\n\n  var obs = from(canLoad).pipe(map(\n  /**\n  * @param {?} injectionToken\n  * @return {?}\n  */\n  function (injectionToken) {\n    /** @type {?} */\n    var guard = moduleInjector.get(injectionToken);\n    /** @type {?} */\n\n    var guardVal;\n\n    if (isCanLoad(guard)) {\n      guardVal = guard.canLoad(route, segments);\n    } else if (isFunction(guard)) {\n      guardVal = guard(route, segments);\n    } else {\n      throw new Error('Invalid CanLoad guard');\n    }\n\n    return wrapIntoObservable(guardVal);\n  }));\n  return obs.pipe(concatAll(), every(\n  /**\n  * @param {?} result\n  * @return {?}\n  */\n  function (result) {\n    return result === true;\n  }));\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\n\n\nfunction match(segmentGroup, route, segments) {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {\n        matched: false,\n        consumedSegments: [],\n        lastChild: 0,\n        positionalParamSegments: {}\n      };\n    }\n\n    return {\n      matched: true,\n      consumedSegments: [],\n      lastChild: 0,\n      positionalParamSegments: {}\n    };\n  }\n  /** @type {?} */\n\n\n  var matcher = route.matcher || defaultUrlMatcher;\n  /** @type {?} */\n\n  var res = matcher(segments, segmentGroup, route);\n\n  if (!res) {\n    return {\n      matched: false,\n      consumedSegments:\n      /** @type {?} */\n      [],\n      lastChild: 0,\n      positionalParamSegments: {}\n    };\n  }\n\n  return {\n    matched: true,\n    consumedSegments:\n    /** @type {?} */\n    res.consumed,\n    lastChild:\n    /** @type {?} */\n    res.consumed.length,\n    positionalParamSegments:\n    /** @type {?} */\n    res.posParams\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @return {?}\n */\n\n\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n  if (slicedSegments.length > 0 && containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    /** @type {?} */\n    var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {\n      segmentGroup: mergeTrivialChildren(s),\n      slicedSegments: []\n    };\n  }\n\n  if (slicedSegments.length === 0 && containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n    /** @type {?} */\n    var _s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n\n    return {\n      segmentGroup: mergeTrivialChildren(_s),\n      slicedSegments: slicedSegments\n    };\n  }\n\n  return {\n    segmentGroup: segmentGroup,\n    slicedSegments: slicedSegments\n  };\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction mergeTrivialChildren(s) {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    /** @type {?} */\n    var c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @return {?}\n */\n\n\nfunction addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n  /** @type {?} */\n  var res = {};\n\n  var _iterator5 = _createForOfIteratorHelper(routes),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var r = _step5.value;\n\n      if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n        res[getOutlet(r)] = new UrlSegmentGroup([], {});\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return Object.assign({}, children, res);\n}\n/**\n * @param {?} routes\n * @param {?} primarySegmentGroup\n * @return {?}\n */\n\n\nfunction createChildrenForEmptySegments(routes, primarySegmentGroup) {\n  /** @type {?} */\n  var res = {};\n  res[PRIMARY_OUTLET] = primarySegmentGroup;\n\n  var _iterator6 = _createForOfIteratorHelper(routes),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var r = _step6.value;\n\n      if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n        res[getOutlet(r)] = new UrlSegmentGroup([], {});\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {\n  return routes.some(\n  /**\n  * @param {?} r\n  * @return {?}\n  */\n  function (r) {\n    return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathRedirects(segmentGroup, segments, routes) {\n  return routes.some(\n  /**\n  * @param {?} r\n  * @return {?}\n  */\n  function (r) {\n    return isEmptyPathRedirect(segmentGroup, segments, r);\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} segments\n * @param {?} r\n * @return {?}\n */\n\n\nfunction isEmptyPathRedirect(segmentGroup, segments, r) {\n  if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo !== undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getOutlet(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} moduleInjector\n * @param {?} configLoader\n * @param {?} urlSerializer\n * @param {?} config\n * @return {?}\n */\n\n\nfunction applyRedirects$1(moduleInjector, configLoader, urlSerializer, config) {\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    function (source) {\n      return source.pipe(switchMap(\n      /**\n      * @param {?} t\n      * @return {?}\n      */\n      function (t) {\n        return applyRedirects(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config).pipe(map(\n        /**\n        * @param {?} urlAfterRedirects\n        * @return {?}\n        */\n        function (urlAfterRedirects) {\n          return Object.assign({}, t, {\n            urlAfterRedirects: urlAfterRedirects\n          });\n        }));\n      }));\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar CanActivate =\n/**\n * @param {?} path\n */\nfunction CanActivate(path) {\n  _classCallCheck(this, CanActivate);\n\n  this.path = path;\n  this.route = this.path[this.path.length - 1];\n};\n\nif (false) {\n  /** @type {?} */\n  CanActivate.prototype.route;\n  /** @type {?} */\n\n  CanActivate.prototype.path;\n}\n\nvar CanDeactivate =\n/**\n * @param {?} component\n * @param {?} route\n */\nfunction CanDeactivate(component, route) {\n  _classCallCheck(this, CanDeactivate);\n\n  this.component = component;\n  this.route = route;\n};\n\nif (false) {\n  /** @type {?} */\n  CanDeactivate.prototype.component;\n  /** @type {?} */\n\n  CanDeactivate.prototype.route;\n}\n/**\n * @param {?} future\n * @param {?} curr\n * @param {?} parentContexts\n * @return {?}\n */\n\n\nfunction getAllRouteGuards(future, curr, parentContexts) {\n  /** @type {?} */\n  var futureRoot = future._root;\n  /** @type {?} */\n\n  var currRoot = curr ? curr._root : null;\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n/**\n * @param {?} p\n * @return {?}\n */\n\n\nfunction getCanActivateChild(p) {\n  /** @type {?} */\n  var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {\n    node: p,\n    guards: canActivateChild\n  };\n}\n/**\n * @param {?} token\n * @param {?} snapshot\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction getToken(token, snapshot, moduleInjector) {\n  /** @type {?} */\n  var config = getClosestLoadedConfig(snapshot);\n  /** @type {?} */\n\n  var injector = config ? config.module.injector : moduleInjector;\n  return injector.get(token);\n}\n/**\n * @param {?} snapshot\n * @return {?}\n */\n\n\nfunction getClosestLoadedConfig(snapshot) {\n  if (!snapshot) return null;\n\n  for (var s = snapshot.parent; s; s = s.parent) {\n    /** @type {?} */\n    var route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n  }\n\n  return null;\n}\n/**\n * @param {?} futureNode\n * @param {?} currNode\n * @param {?} contexts\n * @param {?} futurePath\n * @param {?=} checks\n * @return {?}\n */\n\n\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath) {\n  var checks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    canDeactivateChecks: [],\n    canActivateChecks: []\n  };\n\n  /** @type {?} */\n  var prevChildren = nodeChildrenAsMap(currNode); // Process the children of the future route\n\n  futureNode.children.forEach(\n  /**\n  * @param {?} c\n  * @return {?}\n  */\n  function (c) {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  }); // Process any children left from the current route (not active for the future route)\n\n  forEach(prevChildren,\n  /**\n  * @param {?} v\n  * @param {?} k\n  * @return {?}\n  */\n  function (v, k) {\n    return deactivateRouteAndItsChildren(v,\n    /** @type {?} */\n    contexts.getContext(k), checks);\n  });\n  return checks;\n}\n/**\n * @param {?} futureNode\n * @param {?} currNode\n * @param {?} parentContexts\n * @param {?} futurePath\n * @param {?=} checks\n * @return {?}\n */\n\n\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath) {\n  var checks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    canDeactivateChecks: [],\n    canActivateChecks: []\n  };\n\n  /** @type {?} */\n  var future = futureNode.value;\n  /** @type {?} */\n\n  var curr = currNode ? currNode.value : null;\n  /** @type {?} */\n\n  var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null; // reusing the node\n\n  if (curr && future.routeConfig === curr.routeConfig) {\n    /** @type {?} */\n    var shouldRun = shouldRunGuardsAndResolvers(curr, future,\n    /** @type {?} */\n    future.routeConfig.runGuardsAndResolvers);\n\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    } // If we have a component, we need to go through an outlet.\n\n\n    if (future.component) {\n      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks); // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun) {\n      /** @type {?} */\n      var component = context && context.outlet && context.outlet.component || null;\n      checks.canDeactivateChecks.push(new CanDeactivate(component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath)); // If we have a component, we need to go through an outlet.\n\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks); // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n/**\n * @param {?} curr\n * @param {?} future\n * @param {?} mode\n * @return {?}\n */\n\n\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n\n    case 'pathParamsOrQueryParamsChange':\n      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n/**\n * @param {?} route\n * @param {?} context\n * @param {?} checks\n * @return {?}\n */\n\n\nfunction deactivateRouteAndItsChildren(route, context, checks) {\n  /** @type {?} */\n  var children = nodeChildrenAsMap(route);\n  /** @type {?} */\n\n  var r = route.value;\n  forEach(children,\n  /**\n  * @param {?} node\n  * @param {?} childName\n  * @return {?}\n  */\n  function (node, childName) {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar INITIAL_VALUE = Symbol('INITIAL_VALUE');\n/**\n * @return {?}\n */\n\nfunction prioritizedGuardValue() {\n  return switchMap(\n  /**\n  * @param {?} obs\n  * @return {?}\n  */\n  function (obs) {\n    return (\n      /** @type {?} */\n      combineLatest.apply(void 0, _toConsumableArray(obs.map(\n      /**\n      * @param {?} o\n      * @return {?}\n      */\n      function (o) {\n        return o.pipe(take(1), startWith(\n        /** @type {?} */\n        INITIAL_VALUE));\n      }))).pipe(scan(\n      /**\n      * @param {?} acc\n      * @param {?} list\n      * @return {?}\n      */\n      function (acc, list) {\n        /** @type {?} */\n        var isPending = false;\n        return list.reduce(\n        /**\n        * @param {?} innerAcc\n        * @param {?} val\n        * @param {?} i\n        * @return {?}\n        */\n        function (innerAcc, val, i) {\n          if (innerAcc !== INITIAL_VALUE) return innerAcc; // Toggle pending flag if any values haven't been set yet\n\n          if (val === INITIAL_VALUE) isPending = true; // Any other return values are only valid if we haven't yet hit a pending call.\n          // This guarantees that in the case of a guard at the bottom of the tree that\n          // returns a redirect, we will wait for the higher priority guard at the top to\n          // finish before performing the redirect.\n\n          if (!isPending) {\n            // Early return when we hit a `false` value as that should always cancel\n            // navigation\n            if (val === false) return val;\n\n            if (i === list.length - 1 || isUrlTree(val)) {\n              return val;\n            }\n          }\n\n          return innerAcc;\n        }, acc);\n      }, INITIAL_VALUE), filter(\n      /**\n      * @param {?} item\n      * @return {?}\n      */\n      function (item) {\n        return item !== INITIAL_VALUE;\n      }), map(\n      /**\n      * @param {?} item\n      * @return {?}\n      */\n      function (item) {\n        return isUrlTree(item) ? item : item === true;\n      }), //\n      take(1))\n    );\n  });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} moduleInjector\n * @param {?=} forwardEvent\n * @return {?}\n */\n\n\nfunction checkGuards(moduleInjector, forwardEvent) {\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    function (source) {\n      return source.pipe(mergeMap(\n      /**\n      * @param {?} t\n      * @return {?}\n      */\n      function (t) {\n        var targetSnapshot = t.targetSnapshot,\n            currentSnapshot = t.currentSnapshot,\n            _t$guards = t.guards,\n            canActivateChecks = _t$guards.canActivateChecks,\n            canDeactivateChecks = _t$guards.canDeactivateChecks;\n\n        if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n          return of(Object.assign({}, t, {\n            guardsResult: true\n          }));\n        }\n\n        return runCanDeactivateChecks(canDeactivateChecks,\n        /** @type {?} */\n        targetSnapshot, currentSnapshot, moduleInjector).pipe(mergeMap(\n        /**\n        * @param {?} canDeactivate\n        * @return {?}\n        */\n        function (canDeactivate) {\n          return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(\n          /** @type {?} */\n          targetSnapshot, canActivateChecks, moduleInjector, forwardEvent) : of(canDeactivate);\n        }), map(\n        /**\n        * @param {?} guardsResult\n        * @return {?}\n        */\n        function (guardsResult) {\n          return Object.assign({}, t, {\n            guardsResult: guardsResult\n          });\n        }));\n      }));\n    }\n  );\n}\n/**\n * @param {?} checks\n * @param {?} futureRSS\n * @param {?} currRSS\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, moduleInjector) {\n  return from(checks).pipe(mergeMap(\n  /**\n  * @param {?} check\n  * @return {?}\n  */\n  function (check) {\n    return runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector);\n  }), first(\n  /**\n  * @param {?} result\n  * @return {?}\n  */\n  function (result) {\n    return result !== true;\n  },\n  /** @type {?} */\n  true));\n}\n/**\n * @param {?} futureSnapshot\n * @param {?} checks\n * @param {?} moduleInjector\n * @param {?=} forwardEvent\n * @return {?}\n */\n\n\nfunction runCanActivateChecks(futureSnapshot, checks, moduleInjector, forwardEvent) {\n  return from(checks).pipe(concatMap(\n  /**\n  * @param {?} check\n  * @return {?}\n  */\n  function (check) {\n    return from([fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, moduleInjector), runCanActivate(futureSnapshot, check.route, moduleInjector)]).pipe(concatAll(), first(\n    /**\n    * @param {?} result\n    * @return {?}\n    */\n    function (result) {\n      return result !== true;\n    },\n    /** @type {?} */\n    true));\n  }), first(\n  /**\n  * @param {?} result\n  * @return {?}\n  */\n  function (result) {\n    return result !== true;\n  },\n  /** @type {?} */\n  true));\n}\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n * @param {?} snapshot\n * @param {?=} forwardEvent\n * @return {?}\n */\n\n\nfunction fireActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n\n  return of(true);\n}\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n * @param {?} snapshot\n * @param {?=} forwardEvent\n * @return {?}\n */\n\n\nfunction fireChildActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n\n  return of(true);\n}\n/**\n * @param {?} futureRSS\n * @param {?} futureARS\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction runCanActivate(futureRSS, futureARS, moduleInjector) {\n  /** @type {?} */\n  var canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n  /** @type {?} */\n\n  var canActivateObservables = canActivate.map(\n  /**\n  * @param {?} c\n  * @return {?}\n  */\n  function (c) {\n    return defer(\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var guard = getToken(c, futureARS, moduleInjector);\n      /** @type {?} */\n\n      var observable;\n\n      if (isCanActivate(guard)) {\n        observable = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));\n      } else if (isFunction(guard)) {\n        observable = wrapIntoObservable(guard(futureARS, futureRSS));\n      } else {\n        throw new Error('Invalid CanActivate guard');\n      }\n\n      return observable.pipe(first());\n    });\n  });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\n/**\n * @param {?} futureRSS\n * @param {?} path\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction runCanActivateChild(futureRSS, path, moduleInjector) {\n  /** @type {?} */\n  var futureARS = path[path.length - 1];\n  /** @type {?} */\n\n  var canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(\n  /**\n  * @param {?} p\n  * @return {?}\n  */\n  function (p) {\n    return getCanActivateChild(p);\n  }).filter(\n  /**\n  * @param {?} _\n  * @return {?}\n  */\n  function (_) {\n    return _ !== null;\n  });\n  /** @type {?} */\n\n  var canActivateChildGuardsMapped = canActivateChildGuards.map(\n  /**\n  * @param {?} d\n  * @return {?}\n  */\n  function (d) {\n    return defer(\n    /**\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var guardsMapped = d.guards.map(\n      /**\n      * @param {?} c\n      * @return {?}\n      */\n      function (c) {\n        /** @type {?} */\n        var guard = getToken(c, d.node, moduleInjector);\n        /** @type {?} */\n\n        var observable;\n\n        if (isCanActivateChild(guard)) {\n          observable = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));\n        } else if (isFunction(guard)) {\n          observable = wrapIntoObservable(guard(futureARS, futureRSS));\n        } else {\n          throw new Error('Invalid CanActivateChild guard');\n        }\n\n        return observable.pipe(first());\n      });\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\n/**\n * @param {?} component\n * @param {?} currARS\n * @param {?} currRSS\n * @param {?} futureRSS\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, moduleInjector) {\n  /** @type {?} */\n  var canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  /** @type {?} */\n\n  var canDeactivateObservables = canDeactivate.map(\n  /**\n  * @param {?} c\n  * @return {?}\n  */\n  function (c) {\n    /** @type {?} */\n    var guard = getToken(c, currARS, moduleInjector);\n    /** @type {?} */\n\n    var observable;\n\n    if (isCanDeactivate(guard)) {\n      observable = wrapIntoObservable(guard.canDeactivate(\n      /** @type {?} */\n      component, currARS, currRSS, futureRSS));\n    } else if (isFunction(guard)) {\n      observable = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));\n    } else {\n      throw new Error('Invalid CanDeactivate guard');\n    }\n\n    return observable.pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar NoMatch$1 = function NoMatch$1() {\n  _classCallCheck(this, NoMatch$1);\n};\n/**\n * @param {?} rootComponentType\n * @param {?} config\n * @param {?} urlTree\n * @param {?} url\n * @param {?=} paramsInheritanceStrategy\n * @param {?=} relativeLinkResolution\n * @return {?}\n */\n\n\nfunction recognize(rootComponentType, config, urlTree, url) {\n  var paramsInheritanceStrategy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'emptyOnly';\n  var relativeLinkResolution = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'legacy';\n  return new Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution).recognize();\n}\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\n   * @param {?} rootComponentType\n   * @param {?} config\n   * @param {?} urlTree\n   * @param {?} url\n   * @param {?} paramsInheritanceStrategy\n   * @param {?} relativeLinkResolution\n   */\n  function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {\n    _classCallCheck(this, Recognizer);\n\n    this.rootComponentType = rootComponentType;\n    this.config = config;\n    this.urlTree = urlTree;\n    this.url = url;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n    this.relativeLinkResolution = relativeLinkResolution;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(Recognizer, [{\n    key: \"recognize\",\n    value: function recognize() {\n      try {\n        /** @type {?} */\n        var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\n        /** @type {?} */\n\n        var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n        /** @type {?} */\n\n        var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)),\n        /** @type {?} */\n        this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n        /** @type {?} */\n\n        var rootNode = new TreeNode(root, children);\n        /** @type {?} */\n\n        var routeState = new RouterStateSnapshot(this.url, rootNode);\n        this.inheritParamsAndData(routeState._root);\n        return of(routeState);\n      } catch (e) {\n        return new Observable(\n        /**\n        * @param {?} obs\n        * @return {?}\n        */\n        function (obs) {\n          return obs.error(e);\n        });\n      }\n    }\n    /**\n     * @param {?} routeNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"inheritParamsAndData\",\n    value: function inheritParamsAndData(routeNode) {\n      var _this26 = this;\n\n      /** @type {?} */\n      var route = routeNode.value;\n      /** @type {?} */\n\n      var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);\n      route.params = Object.freeze(i.params);\n      route.data = Object.freeze(i.data);\n      routeNode.children.forEach(\n      /**\n      * @param {?} n\n      * @return {?}\n      */\n      function (n) {\n        return _this26.inheritParamsAndData(n);\n      });\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegmentGroup\",\n    value: function processSegmentGroup(config, segmentGroup, outlet) {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return this.processChildren(config, segmentGroup);\n      }\n\n      return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @return {?}\n     */\n\n  }, {\n    key: \"processChildren\",\n    value: function processChildren(config, segmentGroup) {\n      var _this27 = this;\n\n      /** @type {?} */\n      var children = mapChildrenIntoArray(segmentGroup,\n      /**\n      * @param {?} child\n      * @param {?} childOutlet\n      * @return {?}\n      */\n      function (child, childOutlet) {\n        return _this27.processSegmentGroup(config, child, childOutlet);\n      });\n      checkOutletNameUniqueness(children);\n      sortActivatedRouteSnapshots(children);\n      return children;\n    }\n    /**\n     * @param {?} config\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegment\",\n    value: function processSegment(config, segmentGroup, segments, outlet) {\n      var _iterator7 = _createForOfIteratorHelper(config),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var r = _step7.value;\n\n          try {\n            return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n          } catch (e) {\n            if (!(e instanceof NoMatch$1)) throw e;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n        return [];\n      }\n\n      throw new NoMatch$1();\n    }\n    /**\n     * @private\n     * @param {?} segmentGroup\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"noLeftoversInUrl\",\n    value: function noLeftoversInUrl(segmentGroup, segments, outlet) {\n      return segments.length === 0 && !segmentGroup.children[outlet];\n    }\n    /**\n     * @param {?} route\n     * @param {?} rawSegment\n     * @param {?} segments\n     * @param {?} outlet\n     * @return {?}\n     */\n\n  }, {\n    key: \"processSegmentAgainstRoute\",\n    value: function processSegmentAgainstRoute(route, rawSegment, segments, outlet) {\n      if (route.redirectTo) throw new NoMatch$1();\n      if ((route.outlet || PRIMARY_OUTLET) !== outlet) throw new NoMatch$1();\n      /** @type {?} */\n\n      var snapshot;\n      /** @type {?} */\n\n      var consumedSegments = [];\n      /** @type {?} */\n\n      var rawSlicedSegments = [];\n\n      if (route.path === '**') {\n        /** @type {?} */\n        var params = segments.length > 0 ?\n        /** @type {?} */\n        last(segments).parameters : {};\n        snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(Object.assign({}, this.urlTree.queryParams)),\n        /** @type {?} */\n        this.urlTree.fragment, getData(route), outlet,\n        /** @type {?} */\n        route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n      } else {\n        /** @type {?} */\n        var result = match$1(rawSegment, route, segments);\n        consumedSegments = result.consumedSegments;\n        rawSlicedSegments = segments.slice(result.lastChild);\n        snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)),\n        /** @type {?} */\n        this.urlTree.fragment, getData(route), outlet,\n        /** @type {?} */\n        route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n      }\n      /** @type {?} */\n\n\n      var childConfig = getChildConfig(route);\n\n      var _split$ = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution),\n          segmentGroup = _split$.segmentGroup,\n          slicedSegments = _split$.slicedSegments;\n\n      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n        /** @type {?} */\n        var _children3 = this.processChildren(childConfig, segmentGroup);\n\n        return [new TreeNode(snapshot, _children3)];\n      }\n\n      if (childConfig.length === 0 && slicedSegments.length === 0) {\n        return [new TreeNode(snapshot, [])];\n      }\n      /** @type {?} */\n\n\n      var children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n      return [new TreeNode(snapshot, children)];\n    }\n  }]);\n\n  return Recognizer;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  Recognizer.prototype.rootComponentType;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Recognizer.prototype.config;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Recognizer.prototype.urlTree;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Recognizer.prototype.url;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Recognizer.prototype.paramsInheritanceStrategy;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Recognizer.prototype.relativeLinkResolution;\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\n\n\nfunction sortActivatedRouteSnapshots(nodes) {\n  nodes.sort(\n  /**\n  * @param {?} a\n  * @param {?} b\n  * @return {?}\n  */\n  function (a, b) {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getChildConfig(route) {\n  if (route.children) {\n    return route.children;\n  }\n\n  if (route.loadChildren) {\n    return (\n      /** @type {?} */\n      route._loadedConfig.routes\n    );\n  }\n\n  return [];\n}\n/**\n * @record\n */\n\n\nfunction MatchResult() {}\n\nif (false) {\n  /** @type {?} */\n  MatchResult.prototype.consumedSegments;\n  /** @type {?} */\n\n  MatchResult.prototype.lastChild;\n  /** @type {?} */\n\n  MatchResult.prototype.parameters;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} route\n * @param {?} segments\n * @return {?}\n */\n\n\nfunction match$1(segmentGroup, route, segments) {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      throw new NoMatch$1();\n    }\n\n    return {\n      consumedSegments: [],\n      lastChild: 0,\n      parameters: {}\n    };\n  }\n  /** @type {?} */\n\n\n  var matcher = route.matcher || defaultUrlMatcher;\n  /** @type {?} */\n\n  var res = matcher(segments, segmentGroup, route);\n  if (!res) throw new NoMatch$1();\n  /** @type {?} */\n\n  var posParams = {};\n  forEach(\n  /** @type {?} */\n  res.posParams,\n  /**\n  * @param {?} v\n  * @param {?} k\n  * @return {?}\n  */\n  function (v, k) {\n    posParams[k] = v.path;\n  });\n  /** @type {?} */\n\n  var parameters = res.consumed.length > 0 ? Object.assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) : posParams;\n  return {\n    consumedSegments: res.consumed,\n    lastChild: res.consumed.length,\n    parameters: parameters\n  };\n}\n/**\n * @param {?} nodes\n * @return {?}\n */\n\n\nfunction checkOutletNameUniqueness(nodes) {\n  /** @type {?} */\n  var names = {};\n  nodes.forEach(\n  /**\n  * @param {?} n\n  * @return {?}\n  */\n  function (n) {\n    /** @type {?} */\n    var routeWithSameOutletName = names[n.value.outlet];\n\n    if (routeWithSameOutletName) {\n      /** @type {?} */\n      var p = routeWithSameOutletName.url.map(\n      /**\n      * @param {?} s\n      * @return {?}\n      */\n      function (s) {\n        return s.toString();\n      }).join('/');\n      /** @type {?} */\n\n      var c = n.value.url.map(\n      /**\n      * @param {?} s\n      * @return {?}\n      */\n      function (s) {\n        return s.toString();\n      }).join('/');\n      throw new Error(\"Two segments cannot have the same outlet name: '\".concat(p, \"' and '\").concat(c, \"'.\"));\n    }\n\n    names[n.value.outlet] = n.value;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction getSourceSegmentGroup(segmentGroup) {\n  /** @type {?} */\n  var s = segmentGroup;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n  }\n\n  return s;\n}\n/**\n * @param {?} segmentGroup\n * @return {?}\n */\n\n\nfunction getPathIndexShift(segmentGroup) {\n  /** @type {?} */\n  var s = segmentGroup;\n  /** @type {?} */\n\n  var res = s._segmentIndexShift ? s._segmentIndexShift : 0;\n\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n    res += s._segmentIndexShift ? s._segmentIndexShift : 0;\n  }\n\n  return res - 1;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} config\n * @param {?} relativeLinkResolution\n * @return {?}\n */\n\n\nfunction split$1(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution) {\n  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    /** @type {?} */\n    var _s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n\n    _s2._sourceSegment = segmentGroup;\n    _s2._segmentIndexShift = consumedSegments.length;\n    return {\n      segmentGroup: _s2,\n      slicedSegments: []\n    };\n  }\n\n  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    /** @type {?} */\n    var _s3 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));\n\n    _s3._sourceSegment = segmentGroup;\n    _s3._segmentIndexShift = consumedSegments.length;\n    return {\n      segmentGroup: _s3,\n      slicedSegments: slicedSegments\n    };\n  }\n  /** @type {?} */\n\n\n  var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  s._sourceSegment = segmentGroup;\n  s._segmentIndexShift = consumedSegments.length;\n  return {\n    segmentGroup: s,\n    slicedSegments: slicedSegments\n  };\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} slicedSegments\n * @param {?} routes\n * @param {?} children\n * @param {?} relativeLinkResolution\n * @return {?}\n */\n\n\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {\n  /** @type {?} */\n  var res = {};\n\n  var _iterator8 = _createForOfIteratorHelper(routes),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var r = _step8.value;\n\n      if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\n        /** @type {?} */\n        var s = new UrlSegmentGroup([], {});\n        s._sourceSegment = segmentGroup;\n\n        if (relativeLinkResolution === 'legacy') {\n          s._segmentIndexShift = segmentGroup.segments.length;\n        } else {\n          s._segmentIndexShift = consumedSegments.length;\n        }\n\n        res[getOutlet$1(r)] = s;\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return Object.assign({}, children, res);\n}\n/**\n * @param {?} segmentGroup\n * @param {?} consumedSegments\n * @param {?} routes\n * @param {?} primarySegment\n * @return {?}\n */\n\n\nfunction createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\n  /** @type {?} */\n  var res = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  primarySegment._sourceSegment = segmentGroup;\n  primarySegment._segmentIndexShift = consumedSegments.length;\n\n  var _iterator9 = _createForOfIteratorHelper(routes),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var r = _step9.value;\n\n      if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {\n        /** @type {?} */\n        var s = new UrlSegmentGroup([], {});\n        s._sourceSegment = segmentGroup;\n        s._segmentIndexShift = consumedSegments.length;\n        res[getOutlet$1(r)] = s;\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return res;\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n  return routes.some(\n  /**\n  * @param {?} r\n  * @return {?}\n  */\n  function (r) {\n    return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET;\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} routes\n * @return {?}\n */\n\n\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n  return routes.some(\n  /**\n  * @param {?} r\n  * @return {?}\n  */\n  function (r) {\n    return emptyPathMatch(segmentGroup, slicedSegments, r);\n  });\n}\n/**\n * @param {?} segmentGroup\n * @param {?} slicedSegments\n * @param {?} r\n * @return {?}\n */\n\n\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo === undefined;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getOutlet$1(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getData(route) {\n  return route.data || {};\n}\n/**\n * @param {?} route\n * @return {?}\n */\n\n\nfunction getResolve(route) {\n  return route.resolve || {};\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} rootComponentType\n * @param {?} config\n * @param {?} serializer\n * @param {?} paramsInheritanceStrategy\n * @param {?} relativeLinkResolution\n * @return {?}\n */\n\n\nfunction recognize$1(rootComponentType, config, serializer, paramsInheritanceStrategy, relativeLinkResolution) {\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    function (source) {\n      return source.pipe(mergeMap(\n      /**\n      * @param {?} t\n      * @return {?}\n      */\n      function (t) {\n        return recognize(rootComponentType, config, t.urlAfterRedirects, serializer(t.urlAfterRedirects), paramsInheritanceStrategy, relativeLinkResolution).pipe(map(\n        /**\n        * @param {?} targetSnapshot\n        * @return {?}\n        */\n        function (targetSnapshot) {\n          return Object.assign({}, t, {\n            targetSnapshot: targetSnapshot\n          });\n        }));\n      }));\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} paramsInheritanceStrategy\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction resolveData(paramsInheritanceStrategy, moduleInjector) {\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    function (source) {\n      return source.pipe(mergeMap(\n      /**\n      * @param {?} t\n      * @return {?}\n      */\n      function (t) {\n        var targetSnapshot = t.targetSnapshot,\n            canActivateChecks = t.guards.canActivateChecks;\n\n        if (!canActivateChecks.length) {\n          return of(t);\n        }\n\n        return from(canActivateChecks).pipe(concatMap(\n        /**\n        * @param {?} check\n        * @return {?}\n        */\n        function (check) {\n          return runResolve(check.route,\n          /** @type {?} */\n          targetSnapshot, paramsInheritanceStrategy, moduleInjector);\n        }), reduce(\n        /**\n        * @param {?} _\n        * @param {?} __\n        * @return {?}\n        */\n        function (_, __) {\n          return _;\n        }), map(\n        /**\n        * @param {?} _\n        * @return {?}\n        */\n        function (_) {\n          return t;\n        }));\n      }));\n    }\n  );\n}\n/**\n * @param {?} futureARS\n * @param {?} futureRSS\n * @param {?} paramsInheritanceStrategy\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, moduleInjector) {\n  /** @type {?} */\n  var resolve = futureARS._resolve;\n  return resolveNode(resolve, futureARS, futureRSS, moduleInjector).pipe(map(\n  /**\n  * @param {?} resolvedData\n  * @return {?}\n  */\n  function (resolvedData) {\n    futureARS._resolvedData = resolvedData;\n    futureARS.data = Object.assign({}, futureARS.data, inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve);\n    return null;\n  }));\n}\n/**\n * @param {?} resolve\n * @param {?} futureARS\n * @param {?} futureRSS\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction resolveNode(resolve, futureARS, futureRSS, moduleInjector) {\n  /** @type {?} */\n  var keys = Object.keys(resolve);\n\n  if (keys.length === 0) {\n    return of({});\n  }\n\n  if (keys.length === 1) {\n    /** @type {?} */\n    var key = keys[0];\n    return getResolver(resolve[key], futureARS, futureRSS, moduleInjector).pipe(map(\n    /**\n    * @param {?} value\n    * @return {?}\n    */\n    function (value) {\n      return _defineProperty({}, key, value);\n    }));\n  }\n  /** @type {?} */\n\n\n  var data = {};\n  /** @type {?} */\n\n  var runningResolvers$ = from(keys).pipe(mergeMap(\n  /**\n  * @param {?} key\n  * @return {?}\n  */\n  function (key) {\n    return getResolver(resolve[key], futureARS, futureRSS, moduleInjector).pipe(map(\n    /**\n    * @param {?} value\n    * @return {?}\n    */\n    function (value) {\n      data[key] = value;\n      return value;\n    }));\n  }));\n  return runningResolvers$.pipe(last$1(), map(\n  /**\n  * @return {?}\n  */\n  function () {\n    return data;\n  }));\n}\n/**\n * @param {?} injectionToken\n * @param {?} futureARS\n * @param {?} futureRSS\n * @param {?} moduleInjector\n * @return {?}\n */\n\n\nfunction getResolver(injectionToken, futureARS, futureRSS, moduleInjector) {\n  /** @type {?} */\n  var resolver = getToken(injectionToken, futureARS, moduleInjector);\n  return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) : wrapIntoObservable(resolver(futureARS, futureRSS));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n * @template T\n * @param {?} next\n * @return {?}\n */\n\n\nfunction switchTap(next) {\n  return (\n    /**\n    * @param {?} source\n    * @return {?}\n    */\n    function (source) {\n      return source.pipe(switchMap(\n      /**\n      * @param {?} v\n      * @return {?}\n      */\n      function (v) {\n        /** @type {?} */\n        var nextResult = next(v);\n\n        if (nextResult) {\n          return from(nextResult).pipe(map(\n          /**\n          * @return {?}\n          */\n          function () {\n            return v;\n          }));\n        }\n\n        return from([v]);\n      }));\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * \\@publicApi\n * @abstract\n */\n\n\nvar RouteReuseStrategy = function RouteReuseStrategy() {\n  _classCallCheck(this, RouteReuseStrategy);\n};\n\nif (false) {\n  /**\n   * Determines if this route (and its subtree) should be detached to be reused later\n   * @abstract\n   * @param {?} route\n   * @return {?}\n   */\n  RouteReuseStrategy.prototype.shouldDetach = function (route) {};\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   * @abstract\n   * @param {?} route\n   * @param {?} handle\n   * @return {?}\n   */\n\n\n  RouteReuseStrategy.prototype.store = function (route, handle) {};\n  /**\n   * Determines if this route (and its subtree) should be reattached\n   * @abstract\n   * @param {?} route\n   * @return {?}\n   */\n\n\n  RouteReuseStrategy.prototype.shouldAttach = function (route) {};\n  /**\n   * Retrieves the previously stored route\n   * @abstract\n   * @param {?} route\n   * @return {?}\n   */\n\n\n  RouteReuseStrategy.prototype.retrieve = function (route) {};\n  /**\n   * Determines if a route should be reused\n   * @abstract\n   * @param {?} future\n   * @param {?} curr\n   * @return {?}\n   */\n\n\n  RouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {};\n}\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\n\n\nvar DefaultRouteReuseStrategy = /*#__PURE__*/function () {\n  function DefaultRouteReuseStrategy() {\n    _classCallCheck(this, DefaultRouteReuseStrategy);\n  }\n\n  _createClass(DefaultRouteReuseStrategy, [{\n    key: \"shouldDetach\",\n    value:\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n    function shouldDetach(route) {\n      return false;\n    }\n    /**\n     * @param {?} route\n     * @param {?} detachedTree\n     * @return {?}\n     */\n\n  }, {\n    key: \"store\",\n    value: function store(route, detachedTree) {}\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldAttach\",\n    value: function shouldAttach(route) {\n      return false;\n    }\n    /**\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(route) {\n      return null;\n    }\n    /**\n     * @param {?} future\n     * @param {?} curr\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldReuseRoute\",\n    value: function shouldReuseRoute(future, curr) {\n      return future.routeConfig === curr.routeConfig;\n    }\n  }]);\n\n  return DefaultRouteReuseStrategy;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The [DI token](guide/glossary/#di-token) for a router configuration.\n * @see `ROUTES`\n * \\@publicApi\n * @type {?}\n */\n\n\nvar ROUTES = new InjectionToken('ROUTES');\n\nvar RouterConfigLoader = /*#__PURE__*/function () {\n  /**\n   * @param {?} loader\n   * @param {?} compiler\n   * @param {?=} onLoadStartListener\n   * @param {?=} onLoadEndListener\n   */\n  function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {\n    _classCallCheck(this, RouterConfigLoader);\n\n    this.loader = loader;\n    this.compiler = compiler;\n    this.onLoadStartListener = onLoadStartListener;\n    this.onLoadEndListener = onLoadEndListener;\n  }\n  /**\n   * @param {?} parentInjector\n   * @param {?} route\n   * @return {?}\n   */\n\n\n  _createClass(RouterConfigLoader, [{\n    key: \"load\",\n    value: function load(parentInjector, route) {\n      var _this28 = this;\n\n      if (this.onLoadStartListener) {\n        this.onLoadStartListener(route);\n      }\n      /** @type {?} */\n\n\n      var moduleFactory$ = this.loadModuleFactory(\n      /** @type {?} */\n      route.loadChildren);\n      return moduleFactory$.pipe(map(\n      /**\n      * @param {?} factory\n      * @return {?}\n      */\n      function (factory) {\n        if (_this28.onLoadEndListener) {\n          _this28.onLoadEndListener(route);\n        }\n        /** @type {?} */\n\n\n        var module = factory.create(parentInjector);\n        return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);\n      }));\n    }\n    /**\n     * @private\n     * @param {?} loadChildren\n     * @return {?}\n     */\n\n  }, {\n    key: \"loadModuleFactory\",\n    value: function loadModuleFactory(loadChildren) {\n      var _this29 = this;\n\n      if (typeof loadChildren === 'string') {\n        return from(this.loader.load(loadChildren));\n      } else {\n        return wrapIntoObservable(loadChildren()).pipe(mergeMap(\n        /**\n        * @param {?} t\n        * @return {?}\n        */\n        function (t) {\n          if (t instanceof NgModuleFactory) {\n            return of(t);\n          } else {\n            return from(_this29.compiler.compileModuleAsync(t));\n          }\n        }));\n      }\n    }\n  }]);\n\n  return RouterConfigLoader;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  RouterConfigLoader.prototype.loader;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterConfigLoader.prototype.compiler;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterConfigLoader.prototype.onLoadStartListener;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterConfigLoader.prototype.onLoadEndListener;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * \\@description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * \\@publicApi\n * @abstract\n */\n\n\nvar UrlHandlingStrategy = function UrlHandlingStrategy() {\n  _classCallCheck(this, UrlHandlingStrategy);\n};\n\nif (false) {\n  /**\n   * Tells the router if this URL should be processed.\n   *\n   * When it returns true, the router will execute the regular navigation.\n   * When it returns false, the router will set the router state to an empty state.\n   * As a result, all the active components will be destroyed.\n   *\n   * @abstract\n   * @param {?} url\n   * @return {?}\n   */\n  UrlHandlingStrategy.prototype.shouldProcessUrl = function (url) {};\n  /**\n   * Extracts the part of the URL that should be handled by the router.\n   * The rest of the URL will remain untouched.\n   * @abstract\n   * @param {?} url\n   * @return {?}\n   */\n\n\n  UrlHandlingStrategy.prototype.extract = function (url) {};\n  /**\n   * Merges the URL fragment with the rest of the URL.\n   * @abstract\n   * @param {?} newUrlPart\n   * @param {?} rawUrl\n   * @return {?}\n   */\n\n\n  UrlHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) {};\n}\n/**\n * \\@publicApi\n */\n\n\nvar DefaultUrlHandlingStrategy = /*#__PURE__*/function () {\n  function DefaultUrlHandlingStrategy() {\n    _classCallCheck(this, DefaultUrlHandlingStrategy);\n  }\n\n  _createClass(DefaultUrlHandlingStrategy, [{\n    key: \"shouldProcessUrl\",\n    value:\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    function shouldProcessUrl(url) {\n      return true;\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n\n  }, {\n    key: \"extract\",\n    value: function extract(url) {\n      return url;\n    }\n    /**\n     * @param {?} newUrlPart\n     * @param {?} wholeUrl\n     * @return {?}\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(newUrlPart, wholeUrl) {\n      return newUrlPart;\n    }\n  }]);\n\n  return DefaultUrlHandlingStrategy;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Options that modify the navigation strategy.\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction NavigationExtras() {}\n\nif (false) {\n  /**\n   * Specifies a root URI to use for relative navigation.\n   *\n   * For example, consider the following route configuration where the parent route\n   * has two children.\n   *\n   * ```\n   * [{\n   *   path: 'parent',\n   *   component: ParentComponent,\n   *   children: [{\n   *     path: 'list',\n   *     component: ListComponent\n   *   },{\n   *     path: 'child',\n   *     component: ChildComponent\n   *   }]\n   * }]\n   * ```\n   *\n   * The following `go()` function navigates to the `list` route by\n   * interpreting the destination URI as relative to the activated `child`  route\n   *\n   * ```\n   * \\@Component({...})\n   *  class ChildComponent {\n   *    constructor(private router: Router, private route: ActivatedRoute) {}\n   *\n   *    go() {\n   *      this.router.navigate(['../list'], { relativeTo: this.route });\n   *    }\n   *  }\n   * ```\n   * @type {?|undefined}\n   */\n  NavigationExtras.prototype.relativeTo;\n  /**\n   * Sets query parameters to the URL.\n   *\n   * ```\n   * // Navigate to /results?page=1\n   * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n   * ```\n   * @type {?|undefined}\n   */\n\n  NavigationExtras.prototype.queryParams;\n  /**\n   * Sets the hash fragment for the URL.\n   *\n   * ```\n   * // Navigate to /results#top\n   * this.router.navigate(['/results'], { fragment: 'top' });\n   * ```\n   * @type {?|undefined}\n   */\n\n  NavigationExtras.prototype.fragment;\n  /**\n   * **DEPRECATED**: Use `queryParamsHandling: \"preserve\"` instead to preserve\n   * query parameters for the next navigation.\n   *\n   * @deprecated since v4\n   * @type {?|undefined}\n   */\n\n  NavigationExtras.prototype.preserveQueryParams;\n  /**\n   * How to handle query parameters in the router link for the next navigation.\n   * One of:\n   * * `merge` : Merge new with current parameters.\n   * * `preserve` : Preserve current parameters.\n   *\n   * ```\n   * // from /results?page=1 to /view?page=1&page=2\n   * this.router.navigate(['/view'], { queryParams: { page: 2 },  queryParamsHandling: \"merge\" });\n   * ```\n   * @type {?|undefined}\n   */\n\n  NavigationExtras.prototype.queryParamsHandling;\n  /**\n   * When true, preserves the URL fragment for the next navigation\n   *\n   * ```\n   * // Preserve fragment from /results#top to /view#top\n   * this.router.navigate(['/view'], { preserveFragment: true });\n   * ```\n   * @type {?|undefined}\n   */\n\n  NavigationExtras.prototype.preserveFragment;\n  /**\n   * When true, navigates without pushing a new state into history.\n   *\n   * ```\n   * // Navigate silently to /view\n   * this.router.navigate(['/view'], { skipLocationChange: true });\n   * ```\n   * @type {?|undefined}\n   */\n\n  NavigationExtras.prototype.skipLocationChange;\n  /**\n   * When true, navigates while replacing the current state in history.\n   *\n   * ```\n   * // Navigate to /view\n   * this.router.navigate(['/view'], { replaceUrl: true });\n   * ```\n   * @type {?|undefined}\n   */\n\n  NavigationExtras.prototype.replaceUrl;\n  /**\n   * Developer-defined state that can be passed to any navigation.\n   * Access this value through the `Navigation.extras` object\n   * returned from `router.getCurrentNavigation()` while a navigation is executing.\n   *\n   * After a navigation completes, the router writes an object containing this\n   * value together with a `navigationId` to `history.state`.\n   * The value is written when `location.go()` or `location.replaceState()`\n   * is called before activating this route.\n   *\n   * Note that `history.state` does not pass an object equality test because\n   * the router adds the `navigationId` on each navigation.\n   * @type {?|undefined}\n   */\n\n  NavigationExtras.prototype.state;\n}\n/**\n * @param {?} error\n * @return {?}\n */\n\n\nfunction defaultErrorHandler(error) {\n  throw error;\n}\n/**\n * @param {?} error\n * @param {?} urlSerializer\n * @param {?} url\n * @return {?}\n */\n\n\nfunction defaultMalformedUriErrorHandler(error, urlSerializer, url) {\n  return urlSerializer.parse('/');\n}\n/**\n * \\@internal\n * @param {?} snapshot\n * @param {?} runExtras\n * @return {?}\n */\n\n\nfunction defaultRouterHook(snapshot, runExtras) {\n  return (\n    /** @type {?} */\n    of(null)\n  );\n}\n/**\n * \\@description\n *\n * A service that provides navigation and URL manipulation capabilities.\n *\n * @see `Route`.\n * @see [Routing and Navigation Guide](guide/router).\n *\n * \\@ngModule RouterModule\n *\n * \\@publicApi\n */\n\n\nvar Router = /*#__PURE__*/function () {\n  /**\n   * Creates the router service.\n   * @param {?} rootComponentType\n   * @param {?} urlSerializer\n   * @param {?} rootContexts\n   * @param {?} location\n   * @param {?} injector\n   * @param {?} loader\n   * @param {?} compiler\n   * @param {?} config\n   */\n  // TODO: vsavkin make internal after the final is out.\n  function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {\n    var _this30 = this;\n\n    _classCallCheck(this, Router);\n\n    this.rootComponentType = rootComponentType;\n    this.urlSerializer = urlSerializer;\n    this.rootContexts = rootContexts;\n    this.location = location;\n    this.config = config;\n    this.lastSuccessfulNavigation = null;\n    this.currentNavigation = null;\n    this.navigationId = 0;\n    this.isNgZoneEnabled = false;\n    /**\n     * An event stream for routing events in this NgModule.\n     */\n\n    this.events = new Subject();\n    /**\n     * A handler for navigation errors in this NgModule.\n     */\n\n    this.errorHandler = defaultErrorHandler;\n    /**\n     * A handler for errors thrown by `Router.parseUrl(url)`\n     * when `url` contains an invalid character.\n     * The most common case is a `%` sign\n     * that's not encoded and is not part of a percent encoded sequence.\n     */\n\n    this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;\n    /**\n     * True if at least one navigation event has occurred,\n     * false otherwise.\n     */\n\n    this.navigated = false;\n    this.lastSuccessfulId = -1;\n    /**\n     * Hooks that enable you to pause navigation,\n     * either before or after the preactivation phase.\n     * Used by `RouterModule`.\n     *\n     * \\@internal\n     */\n\n    this.hooks = {\n      beforePreactivation: defaultRouterHook,\n      afterPreactivation: defaultRouterHook\n    };\n    /**\n     * A strategy for extracting and merging URLs.\n     * Used for AngularJS to Angular migrations.\n     */\n\n    this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\n    /**\n     * A strategy for re-using routes.\n     */\n\n    this.routeReuseStrategy = new DefaultRouteReuseStrategy();\n    /**\n     * How to handle a navigation request to the current URL. One of:\n     * - `'ignore'` :  The router ignores the request.\n     * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\n     */\n\n    this.onSameUrlNavigation = 'ignore';\n    /**\n     * How to merge parameters, data, and resolved data from parent to child\n     * routes. One of:\n     *\n     * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\n     * for path-less or component-less routes.\n     * - `'always'` : Inherit parent parameters, data, and resolved data\n     * for all child routes.\n     */\n\n    this.paramsInheritanceStrategy = 'emptyOnly';\n    /**\n     * Determines when the router updates the browser URL.\n     * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\n     * Set to `'eager'` to update the browser URL at the beginning of navigation.\n     * You can choose to update early so that, if navigation fails,\n     * you can show an error message with the URL that failed.\n     */\n\n    this.urlUpdateStrategy = 'deferred';\n    /**\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\n     * @see `RouterModule`\n     */\n\n    this.relativeLinkResolution = 'legacy';\n    /** @type {?} */\n\n    var onLoadStart =\n    /**\n    * @param {?} r\n    * @return {?}\n    */\n    function onLoadStart(r) {\n      return _this30.triggerEvent(new RouteConfigLoadStart(r));\n    };\n    /** @type {?} */\n\n\n    var onLoadEnd =\n    /**\n    * @param {?} r\n    * @return {?}\n    */\n    function onLoadEnd(r) {\n      return _this30.triggerEvent(new RouteConfigLoadEnd(r));\n    };\n\n    this.ngModule = injector.get(NgModuleRef);\n    this.console = injector.get(ɵConsole);\n    /** @type {?} */\n\n    var ngZone = injector.get(NgZone);\n    this.isNgZoneEnabled = ngZone instanceof NgZone;\n    this.resetConfig(config);\n    this.currentUrlTree = createEmptyUrlTree();\n    this.rawUrlTree = this.currentUrlTree;\n    this.browserUrlTree = this.currentUrlTree;\n    this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\n    this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n    this.transitions = new BehaviorSubject({\n      id: 0,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.currentUrlTree,\n      extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),\n      urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),\n      rawUrl: this.currentUrlTree,\n      extras: {},\n      resolve: null,\n      reject: null,\n      promise: Promise.resolve(true),\n      source: 'imperative',\n      restoredState: null,\n      currentSnapshot: this.routerState.snapshot,\n      targetSnapshot: null,\n      currentRouterState: this.routerState,\n      targetRouterState: null,\n      guards: {\n        canActivateChecks: [],\n        canDeactivateChecks: []\n      },\n      guardsResult: null\n    });\n    this.navigations = this.setupNavigations(this.transitions);\n    this.processNavigations();\n  }\n  /**\n   * @private\n   * @param {?} transitions\n   * @return {?}\n   */\n\n\n  _createClass(Router, [{\n    key: \"setupNavigations\",\n    value: function setupNavigations(transitions) {\n      var _this31 = this;\n\n      /** @type {?} */\n      var eventsSubject =\n      /** @type {?} */\n      this.events;\n      return (\n        /** @type {?} */\n\n        /** @type {?} */\n        transitions.pipe(filter(\n        /**\n        * @param {?} t\n        * @return {?}\n        */\n        function (t) {\n          return t.id !== 0;\n        }), // Extract URL\n        map(\n        /**\n        * @param {?} t\n        * @return {?}\n        */\n        function (t) {\n          return (\n            /** @type {?} */\n            Object.assign({}, t, {\n              extractedUrl: _this31.urlHandlingStrategy.extract(t.rawUrl)\n            })\n          );\n        }), // Using switchMap so we cancel executing navigations when a new one comes in\n        switchMap(\n        /**\n        * @param {?} t\n        * @return {?}\n        */\n        function (t) {\n          /** @type {?} */\n          var completed = false;\n          /** @type {?} */\n\n          var errored = false;\n          return of(t).pipe( // Store the Navigation object\n          tap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            _this31.currentNavigation = {\n              id: t.id,\n              initialUrl: t.currentRawUrl,\n              extractedUrl: t.extractedUrl,\n              trigger: t.source,\n              extras: t.extras,\n              previousNavigation: _this31.lastSuccessfulNavigation ? Object.assign({}, _this31.lastSuccessfulNavigation, {\n                previousNavigation: null\n              }) : null\n            };\n          }), switchMap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            /** @type {?} */\n            var urlTransition = !_this31.navigated || t.extractedUrl.toString() !== _this31.browserUrlTree.toString();\n            /** @type {?} */\n\n\n            var processCurrentUrl = (_this31.onSameUrlNavigation === 'reload' ? true : urlTransition) && _this31.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);\n\n            if (processCurrentUrl) {\n              return of(t).pipe( // Fire NavigationStart event\n              switchMap(\n              /**\n              * @param {?} t\n              * @return {?}\n              */\n              function (t) {\n                /** @type {?} */\n                var transition = _this31.transitions.getValue();\n\n                eventsSubject.next(new NavigationStart(t.id, _this31.serializeUrl(t.extractedUrl), t.source, t.restoredState));\n\n                if (transition !== _this31.transitions.getValue()) {\n                  return EMPTY;\n                }\n\n                return [t];\n              }), // This delay is required to match old behavior that forced navigation to\n              // always be async\n              switchMap(\n              /**\n              * @param {?} t\n              * @return {?}\n              */\n              function (t) {\n                return Promise.resolve(t);\n              }), // ApplyRedirects\n              applyRedirects$1(_this31.ngModule.injector, _this31.configLoader, _this31.urlSerializer, _this31.config), // Update the currentNavigation\n              tap(\n              /**\n              * @param {?} t\n              * @return {?}\n              */\n              function (t) {\n                _this31.currentNavigation = Object.assign({},\n                /** @type {?} */\n                _this31.currentNavigation, {\n                  finalUrl: t.urlAfterRedirects\n                });\n              }), // Recognize\n              recognize$1(_this31.rootComponentType, _this31.config,\n              /**\n              * @param {?} url\n              * @return {?}\n              */\n              function (url) {\n                return _this31.serializeUrl(url);\n              }, _this31.paramsInheritanceStrategy, _this31.relativeLinkResolution), // Update URL if in `eager` update mode\n              tap(\n              /**\n              * @param {?} t\n              * @return {?}\n              */\n              function (t) {\n                if (_this31.urlUpdateStrategy === 'eager') {\n                  if (!t.extras.skipLocationChange) {\n                    _this31.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state);\n                  }\n\n                  _this31.browserUrlTree = t.urlAfterRedirects;\n                }\n              }), // Fire RoutesRecognized\n              tap(\n              /**\n              * @param {?} t\n              * @return {?}\n              */\n              function (t) {\n                /** @type {?} */\n                var routesRecognized = new RoutesRecognized(t.id, _this31.serializeUrl(t.extractedUrl), _this31.serializeUrl(t.urlAfterRedirects),\n                /** @type {?} */\n                t.targetSnapshot);\n                eventsSubject.next(routesRecognized);\n              }));\n            } else {\n              /** @type {?} */\n              var processPreviousUrl = urlTransition && _this31.rawUrlTree && _this31.urlHandlingStrategy.shouldProcessUrl(_this31.rawUrlTree);\n              /* When the current URL shouldn't be processed, but the previous one was, we\n               * handle this \"error condition\" by navigating to the previously successful URL,\n               * but leaving the URL intact.*/\n\n\n              if (processPreviousUrl) {\n                var id = t.id,\n                    extractedUrl = t.extractedUrl,\n                    source = t.source,\n                    restoredState = t.restoredState,\n                    extras = t.extras;\n                /** @type {?} */\n\n                var navStart = new NavigationStart(id, _this31.serializeUrl(extractedUrl), source, restoredState);\n                eventsSubject.next(navStart);\n                /** @type {?} */\n\n                var targetSnapshot = createEmptyState(extractedUrl, _this31.rootComponentType).snapshot;\n                return of(Object.assign({}, t, {\n                  targetSnapshot: targetSnapshot,\n                  urlAfterRedirects: extractedUrl,\n                  extras: Object.assign({}, extras, {\n                    skipLocationChange: false,\n                    replaceUrl: false\n                  })\n                }));\n              } else {\n                /* When neither the current or previous URL can be processed, do nothing other\n                 * than update router's internal reference to the current \"settled\" URL. This\n                 * way the next navigation will be coming from the current URL in the browser.\n                 */\n                _this31.rawUrlTree = t.rawUrl;\n                _this31.browserUrlTree = t.urlAfterRedirects;\n                t.resolve(null);\n                return EMPTY;\n              }\n            }\n          }), // Before Preactivation\n          switchTap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            var targetSnapshot = t.targetSnapshot,\n                navigationId = t.id,\n                appliedUrlTree = t.extractedUrl,\n                rawUrlTree = t.rawUrl,\n                _t$extras = t.extras,\n                skipLocationChange = _t$extras.skipLocationChange,\n                replaceUrl = _t$extras.replaceUrl;\n            return _this31.hooks.beforePreactivation(\n            /** @type {?} */\n            targetSnapshot, {\n              navigationId: navigationId,\n              appliedUrlTree: appliedUrlTree,\n              rawUrlTree: rawUrlTree,\n              skipLocationChange: !!skipLocationChange,\n              replaceUrl: !!replaceUrl\n            });\n          }), // --- GUARDS ---\n          tap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            /** @type {?} */\n            var guardsStart = new GuardsCheckStart(t.id, _this31.serializeUrl(t.extractedUrl), _this31.serializeUrl(t.urlAfterRedirects),\n            /** @type {?} */\n            t.targetSnapshot);\n\n            _this31.triggerEvent(guardsStart);\n          }), map(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            return Object.assign({}, t, {\n              guards: getAllRouteGuards(\n              /** @type {?} */\n              t.targetSnapshot, t.currentSnapshot, _this31.rootContexts)\n            });\n          }), checkGuards(_this31.ngModule.injector,\n          /**\n          * @param {?} evt\n          * @return {?}\n          */\n          function (evt) {\n            return _this31.triggerEvent(evt);\n          }), tap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            if (isUrlTree(t.guardsResult)) {\n              /** @type {?} */\n              var error = navigationCancelingError(\"Redirecting to \\\"\".concat(_this31.serializeUrl(t.guardsResult), \"\\\"\"));\n              error.url = t.guardsResult;\n              throw error;\n            }\n          }), tap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            /** @type {?} */\n            var guardsEnd = new GuardsCheckEnd(t.id, _this31.serializeUrl(t.extractedUrl), _this31.serializeUrl(t.urlAfterRedirects),\n            /** @type {?} */\n            t.targetSnapshot, !!t.guardsResult);\n\n            _this31.triggerEvent(guardsEnd);\n          }), filter(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            if (!t.guardsResult) {\n              _this31.resetUrlToCurrentUrlTree();\n              /** @type {?} */\n\n\n              var navCancel = new NavigationCancel(t.id, _this31.serializeUrl(t.extractedUrl), '');\n              eventsSubject.next(navCancel);\n              t.resolve(false);\n              return false;\n            }\n\n            return true;\n          }), // --- RESOLVE ---\n          switchTap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            if (t.guards.canActivateChecks.length) {\n              return of(t).pipe(tap(\n              /**\n              * @param {?} t\n              * @return {?}\n              */\n              function (t) {\n                /** @type {?} */\n                var resolveStart = new ResolveStart(t.id, _this31.serializeUrl(t.extractedUrl), _this31.serializeUrl(t.urlAfterRedirects),\n                /** @type {?} */\n                t.targetSnapshot);\n\n                _this31.triggerEvent(resolveStart);\n              }), resolveData(_this31.paramsInheritanceStrategy, _this31.ngModule.injector), //\n              tap(\n              /**\n              * @param {?} t\n              * @return {?}\n              */\n              function (t) {\n                /** @type {?} */\n                var resolveEnd = new ResolveEnd(t.id, _this31.serializeUrl(t.extractedUrl), _this31.serializeUrl(t.urlAfterRedirects),\n                /** @type {?} */\n                t.targetSnapshot);\n\n                _this31.triggerEvent(resolveEnd);\n              }));\n            }\n\n            return undefined;\n          }), // --- AFTER PREACTIVATION ---\n          switchTap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            var targetSnapshot = t.targetSnapshot,\n                navigationId = t.id,\n                appliedUrlTree = t.extractedUrl,\n                rawUrlTree = t.rawUrl,\n                _t$extras2 = t.extras,\n                skipLocationChange = _t$extras2.skipLocationChange,\n                replaceUrl = _t$extras2.replaceUrl;\n            return _this31.hooks.afterPreactivation(\n            /** @type {?} */\n            targetSnapshot, {\n              navigationId: navigationId,\n              appliedUrlTree: appliedUrlTree,\n              rawUrlTree: rawUrlTree,\n              skipLocationChange: !!skipLocationChange,\n              replaceUrl: !!replaceUrl\n            });\n          }), map(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            /** @type {?} */\n            var targetRouterState = createRouterState(_this31.routeReuseStrategy,\n            /** @type {?} */\n            t.targetSnapshot, t.currentRouterState);\n            return Object.assign({}, t, {\n              targetRouterState: targetRouterState\n            });\n          }),\n          /* Once here, we are about to activate syncronously. The assumption is this will\n             succeed, and user code may read from the Router service. Therefore before\n             activation, we need to update router properties storing the current URL and the\n             RouterState, as well as updated the browser URL. All this should happen *before*\n             activating. */\n          tap(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          function (t) {\n            _this31.currentUrlTree = t.urlAfterRedirects;\n            _this31.rawUrlTree = _this31.urlHandlingStrategy.merge(_this31.currentUrlTree, t.rawUrl);\n\n            /** @type {?} */\n            _this31.routerState =\n            /** @type {?} */\n            t.targetRouterState;\n\n            if (_this31.urlUpdateStrategy === 'deferred') {\n              if (!t.extras.skipLocationChange) {\n                _this31.setBrowserUrl(_this31.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state);\n              }\n\n              _this31.browserUrlTree = t.urlAfterRedirects;\n            }\n          }), activateRoutes(_this31.rootContexts, _this31.routeReuseStrategy,\n          /**\n          * @param {?} evt\n          * @return {?}\n          */\n          function (evt) {\n            return _this31.triggerEvent(evt);\n          }), tap({\n            /**\n            * @return {?}\n            */\n            next: function next() {\n              completed = true;\n            },\n\n            /**\n            * @return {?}\n            */\n            complete: function complete() {\n              completed = true;\n            }\n          }), finalize(\n          /**\n          * @return {?}\n          */\n          function () {\n            /* When the navigation stream finishes either through error or success, we set the\n             * `completed` or `errored` flag. However, there are some situations where we could\n             * get here without either of those being set. For instance, a redirect during\n             * NavigationStart. Therefore, this is a catch-all to make sure the NavigationCancel\n             * event is fired when a navigation gets cancelled but not caught by other means. */\n            if (!completed && !errored) {\n              // Must reset to current URL tree here to ensure history.state is set. On a fresh\n              // page load, if a new navigation comes in before a successful navigation\n              // completes, there will be nothing in history.state.navigationId. This can cause\n              // sync problems with AngularJS sync code which looks for a value here in order\n              // to determine whether or not to handle a given popstate event or to leave it\n              // to the Angualr router.\n              _this31.resetUrlToCurrentUrlTree();\n              /** @type {?} */\n\n\n              var navCancel = new NavigationCancel(t.id, _this31.serializeUrl(t.extractedUrl), \"Navigation ID \".concat(t.id, \" is not equal to the current navigation id \").concat(_this31.navigationId));\n              eventsSubject.next(navCancel);\n              t.resolve(false);\n            } // currentNavigation should always be reset to null here. If navigation was\n            // successful, lastSuccessfulTransition will have already been set. Therefore we\n            // can safely set currentNavigation to null here.\n\n\n            _this31.currentNavigation = null;\n          }), catchError(\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          function (e) {\n            errored = true;\n            /* This error type is issued during Redirect, and is handled as a cancellation\n             * rather than an error. */\n\n            if (isNavigationCancelingError(e)) {\n              /** @type {?} */\n              var redirecting = isUrlTree(e.url);\n\n              if (!redirecting) {\n                // Set property only if we're not redirecting. If we landed on a page and\n                // redirect to `/` route, the new navigation is going to see the `/` isn't\n                // a change from the default currentUrlTree and won't navigate. This is\n                // only applicable with initial navigation, so setting `navigated` only when\n                // not redirecting resolves this scenario.\n                _this31.navigated = true;\n\n                _this31.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);\n              }\n              /** @type {?} */\n\n\n              var navCancel = new NavigationCancel(t.id, _this31.serializeUrl(t.extractedUrl), e.message);\n              eventsSubject.next(navCancel);\n              t.resolve(false);\n\n              if (redirecting) {\n                _this31.navigateByUrl(e.url);\n              }\n              /* All other errors should reset to the router's internal URL reference to the\n               * pre-error state. */\n\n            } else {\n              _this31.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);\n              /** @type {?} */\n\n\n              var navError = new NavigationError(t.id, _this31.serializeUrl(t.extractedUrl), e);\n              eventsSubject.next(navError);\n\n              try {\n                t.resolve(_this31.errorHandler(e));\n              } catch (ee) {\n                t.reject(ee);\n              }\n            }\n\n            return EMPTY;\n          })); // TODO(jasonaden): remove cast once g3 is on updated TypeScript\n        }))\n      );\n    }\n    /**\n     * \\@internal\n     * TODO: this should be removed once the constructor of the router made internal\n     * @param {?} rootComponentType\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetRootComponentType\",\n    value: function resetRootComponentType(rootComponentType) {\n      this.rootComponentType = rootComponentType; // TODO: vsavkin router 4.0 should make the root component set to null\n      // this will simplify the lifecycle of the router.\n\n      this.routerState.root.component = this.rootComponentType;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"getTransition\",\n    value: function getTransition() {\n      /** @type {?} */\n      var transition = this.transitions.value; // This value needs to be set. Other values such as extractedUrl are set on initial navigation\n      // but the urlAfterRedirects may not get set if we aren't processing the new URL *and* not\n      // processing the previous URL.\n\n      transition.urlAfterRedirects = this.browserUrlTree;\n      return transition;\n    }\n    /**\n     * @private\n     * @param {?} t\n     * @return {?}\n     */\n\n  }, {\n    key: \"setTransition\",\n    value: function setTransition(t) {\n      this.transitions.next(Object.assign({}, this.getTransition(), t));\n    }\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     * @return {?}\n     */\n\n  }, {\n    key: \"initialNavigation\",\n    value: function initialNavigation() {\n      this.setUpLocationChangeListener();\n\n      if (this.navigationId === 0) {\n        this.navigateByUrl(this.location.path(true), {\n          replaceUrl: true\n        });\n      }\n    }\n    /**\n     * Sets up the location change listener.\n     * @return {?}\n     */\n\n  }, {\n    key: \"setUpLocationChangeListener\",\n    value: function setUpLocationChangeListener() {\n      var _this32 = this;\n\n      // Don't need to use Zone.wrap any more, because zone.js\n      // already patch onPopState, so location change callback will\n      // run into ngZone\n      if (!this.locationSubscription) {\n        this.locationSubscription =\n        /** @type {?} */\n        this.location.subscribe(\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        function (change) {\n          /** @type {?} */\n          var rawUrlTree = _this32.parseUrl(change['url']);\n          /** @type {?} */\n\n\n          var source = change['type'] === 'popstate' ? 'popstate' : 'hashchange'; // Navigations coming from Angular router have a navigationId state property. When this\n          // exists, restore the state.\n\n          /** @type {?} */\n\n          var state = change.state && change.state.navigationId ? change.state : null;\n          setTimeout(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this32.scheduleNavigation(rawUrlTree, source, state, {\n              replaceUrl: true\n            });\n          }, 0);\n        });\n      }\n    }\n    /**\n     * The current URL.\n     * @return {?}\n     */\n\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this.serializeUrl(this.currentUrlTree);\n    }\n    /**\n     * The current Navigation object if one exists\n     * @return {?}\n     */\n\n  }, {\n    key: \"getCurrentNavigation\",\n    value: function getCurrentNavigation() {\n      return this.currentNavigation;\n    }\n    /**\n     * \\@internal\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"triggerEvent\",\n    value: function triggerEvent(event) {\n      /** @type {?} */\n      this.events.next(event);\n    }\n    /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * \\@usageNotes\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     * @param {?} config The route array for the new configuration.\n     *\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetConfig\",\n    value: function resetConfig(config) {\n      validateConfig(config);\n      this.config = config.map(standardizeConfig);\n      this.navigated = false;\n      this.lastSuccessfulId = -1;\n    }\n    /**\n     * \\@docsNotRequired\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.dispose();\n    }\n    /**\n     * Disposes of the router.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.locationSubscription) {\n        this.locationSubscription.unsubscribe();\n        this.locationSubscription =\n        /** @type {?} */\n        null;\n      }\n    }\n    /**\n     * Applies an array of commands to the current URL tree and creates a new URL tree.\n     *\n     * When given an activated route, applies the given commands starting from the route.\n     * Otherwise, applies the given command starting from the root.\n     *\n     * \\@usageNotes\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it,\n     * // you can do the following:\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     * @param {?} commands An array of commands to apply.\n     * @param {?=} navigationExtras Options that control the navigation strategy.\n     * @return {?} The new URL tree.\n     *\n     */\n\n  }, {\n    key: \"createUrlTree\",\n    value: function createUrlTree(commands) {\n      var navigationExtras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var relativeTo = navigationExtras.relativeTo,\n          queryParams = navigationExtras.queryParams,\n          fragment = navigationExtras.fragment,\n          preserveQueryParams = navigationExtras.preserveQueryParams,\n          queryParamsHandling = navigationExtras.queryParamsHandling,\n          preserveFragment = navigationExtras.preserveFragment;\n\n      if (isDevMode() && preserveQueryParams &&\n      /** @type {?} */\n      console &&\n      /** @type {?} */\n      console.warn) {\n        console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n      }\n      /** @type {?} */\n\n\n      var a = relativeTo || this.routerState.root;\n      /** @type {?} */\n\n      var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n      /** @type {?} */\n\n      var q = null;\n\n      if (queryParamsHandling) {\n        switch (queryParamsHandling) {\n          case 'merge':\n            q = Object.assign({}, this.currentUrlTree.queryParams, queryParams);\n            break;\n\n          case 'preserve':\n            q = this.currentUrlTree.queryParams;\n            break;\n\n          default:\n            q = queryParams || null;\n        }\n      } else {\n        q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\n      }\n\n      if (q !== null) {\n        q = this.removeEmptyProps(q);\n      }\n\n      return _createUrlTree(a, this.currentUrlTree, commands,\n      /** @type {?} */\n      q,\n      /** @type {?} */\n      f);\n    }\n    /**\n     * Navigate based on the provided URL, which must be absolute.\n     *\n     * \\@usageNotes\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * @param {?} url An absolute URL. The function does not apply any delta to the current URL.\n     * @param {?=} extras An object containing properties that modify the navigation strategy.\n     * The function ignores any properties in the `NavigationExtras` that would change the\n     * provided URL.\n     *\n     * @return {?} A Promise that resolves to 'true' when navigation succeeds,\n     * to 'false' when navigation fails, or is rejected on error.\n     *\n     */\n\n  }, {\n    key: \"navigateByUrl\",\n    value: function navigateByUrl(url) {\n      var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        skipLocationChange: false\n      };\n\n      if (isDevMode() && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {\n        this.console.warn(\"Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?\");\n      }\n      /** @type {?} */\n\n\n      var urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n      /** @type {?} */\n\n      var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n      return this.scheduleNavigation(mergedTree, 'imperative', null, extras);\n    }\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * \\@usageNotes\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * The first parameter of `navigate()` is a delta to be applied to the current URL\n     * or the one provided in the `relativeTo` property of the second parameter (the\n     * `NavigationExtras`).\n     *\n     * In order to affect this browser's `history.state` entry, the `state`\n     * parameter can be passed. This must be an object because the router\n     * will add the `navigationId` property to this object before creating\n     * the new history item.\n     * @param {?} commands\n     * @param {?=} extras\n     * @return {?}\n     */\n\n  }, {\n    key: \"navigate\",\n    value: function navigate(commands) {\n      var extras = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        skipLocationChange: false\n      };\n      validateCommands(commands);\n      return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n    }\n    /**\n     * Serializes a `UrlTree` into a string\n     * @param {?} url\n     * @return {?}\n     */\n\n  }, {\n    key: \"serializeUrl\",\n    value: function serializeUrl(url) {\n      return this.urlSerializer.serialize(url);\n    }\n    /**\n     * Parses a string into a `UrlTree`\n     * @param {?} url\n     * @return {?}\n     */\n\n  }, {\n    key: \"parseUrl\",\n    value: function parseUrl(url) {\n      /** @type {?} */\n      var urlTree;\n\n      try {\n        urlTree = this.urlSerializer.parse(url);\n      } catch (e) {\n        urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);\n      }\n\n      return urlTree;\n    }\n    /**\n     * Returns whether the url is activated\n     * @param {?} url\n     * @param {?} exact\n     * @return {?}\n     */\n\n  }, {\n    key: \"isActive\",\n    value: function isActive(url, exact) {\n      if (isUrlTree(url)) {\n        return containsTree(this.currentUrlTree, url, exact);\n      }\n      /** @type {?} */\n\n\n      var urlTree = this.parseUrl(url);\n      return containsTree(this.currentUrlTree, urlTree, exact);\n    }\n    /**\n     * @private\n     * @param {?} params\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeEmptyProps\",\n    value: function removeEmptyProps(params) {\n      return Object.keys(params).reduce(\n      /**\n      * @param {?} result\n      * @param {?} key\n      * @return {?}\n      */\n      function (result, key) {\n        /** @type {?} */\n        var value = params[key];\n\n        if (value !== null && value !== undefined) {\n          result[key] = value;\n        }\n\n        return result;\n      }, {});\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"processNavigations\",\n    value: function processNavigations() {\n      var _this33 = this;\n\n      this.navigations.subscribe(\n      /**\n      * @param {?} t\n      * @return {?}\n      */\n      function (t) {\n        _this33.navigated = true;\n        _this33.lastSuccessfulId = t.id;\n\n        /** @type {?} */\n        _this33.events.next(new NavigationEnd(t.id, _this33.serializeUrl(t.extractedUrl), _this33.serializeUrl(_this33.currentUrlTree)));\n\n        _this33.lastSuccessfulNavigation = _this33.currentNavigation;\n        _this33.currentNavigation = null;\n        t.resolve(true);\n      },\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      function (e) {\n        _this33.console.warn(\"Unhandled Navigation Error: \");\n      });\n    }\n    /**\n     * @private\n     * @param {?} rawUrl\n     * @param {?} source\n     * @param {?} restoredState\n     * @param {?} extras\n     * @return {?}\n     */\n\n  }, {\n    key: \"scheduleNavigation\",\n    value: function scheduleNavigation(rawUrl, source, restoredState, extras) {\n      /** @type {?} */\n      var lastNavigation = this.getTransition(); // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n      // and that navigation results in 'replaceState' that leads to the same URL,\n      // we should skip those.\n\n      if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n        return Promise.resolve(true); // return value is not used\n      } // Because of a bug in IE and Edge, the location class fires two events (popstate and\n      // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n      // flicker. Handles the case when a popstate was emitted first.\n\n\n      if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n        return Promise.resolve(true); // return value is not used\n      } // Because of a bug in IE and Edge, the location class fires two events (popstate and\n      // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n      // flicker. Handles the case when a hashchange was emitted first.\n\n\n      if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n        return Promise.resolve(true); // return value is not used\n      }\n      /** @type {?} */\n\n\n      var resolve = null;\n      /** @type {?} */\n\n      var reject = null;\n      /** @type {?} */\n\n      var promise = new Promise(\n      /**\n      * @param {?} res\n      * @param {?} rej\n      * @return {?}\n      */\n      function (res, rej) {\n        resolve = res;\n        reject = rej;\n      });\n      /** @type {?} */\n\n      var id = ++this.navigationId;\n      this.setTransition({\n        id: id,\n        source: source,\n        restoredState: restoredState,\n        currentUrlTree: this.currentUrlTree,\n        currentRawUrl: this.rawUrlTree,\n        rawUrl: rawUrl,\n        extras: extras,\n        resolve: resolve,\n        reject: reject,\n        promise: promise,\n        currentSnapshot: this.routerState.snapshot,\n        currentRouterState: this.routerState\n      }); // Make sure that the error is propagated even though `processNavigations` catch\n      // handler does not rethrow\n\n      return promise.catch(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      function (e) {\n        return Promise.reject(e);\n      });\n    }\n    /**\n     * @private\n     * @param {?} url\n     * @param {?} replaceUrl\n     * @param {?} id\n     * @param {?=} state\n     * @return {?}\n     */\n\n  }, {\n    key: \"setBrowserUrl\",\n    value: function setBrowserUrl(url, replaceUrl, id, state) {\n      /** @type {?} */\n      var path = this.urlSerializer.serialize(url);\n      state = state || {};\n\n      if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {\n        // TODO(jasonaden): Remove first `navigationId` and rely on `ng` namespace.\n        this.location.replaceState(path, '', Object.assign({}, state, {\n          navigationId: id\n        }));\n      } else {\n        this.location.go(path, '', Object.assign({}, state, {\n          navigationId: id\n        }));\n      }\n    }\n    /**\n     * @private\n     * @param {?} storedState\n     * @param {?} storedUrl\n     * @param {?} rawUrl\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetStateAndUrl\",\n    value: function resetStateAndUrl(storedState, storedUrl, rawUrl) {\n      /** @type {?} */\n      this.routerState = storedState;\n      this.currentUrlTree = storedUrl;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\n      this.resetUrlToCurrentUrlTree();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetUrlToCurrentUrlTree\",\n    value: function resetUrlToCurrentUrlTree() {\n      this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', {\n        navigationId: this.lastSuccessfulId\n      });\n    }\n  }]);\n\n  return Router;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  Router.prototype.currentUrlTree;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.rawUrlTree;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.browserUrlTree;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.transitions;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.navigations;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.lastSuccessfulNavigation;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.currentNavigation;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.locationSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.navigationId;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.configLoader;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.ngModule;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.console;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.isNgZoneEnabled;\n  /**\n   * An event stream for routing events in this NgModule.\n   * @type {?}\n   */\n\n  Router.prototype.events;\n  /**\n   * The current state of routing in this NgModule.\n   * @type {?}\n   */\n\n  Router.prototype.routerState;\n  /**\n   * A handler for navigation errors in this NgModule.\n   * @type {?}\n   */\n\n  Router.prototype.errorHandler;\n  /**\n   * A handler for errors thrown by `Router.parseUrl(url)`\n   * when `url` contains an invalid character.\n   * The most common case is a `%` sign\n   * that's not encoded and is not part of a percent encoded sequence.\n   * @type {?}\n   */\n\n  Router.prototype.malformedUriErrorHandler;\n  /**\n   * True if at least one navigation event has occurred,\n   * false otherwise.\n   * @type {?}\n   */\n\n  Router.prototype.navigated;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.lastSuccessfulId;\n  /**\n   * Hooks that enable you to pause navigation,\n   * either before or after the preactivation phase.\n   * Used by `RouterModule`.\n   *\n   * \\@internal\n   * @type {?}\n   */\n\n  Router.prototype.hooks;\n  /**\n   * A strategy for extracting and merging URLs.\n   * Used for AngularJS to Angular migrations.\n   * @type {?}\n   */\n\n  Router.prototype.urlHandlingStrategy;\n  /**\n   * A strategy for re-using routes.\n   * @type {?}\n   */\n\n  Router.prototype.routeReuseStrategy;\n  /**\n   * How to handle a navigation request to the current URL. One of:\n   * - `'ignore'` :  The router ignores the request.\n   * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\n   * @type {?}\n   */\n\n  Router.prototype.onSameUrlNavigation;\n  /**\n   * How to merge parameters, data, and resolved data from parent to child\n   * routes. One of:\n   *\n   * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\n   * for path-less or component-less routes.\n   * - `'always'` : Inherit parent parameters, data, and resolved data\n   * for all child routes.\n   * @type {?}\n   */\n\n  Router.prototype.paramsInheritanceStrategy;\n  /**\n   * Determines when the router updates the browser URL.\n   * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\n   * Set to `'eager'` to update the browser URL at the beginning of navigation.\n   * You can choose to update early so that, if navigation fails,\n   * you can show an error message with the URL that failed.\n   * @type {?}\n   */\n\n  Router.prototype.urlUpdateStrategy;\n  /**\n   * Enables a bug fix that corrects relative link resolution in components with empty paths.\n   * @see `RouterModule`\n   * @type {?}\n   */\n\n  Router.prototype.relativeLinkResolution;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.rootComponentType;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.urlSerializer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.rootContexts;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Router.prototype.location;\n  /** @type {?} */\n\n  Router.prototype.config;\n}\n/**\n * @param {?} commands\n * @return {?}\n */\n\n\nfunction validateCommands(commands) {\n  for (var i = 0; i < commands.length; i++) {\n    /** @type {?} */\n    var cmd = commands[i];\n\n    if (cmd == null) {\n      throw new Error(\"The requested path contains \".concat(cmd, \" segment at index \").concat(i));\n    }\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Lets you link to specific routes in your app.\n *\n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`.\n * When linking to this `user/:name` route, you use the `RouterLink` directive.\n *\n * If the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n *\n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n *\n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n *\n * You can set query params and fragment as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n *\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n *\n * You can tell the directive how to handle queryParams. Available options are:\n *  - `'merge'`: merge the queryParams into the current queryParams\n *  - `'preserve'`: preserve the current queryParams\n *  - default/`''`: use the queryParams only\n *\n * Same options for {\\@link NavigationExtras#queryParamsHandling\n * NavigationExtras#queryParamsHandling}.\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * You can provide a `state` value to be persisted to the browser's History.state\n * property (See https://developer.mozilla.org/en-US/docs/Web/API/History#Properties). It's\n * used as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * And later the value can be read from the router through `router.getCurrentNavigation`.\n * For example, to capture the `tracingId` above during the `NavigationStart` event:\n *\n * ```\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * The router link directive always treats the provided input as a delta to the current url.\n *\n * For instance, if the current url is `/user/(box//aux:team)`.\n *\n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n *\n * See {\\@link Router#createUrlTree createUrlTree} for more information.\n *\n * \\@ngModule RouterModule\n *\n * \\@publicApi\n */\n\n\nvar RouterLink = /*#__PURE__*/function () {\n  /**\n   * @param {?} router\n   * @param {?} route\n   * @param {?} tabIndex\n   * @param {?} renderer\n   * @param {?} el\n   */\n  function RouterLink(router, route, tabIndex, renderer, el) {\n    _classCallCheck(this, RouterLink);\n\n    this.router = router;\n    this.route = route;\n    this.commands = [];\n\n    if (tabIndex == null) {\n      renderer.setAttribute(el.nativeElement, 'tabindex', '0');\n    }\n  }\n  /**\n   * @param {?} commands\n   * @return {?}\n   */\n\n\n  _createClass(RouterLink, [{\n    key: \"routerLink\",\n    set: function set(commands) {\n      if (commands != null) {\n        this.commands = Array.isArray(commands) ? commands : [commands];\n      } else {\n        this.commands = [];\n      }\n    }\n    /**\n     * @deprecated 4.0.0 use `queryParamsHandling` instead.\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"preserveQueryParams\",\n    set: function set(value) {\n      if (isDevMode() &&\n      /** @type {?} */\n      console &&\n      /** @type {?} */\n      console.warn) {\n        console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');\n      }\n\n      this.preserve = value;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"onClick\",\n    value: function onClick() {\n      /** @type {?} */\n      var extras = {\n        skipLocationChange: attrBoolValue(this.skipLocationChange),\n        replaceUrl: attrBoolValue(this.replaceUrl)\n      };\n      this.router.navigateByUrl(this.urlTree, extras);\n      return true;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"urlTree\",\n    get: function get() {\n      return this.router.createUrlTree(this.commands, {\n        relativeTo: this.route,\n        queryParams: this.queryParams,\n        fragment: this.fragment,\n        preserveQueryParams: attrBoolValue(this.preserve),\n        queryParamsHandling: this.queryParamsHandling,\n        preserveFragment: attrBoolValue(this.preserveFragment)\n      });\n    }\n  }]);\n\n  return RouterLink;\n}();\n\nRouterLink.decorators = [{\n  type: Directive,\n  args: [{\n    selector: ':not(a):not(area)[routerLink]'\n  }]\n}];\n/** @nocollapse */\n\nRouterLink.ctorParameters = function () {\n  return [{\n    type: Router\n  }, {\n    type: ActivatedRoute\n  }, {\n    type: String,\n    decorators: [{\n      type: Attribute,\n      args: ['tabindex']\n    }]\n  }, {\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }];\n};\n\nRouterLink.propDecorators = {\n  queryParams: [{\n    type: Input\n  }],\n  fragment: [{\n    type: Input\n  }],\n  queryParamsHandling: [{\n    type: Input\n  }],\n  preserveFragment: [{\n    type: Input\n  }],\n  skipLocationChange: [{\n    type: Input\n  }],\n  replaceUrl: [{\n    type: Input\n  }],\n  state: [{\n    type: Input\n  }],\n  routerLink: [{\n    type: Input\n  }],\n  preserveQueryParams: [{\n    type: Input\n  }],\n  onClick: [{\n    type: HostListener,\n    args: ['click']\n  }]\n};\n\nif (false) {\n  /** @type {?} */\n  RouterLink.prototype.queryParams;\n  /** @type {?} */\n\n  RouterLink.prototype.fragment;\n  /** @type {?} */\n\n  RouterLink.prototype.queryParamsHandling;\n  /** @type {?} */\n\n  RouterLink.prototype.preserveFragment;\n  /** @type {?} */\n\n  RouterLink.prototype.skipLocationChange;\n  /** @type {?} */\n\n  RouterLink.prototype.replaceUrl;\n  /** @type {?} */\n\n  RouterLink.prototype.state;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLink.prototype.commands;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLink.prototype.preserve;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLink.prototype.router;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLink.prototype.route;\n}\n/**\n * \\@description\n *\n * Lets you link to specific routes in your app.\n *\n * See `RouterLink` for more information.\n *\n * \\@ngModule RouterModule\n *\n * \\@publicApi\n */\n\n\nvar RouterLinkWithHref = /*#__PURE__*/function () {\n  /**\n   * @param {?} router\n   * @param {?} route\n   * @param {?} locationStrategy\n   */\n  function RouterLinkWithHref(router, route, locationStrategy) {\n    var _this34 = this;\n\n    _classCallCheck(this, RouterLinkWithHref);\n\n    this.router = router;\n    this.route = route;\n    this.locationStrategy = locationStrategy;\n    this.commands = [];\n    this.subscription = router.events.subscribe(\n    /**\n    * @param {?} s\n    * @return {?}\n    */\n    function (s) {\n      if (s instanceof NavigationEnd) {\n        _this34.updateTargetUrlAndHref();\n      }\n    });\n  }\n  /**\n   * @param {?} commands\n   * @return {?}\n   */\n\n\n  _createClass(RouterLinkWithHref, [{\n    key: \"routerLink\",\n    set: function set(commands) {\n      if (commands != null) {\n        this.commands = Array.isArray(commands) ? commands : [commands];\n      } else {\n        this.commands = [];\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"preserveQueryParams\",\n    set: function set(value) {\n      if (isDevMode() &&\n      /** @type {?} */\n      console &&\n      /** @type {?} */\n      console.warn) {\n        console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n      }\n\n      this.preserve = value;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      this.updateTargetUrlAndHref();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n    /**\n     * @param {?} button\n     * @param {?} ctrlKey\n     * @param {?} metaKey\n     * @param {?} shiftKey\n     * @return {?}\n     */\n\n  }, {\n    key: \"onClick\",\n    value: function onClick(button, ctrlKey, metaKey, shiftKey) {\n      if (button !== 0 || ctrlKey || metaKey || shiftKey) {\n        return true;\n      }\n\n      if (typeof this.target === 'string' && this.target != '_self') {\n        return true;\n      }\n      /** @type {?} */\n\n\n      var extras = {\n        skipLocationChange: attrBoolValue(this.skipLocationChange),\n        replaceUrl: attrBoolValue(this.replaceUrl),\n        state: this.state\n      };\n      this.router.navigateByUrl(this.urlTree, extras);\n      return false;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateTargetUrlAndHref\",\n    value: function updateTargetUrlAndHref() {\n      this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"urlTree\",\n    get: function get() {\n      return this.router.createUrlTree(this.commands, {\n        relativeTo: this.route,\n        queryParams: this.queryParams,\n        fragment: this.fragment,\n        preserveQueryParams: attrBoolValue(this.preserve),\n        queryParamsHandling: this.queryParamsHandling,\n        preserveFragment: attrBoolValue(this.preserveFragment)\n      });\n    }\n  }]);\n\n  return RouterLinkWithHref;\n}();\n\nRouterLinkWithHref.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'a[routerLink],area[routerLink]'\n  }]\n}];\n/** @nocollapse */\n\nRouterLinkWithHref.ctorParameters = function () {\n  return [{\n    type: Router\n  }, {\n    type: ActivatedRoute\n  }, {\n    type: LocationStrategy\n  }];\n};\n\nRouterLinkWithHref.propDecorators = {\n  target: [{\n    type: HostBinding,\n    args: ['attr.target']\n  }, {\n    type: Input\n  }],\n  queryParams: [{\n    type: Input\n  }],\n  fragment: [{\n    type: Input\n  }],\n  queryParamsHandling: [{\n    type: Input\n  }],\n  preserveFragment: [{\n    type: Input\n  }],\n  skipLocationChange: [{\n    type: Input\n  }],\n  replaceUrl: [{\n    type: Input\n  }],\n  state: [{\n    type: Input\n  }],\n  href: [{\n    type: HostBinding\n  }],\n  routerLink: [{\n    type: Input\n  }],\n  preserveQueryParams: [{\n    type: Input\n  }],\n  onClick: [{\n    type: HostListener,\n    args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']]\n  }]\n};\n\nif (false) {\n  /** @type {?} */\n  RouterLinkWithHref.prototype.target;\n  /** @type {?} */\n\n  RouterLinkWithHref.prototype.queryParams;\n  /** @type {?} */\n\n  RouterLinkWithHref.prototype.fragment;\n  /** @type {?} */\n\n  RouterLinkWithHref.prototype.queryParamsHandling;\n  /** @type {?} */\n\n  RouterLinkWithHref.prototype.preserveFragment;\n  /** @type {?} */\n\n  RouterLinkWithHref.prototype.skipLocationChange;\n  /** @type {?} */\n\n  RouterLinkWithHref.prototype.replaceUrl;\n  /** @type {?} */\n\n  RouterLinkWithHref.prototype.state;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkWithHref.prototype.commands;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkWithHref.prototype.subscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkWithHref.prototype.preserve;\n  /** @type {?} */\n\n  RouterLinkWithHref.prototype.href;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkWithHref.prototype.router;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkWithHref.prototype.route;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkWithHref.prototype.locationStrategy;\n}\n/**\n * @param {?} s\n * @return {?}\n */\n\n\nfunction attrBoolValue(s) {\n  return s === '' || !!s;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n *\n * \\@description\n *\n * Lets you add a CSS class to an element when the link's route becomes active.\n *\n * This directive lets you add a CSS class to an element when the link's route\n * becomes active.\n *\n * Consider the following example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n *\n * You can set more than one class, as follows:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n *\n * \\@ngModule RouterModule\n *\n * \\@publicApi\n */\n\n\nvar RouterLinkActive = /*#__PURE__*/function () {\n  /**\n   * @param {?} router\n   * @param {?} element\n   * @param {?} renderer\n   * @param {?=} link\n   * @param {?=} linkWithHref\n   */\n  function RouterLinkActive(router, element, renderer, link, linkWithHref) {\n    var _this35 = this;\n\n    _classCallCheck(this, RouterLinkActive);\n\n    this.router = router;\n    this.element = element;\n    this.renderer = renderer;\n    this.link = link;\n    this.linkWithHref = linkWithHref;\n    this.classes = [];\n    this.isActive = false;\n    this.routerLinkActiveOptions = {\n      exact: false\n    };\n    this.subscription = router.events.subscribe(\n    /**\n    * @param {?} s\n    * @return {?}\n    */\n    function (s) {\n      if (s instanceof NavigationEnd) {\n        _this35.update();\n      }\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterLinkActive, [{\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      var _this36 = this;\n\n      this.links.changes.subscribe(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      function (_) {\n        return _this36.update();\n      });\n      this.linksWithHrefs.changes.subscribe(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      function (_) {\n        return _this36.update();\n      });\n      this.update();\n    }\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n\n  }, {\n    key: \"routerLinkActive\",\n    set: function set(data) {\n      /** @type {?} */\n      var classes = Array.isArray(data) ? data : data.split(' ');\n      this.classes = classes.filter(\n      /**\n      * @param {?} c\n      * @return {?}\n      */\n      function (c) {\n        return !!c;\n      });\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      this.update();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this37 = this;\n\n      if (!this.links || !this.linksWithHrefs || !this.router.navigated) return;\n      Promise.resolve().then(\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        var hasActiveLinks = _this37.hasActiveLinks();\n\n        if (_this37.isActive !== hasActiveLinks) {\n          /** @type {?} */\n          _this37.isActive = hasActiveLinks;\n\n          _this37.classes.forEach(\n          /**\n          * @param {?} c\n          * @return {?}\n          */\n          function (c) {\n            if (hasActiveLinks) {\n              _this37.renderer.addClass(_this37.element.nativeElement, c);\n            } else {\n              _this37.renderer.removeClass(_this37.element.nativeElement, c);\n            }\n          });\n        }\n      });\n    }\n    /**\n     * @private\n     * @param {?} router\n     * @return {?}\n     */\n\n  }, {\n    key: \"isLinkActive\",\n    value: function isLinkActive(router) {\n      var _this38 = this;\n\n      return (\n        /**\n        * @param {?} link\n        * @return {?}\n        */\n        function (link) {\n          return router.isActive(link.urlTree, _this38.routerLinkActiveOptions.exact);\n        }\n      );\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"hasActiveLinks\",\n    value: function hasActiveLinks() {\n      /** @type {?} */\n      var isActiveCheckFn = this.isLinkActive(this.router);\n      return this.link && isActiveCheckFn(this.link) || this.linkWithHref && isActiveCheckFn(this.linkWithHref) || this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);\n    }\n  }]);\n\n  return RouterLinkActive;\n}();\n\nRouterLinkActive.decorators = [{\n  type: Directive,\n  args: [{\n    selector: '[routerLinkActive]',\n    exportAs: 'routerLinkActive'\n  }]\n}];\n/** @nocollapse */\n\nRouterLinkActive.ctorParameters = function () {\n  return [{\n    type: Router\n  }, {\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: RouterLink,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: RouterLinkWithHref,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n\nRouterLinkActive.propDecorators = {\n  links: [{\n    type: ContentChildren,\n    args: [RouterLink, {\n      descendants: true\n    }]\n  }],\n  linksWithHrefs: [{\n    type: ContentChildren,\n    args: [RouterLinkWithHref, {\n      descendants: true\n    }]\n  }],\n  routerLinkActiveOptions: [{\n    type: Input\n  }],\n  routerLinkActive: [{\n    type: Input\n  }]\n};\n\nif (false) {\n  /** @type {?} */\n  RouterLinkActive.prototype.links;\n  /** @type {?} */\n\n  RouterLinkActive.prototype.linksWithHrefs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkActive.prototype.classes;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkActive.prototype.subscription;\n  /** @type {?} */\n\n  RouterLinkActive.prototype.isActive;\n  /** @type {?} */\n\n  RouterLinkActive.prototype.routerLinkActiveOptions;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkActive.prototype.router;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkActive.prototype.element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkActive.prototype.renderer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkActive.prototype.link;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterLinkActive.prototype.linkWithHref;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * \\@publicApi\n */\n\n\nvar OutletContext = function OutletContext() {\n  _classCallCheck(this, OutletContext);\n\n  this.outlet = null;\n  this.route = null;\n  this.resolver = null;\n  this.children = new ChildrenOutletContexts();\n  this.attachRef = null;\n};\n\nif (false) {\n  /** @type {?} */\n  OutletContext.prototype.outlet;\n  /** @type {?} */\n\n  OutletContext.prototype.route;\n  /** @type {?} */\n\n  OutletContext.prototype.resolver;\n  /** @type {?} */\n\n  OutletContext.prototype.children;\n  /** @type {?} */\n\n  OutletContext.prototype.attachRef;\n}\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * \\@publicApi\n */\n\n\nvar ChildrenOutletContexts = /*#__PURE__*/function () {\n  function ChildrenOutletContexts() {\n    _classCallCheck(this, ChildrenOutletContexts);\n\n    // contexts for child outlets, by name.\n    this.contexts = new Map();\n  }\n  /**\n   * Called when a `RouterOutlet` directive is instantiated\n   * @param {?} childName\n   * @param {?} outlet\n   * @return {?}\n   */\n\n\n  _createClass(ChildrenOutletContexts, [{\n    key: \"onChildOutletCreated\",\n    value: function onChildOutletCreated(childName, outlet) {\n      /** @type {?} */\n      var context = this.getOrCreateContext(childName);\n      context.outlet = outlet;\n      this.contexts.set(childName, context);\n    }\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"onChildOutletDestroyed\",\n    value: function onChildOutletDestroyed(childName) {\n      /** @type {?} */\n      var context = this.getContext(childName);\n\n      if (context) {\n        context.outlet = null;\n      }\n    }\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     * @return {?}\n     */\n\n  }, {\n    key: \"onOutletDeactivated\",\n    value: function onOutletDeactivated() {\n      /** @type {?} */\n      var contexts = this.contexts;\n      this.contexts = new Map();\n      return contexts;\n    }\n    /**\n     * @param {?} contexts\n     * @return {?}\n     */\n\n  }, {\n    key: \"onOutletReAttached\",\n    value: function onOutletReAttached(contexts) {\n      this.contexts = contexts;\n    }\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"getOrCreateContext\",\n    value: function getOrCreateContext(childName) {\n      /** @type {?} */\n      var context = this.getContext(childName);\n\n      if (!context) {\n        context = new OutletContext();\n        this.contexts.set(childName, context);\n      }\n\n      return context;\n    }\n    /**\n     * @param {?} childName\n     * @return {?}\n     */\n\n  }, {\n    key: \"getContext\",\n    value: function getContext(childName) {\n      return this.contexts.get(childName) || null;\n    }\n  }]);\n\n  return ChildrenOutletContexts;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ChildrenOutletContexts.prototype.contexts;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * and a deactivate event when a component is destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * \\@ngModule RouterModule\n *\n * \\@publicApi\n */\n\n\nvar RouterOutlet = /*#__PURE__*/function () {\n  /**\n   * @param {?} parentContexts\n   * @param {?} location\n   * @param {?} resolver\n   * @param {?} name\n   * @param {?} changeDetector\n   */\n  function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {\n    _classCallCheck(this, RouterOutlet);\n\n    this.parentContexts = parentContexts;\n    this.location = location;\n    this.resolver = resolver;\n    this.changeDetector = changeDetector;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.activateEvents = new EventEmitter();\n    this.deactivateEvents = new EventEmitter();\n    this.name = name || PRIMARY_OUTLET;\n    parentContexts.onChildOutletCreated(this.name, this);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterOutlet, [{\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      if (!this.activated) {\n        // If the outlet was not instantiated at the time the route got activated we need to populate\n        // the outlet when it is initialized (ie inside a NgIf)\n\n        /** @type {?} */\n        var context = this.parentContexts.getContext(this.name);\n\n        if (context && context.route) {\n          if (context.attachRef) {\n            // `attachRef` is populated when there is an existing component to mount\n            this.attach(context.attachRef, context.route);\n          } else {\n            // otherwise the component defined in the configuration is created\n            this.activateWith(context.route, context.resolver || null);\n          }\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isActivated\",\n    get: function get() {\n      return !!this.activated;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"component\",\n    get: function get() {\n      if (!this.activated) throw new Error('Outlet is not activated');\n      return this.activated.instance;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"activatedRoute\",\n    get: function get() {\n      if (!this.activated) throw new Error('Outlet is not activated');\n      return (\n        /** @type {?} */\n        this._activatedRoute\n      );\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"activatedRouteData\",\n    get: function get() {\n      if (this._activatedRoute) {\n        return this._activatedRoute.snapshot.data;\n      }\n\n      return {};\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (!this.activated) throw new Error('Outlet is not activated');\n      this.location.detach();\n      /** @type {?} */\n\n      var cmp = this.activated;\n      this.activated = null;\n      this._activatedRoute = null;\n      return cmp;\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     * @param {?} ref\n     * @param {?} activatedRoute\n     * @return {?}\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(ref, activatedRoute) {\n      this.activated = ref;\n      this._activatedRoute = activatedRoute;\n      this.location.insert(ref.hostView);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      if (this.activated) {\n        /** @type {?} */\n        var c = this.component;\n        this.activated.destroy();\n        this.activated = null;\n        this._activatedRoute = null;\n        this.deactivateEvents.emit(c);\n      }\n    }\n    /**\n     * @param {?} activatedRoute\n     * @param {?} resolver\n     * @return {?}\n     */\n\n  }, {\n    key: \"activateWith\",\n    value: function activateWith(activatedRoute, resolver) {\n      if (this.isActivated) {\n        throw new Error('Cannot activate an already activated outlet');\n      }\n\n      this._activatedRoute = activatedRoute;\n      /** @type {?} */\n\n      var snapshot = activatedRoute._futureSnapshot;\n      /** @type {?} */\n\n      var component =\n      /** @type {?} */\n\n      /** @type {?} */\n      snapshot.routeConfig.component;\n      resolver = resolver || this.resolver;\n      /** @type {?} */\n\n      var factory = resolver.resolveComponentFactory(component);\n      /** @type {?} */\n\n      var childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n      /** @type {?} */\n\n      var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\n      this.activated = this.location.createComponent(factory, this.location.length, injector); // Calling `markForCheck` to make sure we will run the change detection when the\n      // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n\n      this.changeDetector.markForCheck();\n      this.activateEvents.emit(this.activated.instance);\n    }\n  }]);\n\n  return RouterOutlet;\n}();\n\nRouterOutlet.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'router-outlet',\n    exportAs: 'outlet'\n  }]\n}];\n/** @nocollapse */\n\nRouterOutlet.ctorParameters = function () {\n  return [{\n    type: ChildrenOutletContexts\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: ComponentFactoryResolver\n  }, {\n    type: String,\n    decorators: [{\n      type: Attribute,\n      args: ['name']\n    }]\n  }, {\n    type: ChangeDetectorRef\n  }];\n};\n\nRouterOutlet.propDecorators = {\n  activateEvents: [{\n    type: Output,\n    args: ['activate']\n  }],\n  deactivateEvents: [{\n    type: Output,\n    args: ['deactivate']\n  }]\n};\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  RouterOutlet.prototype.activated;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterOutlet.prototype._activatedRoute;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterOutlet.prototype.name;\n  /** @type {?} */\n\n  RouterOutlet.prototype.activateEvents;\n  /** @type {?} */\n\n  RouterOutlet.prototype.deactivateEvents;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterOutlet.prototype.parentContexts;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterOutlet.prototype.location;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterOutlet.prototype.resolver;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterOutlet.prototype.changeDetector;\n}\n\nvar OutletInjector = /*#__PURE__*/function () {\n  /**\n   * @param {?} route\n   * @param {?} childContexts\n   * @param {?} parent\n   */\n  function OutletInjector(route, childContexts, parent) {\n    _classCallCheck(this, OutletInjector);\n\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n  /**\n   * @param {?} token\n   * @param {?=} notFoundValue\n   * @return {?}\n   */\n\n\n  _createClass(OutletInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      if (token === ActivatedRoute) {\n        return this.route;\n      }\n\n      if (token === ChildrenOutletContexts) {\n        return this.childContexts;\n      }\n\n      return this.parent.get(token, notFoundValue);\n    }\n  }]);\n\n  return OutletInjector;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  OutletInjector.prototype.route;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  OutletInjector.prototype.childContexts;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  OutletInjector.prototype.parent;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@description\n *\n * Provides a preloading strategy.\n *\n * \\@publicApi\n * @abstract\n */\n\n\nvar PreloadingStrategy = function PreloadingStrategy() {\n  _classCallCheck(this, PreloadingStrategy);\n};\n\nif (false) {\n  /**\n   * @abstract\n   * @param {?} route\n   * @param {?} fn\n   * @return {?}\n   */\n  PreloadingStrategy.prototype.preload = function (route, fn) {};\n}\n/**\n * \\@description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * \\@publicApi\n */\n\n\nvar PreloadAllModules = /*#__PURE__*/function () {\n  function PreloadAllModules() {\n    _classCallCheck(this, PreloadAllModules);\n  }\n\n  _createClass(PreloadAllModules, [{\n    key: \"preload\",\n    value:\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function preload(route, fn) {\n      return fn().pipe(catchError(\n      /**\n      * @return {?}\n      */\n      function () {\n        return of(null);\n      }));\n    }\n  }]);\n\n  return PreloadAllModules;\n}();\n/**\n * \\@description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * \\@publicApi\n */\n\n\nvar NoPreloading = /*#__PURE__*/function () {\n  function NoPreloading() {\n    _classCallCheck(this, NoPreloading);\n  }\n\n  _createClass(NoPreloading, [{\n    key: \"preload\",\n    value:\n    /**\n     * @param {?} route\n     * @param {?} fn\n     * @return {?}\n     */\n    function preload(route, fn) {\n      return of(null);\n    }\n  }]);\n\n  return NoPreloading;\n}();\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * \\@publicApi\n */\n\n\nvar RouterPreloader = /*#__PURE__*/function () {\n  /**\n   * @param {?} router\n   * @param {?} moduleLoader\n   * @param {?} compiler\n   * @param {?} injector\n   * @param {?} preloadingStrategy\n   */\n  function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\n    _classCallCheck(this, RouterPreloader);\n\n    this.router = router;\n    this.injector = injector;\n    this.preloadingStrategy = preloadingStrategy;\n    /** @type {?} */\n\n    var onStartLoad =\n    /**\n    * @param {?} r\n    * @return {?}\n    */\n    function onStartLoad(r) {\n      return router.triggerEvent(new RouteConfigLoadStart(r));\n    };\n    /** @type {?} */\n\n\n    var onEndLoad =\n    /**\n    * @param {?} r\n    * @return {?}\n    */\n    function onEndLoad(r) {\n      return router.triggerEvent(new RouteConfigLoadEnd(r));\n    };\n\n    this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterPreloader, [{\n    key: \"setUpPreloading\",\n    value: function setUpPreloading() {\n      var _this39 = this;\n\n      this.subscription = this.router.events.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      function (e) {\n        return e instanceof NavigationEnd;\n      }), concatMap(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this39.preload();\n      })).subscribe(\n      /**\n      * @return {?}\n      */\n      function () {});\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      /** @type {?} */\n      var ngModule = this.injector.get(NgModuleRef);\n      return this.processRoutes(ngModule, this.router.config);\n    } // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If\n    // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This\n    // should be refactored.\n\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} routes\n     * @return {?}\n     */\n\n  }, {\n    key: \"processRoutes\",\n    value: function processRoutes(ngModule, routes) {\n      /** @type {?} */\n      var res = [];\n\n      var _iterator10 = _createForOfIteratorHelper(routes),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var route = _step10.value;\n\n          // we already have the config loaded, just recurse\n          if (route.loadChildren && !route.canLoad && route._loadedConfig) {\n            /** @type {?} */\n            var childConfig = route._loadedConfig;\n            res.push(this.processRoutes(childConfig.module, childConfig.routes)); // no config loaded, fetch the config\n          } else if (route.loadChildren && !route.canLoad) {\n            res.push(this.preloadConfig(ngModule, route)); // recurse into children\n          } else if (route.children) {\n            res.push(this.processRoutes(ngModule, route.children));\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return from(res).pipe(mergeAll(), map(\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      function (_) {\n        return void 0;\n      }));\n    }\n    /**\n     * @private\n     * @param {?} ngModule\n     * @param {?} route\n     * @return {?}\n     */\n\n  }, {\n    key: \"preloadConfig\",\n    value: function preloadConfig(ngModule, route) {\n      var _this40 = this;\n\n      return this.preloadingStrategy.preload(route,\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        var loaded$ = _this40.loader.load(ngModule.injector, route);\n\n        return loaded$.pipe(mergeMap(\n        /**\n        * @param {?} config\n        * @return {?}\n        */\n        function (config) {\n          route._loadedConfig = config;\n          return _this40.processRoutes(config.module, config.routes);\n        }));\n      });\n    }\n  }]);\n\n  return RouterPreloader;\n}();\n\nRouterPreloader.decorators = [{\n  type: Injectable\n}];\n/** @nocollapse */\n\nRouterPreloader.ctorParameters = function () {\n  return [{\n    type: Router\n  }, {\n    type: NgModuleFactoryLoader\n  }, {\n    type: Compiler\n  }, {\n    type: Injector\n  }, {\n    type: PreloadingStrategy\n  }];\n};\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  RouterPreloader.prototype.loader;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterPreloader.prototype.subscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterPreloader.prototype.router;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterPreloader.prototype.injector;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterPreloader.prototype.preloadingStrategy;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar RouterScroller = /*#__PURE__*/function () {\n  /**\n   * @param {?} router\n   * @param {?} viewportScroller\n   * @param {?=} options\n   */\n  function RouterScroller(router, viewportScroller) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, RouterScroller);\n\n    this.router = router;\n    this.viewportScroller = viewportScroller;\n    this.options = options;\n    this.lastId = 0;\n    this.lastSource = 'imperative';\n    this.restoredId = 0;\n    this.store = {}; // Default both options to 'disabled'\n\n    options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';\n    options.anchorScrolling = options.anchorScrolling || 'disabled';\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterScroller, [{\n    key: \"init\",\n    value: function init() {\n      // we want to disable the automatic scrolling because having two places\n      // responsible for scrolling results race conditions, especially given\n      // that browser don't implement this behavior consistently\n      if (this.options.scrollPositionRestoration !== 'disabled') {\n        this.viewportScroller.setHistoryScrollRestoration('manual');\n      }\n\n      this.routerEventsSubscription = this.createScrollEvents();\n      this.scrollEventsSubscription = this.consumeScrollEvents();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"createScrollEvents\",\n    value: function createScrollEvents() {\n      var _this41 = this;\n\n      return this.router.events.subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      function (e) {\n        if (e instanceof NavigationStart) {\n          // store the scroll position of the current stable navigations.\n          _this41.store[_this41.lastId] = _this41.viewportScroller.getScrollPosition();\n          _this41.lastSource = e.navigationTrigger;\n          _this41.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n        } else if (e instanceof NavigationEnd) {\n          _this41.lastId = e.id;\n\n          _this41.scheduleScrollEvent(e, _this41.router.parseUrl(e.urlAfterRedirects).fragment);\n        }\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"consumeScrollEvents\",\n    value: function consumeScrollEvents() {\n      var _this42 = this;\n\n      return this.router.events.subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      function (e) {\n        if (!(e instanceof Scroll)) return; // a popstate event. The pop state event will always ignore anchor scrolling.\n\n        if (e.position) {\n          if (_this42.options.scrollPositionRestoration === 'top') {\n            _this42.viewportScroller.scrollToPosition([0, 0]);\n          } else if (_this42.options.scrollPositionRestoration === 'enabled') {\n            _this42.viewportScroller.scrollToPosition(e.position);\n          } // imperative navigation \"forward\"\n\n        } else {\n          if (e.anchor && _this42.options.anchorScrolling === 'enabled') {\n            _this42.viewportScroller.scrollToAnchor(e.anchor);\n          } else if (_this42.options.scrollPositionRestoration !== 'disabled') {\n            _this42.viewportScroller.scrollToPosition([0, 0]);\n          }\n        }\n      });\n    }\n    /**\n     * @private\n     * @param {?} routerEvent\n     * @param {?} anchor\n     * @return {?}\n     */\n\n  }, {\n    key: \"scheduleScrollEvent\",\n    value: function scheduleScrollEvent(routerEvent, anchor) {\n      this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this.routerEventsSubscription) {\n        this.routerEventsSubscription.unsubscribe();\n      }\n\n      if (this.scrollEventsSubscription) {\n        this.scrollEventsSubscription.unsubscribe();\n      }\n    }\n  }]);\n\n  return RouterScroller;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  RouterScroller.prototype.routerEventsSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterScroller.prototype.scrollEventsSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterScroller.prototype.lastId;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterScroller.prototype.lastSource;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterScroller.prototype.restoredId;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterScroller.prototype.store;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterScroller.prototype.router;\n  /**\n   * \\@docsNotRequired\n   * @type {?}\n   */\n\n  RouterScroller.prototype.viewportScroller;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterScroller.prototype.options;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The directives defined in the `RouterModule`.\n * @type {?}\n */\n\n\nvar ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent];\n/**\n * A [DI token](guide/glossary/#di-token) for the router service.\n *\n * \\@publicApi\n * @type {?}\n */\n\nvar ROUTER_CONFIGURATION = new InjectionToken('ROUTER_CONFIGURATION');\n/**\n * \\@docsNotRequired\n * @type {?}\n */\n\nvar ROUTER_FORROOT_GUARD = new InjectionToken('ROUTER_FORROOT_GUARD');\nvar ɵ0 = {\n  enableTracing: false\n};\n/** @type {?} */\n\nvar ROUTER_PROVIDERS = [Location, {\n  provide: UrlSerializer,\n  useClass: DefaultUrlSerializer\n}, {\n  provide: Router,\n  useFactory: setupRouter,\n  deps: [ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector, NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new Optional()], [RouteReuseStrategy, new Optional()]]\n}, ChildrenOutletContexts, {\n  provide: ActivatedRoute,\n  useFactory: rootRoute,\n  deps: [Router]\n}, {\n  provide: NgModuleFactoryLoader,\n  useClass: SystemJsNgModuleLoader\n}, RouterPreloader, NoPreloading, PreloadAllModules, {\n  provide: ROUTER_CONFIGURATION,\n  useValue: ɵ0\n}];\n/**\n * @return {?}\n */\n\nfunction routerNgProbeToken() {\n  return new NgProbeToken('Router', Router);\n}\n/**\n * \\@usageNotes\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@description\n *\n * Adds router directives and providers.\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router service solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * @see [Routing and Navigation](guide/router.html) for an\n * overview of how the router service should be used.\n *\n * \\@publicApi\n */\n\n\nvar RouterModule = /*#__PURE__*/function () {\n  // Note: We are injecting the Router so it gets created eagerly...\n\n  /**\n   * @param {?} guard\n   * @param {?} router\n   */\n  function RouterModule(guard, router) {\n    _classCallCheck(this, RouterModule);\n  }\n  /**\n   * Creates and configures a module with all the router providers and directives.\n   * Optionally sets up an application listener to perform an initial navigation.\n   *\n   * @param {?} routes An array of `Route` objects that define the navigation paths for the application.\n   * @param {?=} config An `ExtraOptions` configuration object that controls how navigation is performed.\n   * @return {?} The new router module.\n   */\n\n\n  _createClass(RouterModule, null, [{\n    key: \"forRoot\",\n    value: function forRoot(routes, config) {\n      return {\n        ngModule: RouterModule,\n        providers: [ROUTER_PROVIDERS, provideRoutes(routes), {\n          provide: ROUTER_FORROOT_GUARD,\n          useFactory: provideForRootGuard,\n          deps: [[Router, new Optional(), new SkipSelf()]]\n        }, {\n          provide: ROUTER_CONFIGURATION,\n          useValue: config ? config : {}\n        }, {\n          provide: LocationStrategy,\n          useFactory: provideLocationStrategy,\n          deps: [PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION]\n        }, {\n          provide: RouterScroller,\n          useFactory: createRouterScroller,\n          deps: [Router, ViewportScroller, ROUTER_CONFIGURATION]\n        }, {\n          provide: PreloadingStrategy,\n          useExisting: config && config.preloadingStrategy ? config.preloadingStrategy : NoPreloading\n        }, {\n          provide: NgProbeToken,\n          multi: true,\n          useFactory: routerNgProbeToken\n        }, provideRouterInitializer()]\n      };\n    }\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     * @param {?} routes\n     * @return {?}\n     */\n\n  }, {\n    key: \"forChild\",\n    value: function forChild(routes) {\n      return {\n        ngModule: RouterModule,\n        providers: [provideRoutes(routes)]\n      };\n    }\n  }]);\n\n  return RouterModule;\n}();\n\nRouterModule.decorators = [{\n  type: NgModule,\n  args: [{\n    declarations: ROUTER_DIRECTIVES,\n    exports: ROUTER_DIRECTIVES,\n    entryComponents: [ɵEmptyOutletComponent]\n  }]\n}];\n/** @nocollapse */\n\nRouterModule.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [ROUTER_FORROOT_GUARD]\n    }]\n  }, {\n    type: Router,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n/**\n * @param {?} router\n * @param {?} viewportScroller\n * @param {?} config\n * @return {?}\n */\n\n\nfunction createRouterScroller(router, viewportScroller, config) {\n  if (config.scrollOffset) {\n    viewportScroller.setOffset(config.scrollOffset);\n  }\n\n  return new RouterScroller(router, viewportScroller, config);\n}\n/**\n * @param {?} platformLocationStrategy\n * @param {?} baseHref\n * @param {?=} options\n * @return {?}\n */\n\n\nfunction provideLocationStrategy(platformLocationStrategy, baseHref) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) : new PathLocationStrategy(platformLocationStrategy, baseHref);\n}\n/**\n * @param {?} router\n * @return {?}\n */\n\n\nfunction provideForRootGuard(router) {\n  if (router) {\n    throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\n  }\n\n  return 'guarded';\n}\n/**\n * Registers a [DI provider](guide/glossary#provider) for a set of routes.\n * \\@usageNotes\n *\n * ```\n * \\@NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * \\@publicApi\n * @param {?} routes The route configuration to provide.\n *\n * @return {?}\n */\n\n\nfunction provideRoutes(routes) {\n  return [{\n    provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n    multi: true,\n    useValue: routes\n  }, {\n    provide: ROUTES,\n    multi: true,\n    useValue: routes\n  }];\n}\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction ExtraOptions() {}\n\nif (false) {\n  /**\n   * When true, log all internal navigation events to the console.\n   * Use for debugging.\n   * @type {?|undefined}\n   */\n  ExtraOptions.prototype.enableTracing;\n  /**\n   * When true, enable the location strategy that uses the URL fragment\n   * instead of the history API.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.useHash;\n  /**\n   * One of `enabled` or `disabled`.\n   * When set to `enabled`, the initial navigation starts before the root component is created.\n   * The bootstrap is blocked until the initial navigation is complete. This value is required for\n   * [server-side rendering](guide/universal) to work.\n   * When set to `disabled`, the initial navigation is not performed.\n   * The location listener is set up before the root component gets created.\n   * Use if there is a reason to have more control over when the router\n   * starts its initial navigation due to some complex initialization logic.\n   *\n   * Legacy values are deprecated since v4 and should not be used for new applications:\n   *\n   * * `legacy_enabled` - Default for compatibility.\n   * The initial navigation starts after the root component has been created,\n   * but the bootstrap is not blocked until the initial navigation is complete.\n   * * `legacy_disabled` - The initial navigation is not performed.\n   * The location listener is set up after the root component gets created.\n   * * `true` - same as `legacy_enabled`.\n   * * `false` - same as `legacy_disabled`.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.initialNavigation;\n  /**\n   * A custom error handler for failed navigations.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.errorHandler;\n  /**\n   * Configures a preloading strategy.\n   * One of `PreloadAllModules` or `NoPreloading` (the default).\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.preloadingStrategy;\n  /**\n   * Define what the router should do if it receives a navigation request to the current URL.\n   * Default is `ignore`, which causes the router ignores the navigation.\n   * This can disable features such as a \"refresh\" button.\n   * Use this option to configure the behavior when navigating to the\n   * current URL. Default is 'ignore'.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.onSameUrlNavigation;\n  /**\n   * Configures if the scroll position needs to be restored when navigating back.\n   *\n   * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n   * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n   * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n   * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n   * navigation). This option will be the default in the future.\n   *\n   * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n   * in the following example.\n   *\n   * ```typescript\n   * class AppModule {\n   *   constructor(router: Router, viewportScroller: ViewportScroller) {\n   *     router.events.pipe(\n   *       filter((e: Event): e is Scroll => e instanceof Scroll)\n   *     ).subscribe(e => {\n   *       if (e.position) {\n   *         // backward navigation\n   *         viewportScroller.scrollToPosition(e.position);\n   *       } else if (e.anchor) {\n   *         // anchor navigation\n   *         viewportScroller.scrollToAnchor(e.anchor);\n   *       } else {\n   *         // forward navigation\n   *         viewportScroller.scrollToPosition([0, 0]);\n   *       }\n   *     });\n   *   }\n   * }\n   * ```\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.scrollPositionRestoration;\n  /**\n   * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n   * Anchor scrolling is disabled by default.\n   *\n   * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n   * that we stored or scroll to the top.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.anchorScrolling;\n  /**\n   * Configures the scroll offset the router will use when scrolling to an element.\n   *\n   * When given a tuple with x and y position value,\n   * the router uses that offset each time it scrolls.\n   * When given a function, the router invokes the function every time\n   * it restores scroll position.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.scrollOffset;\n  /**\n   * Defines how the router merges parameters, data, and resolved data from parent to child\n   * routes. By default ('emptyOnly'), inherits parent parameters only for\n   * path-less or component-less routes.\n   * Set to 'always' to enable unconditional inheritance of parent parameters.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.paramsInheritanceStrategy;\n  /**\n   * A custom handler for malformed URI errors. The handler is invoked when `encodedURI` contains\n   * invalid character sequences.\n   * The default implementation is to redirect to the root URL, dropping\n   * any path or parameter information. The function takes three parameters:\n   *\n   * - `'URIError'` - Error thrown when parsing a bad URL.\n   * - `'UrlSerializer'` - UrlSerializer that’s configured with the router.\n   * - `'url'` -  The malformed URL that caused the URIError\n   *\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.malformedUriErrorHandler;\n  /**\n   * Defines when the router updates the browser URL. By default ('deferred'),\n   * update after successful navigation.\n   * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n   * Updating the URL early allows you to handle a failure of navigation by\n   * showing an error message with the URL that failed.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.urlUpdateStrategy;\n  /**\n   * Enables a bug fix that corrects relative link resolution in components with empty paths.\n   * Example:\n   *\n   * ```\n   * const routes = [\n   *   {\n   *     path: '',\n   *     component: ContainerComponent,\n   *     children: [\n   *       { path: 'a', component: AComponent },\n   *       { path: 'b', component: BComponent },\n   *     ]\n   *   }\n   * ];\n   * ```\n   *\n   * From the `ContainerComponent`, this will not work:\n   *\n   * `<a [routerLink]=\"['./a']\">Link to A</a>`\n   *\n   * However, this will work:\n   *\n   * `<a [routerLink]=\"['../a']\">Link to A</a>`\n   *\n   * In other words, you're required to use `../` rather than `./`. This is currently the default\n   * behavior. Setting this option to `corrected` enables the fix.\n   * @type {?|undefined}\n   */\n\n  ExtraOptions.prototype.relativeLinkResolution;\n}\n/**\n * @param {?} ref\n * @param {?} urlSerializer\n * @param {?} contexts\n * @param {?} location\n * @param {?} injector\n * @param {?} loader\n * @param {?} compiler\n * @param {?} config\n * @param {?=} opts\n * @param {?=} urlHandlingStrategy\n * @param {?=} routeReuseStrategy\n * @return {?}\n */\n\n\nfunction setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config) {\n  var opts = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {};\n  var urlHandlingStrategy = arguments.length > 9 ? arguments[9] : undefined;\n  var routeReuseStrategy = arguments.length > 10 ? arguments[10] : undefined;\n\n  /** @type {?} */\n  var router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\n\n  if (urlHandlingStrategy) {\n    router.urlHandlingStrategy = urlHandlingStrategy;\n  }\n\n  if (routeReuseStrategy) {\n    router.routeReuseStrategy = routeReuseStrategy;\n  }\n\n  if (opts.errorHandler) {\n    router.errorHandler = opts.errorHandler;\n  }\n\n  if (opts.malformedUriErrorHandler) {\n    router.malformedUriErrorHandler = opts.malformedUriErrorHandler;\n  }\n\n  if (opts.enableTracing) {\n    /** @type {?} */\n    var dom = ɵgetDOM();\n    router.events.subscribe(\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n    function (e) {\n      dom.logGroup(\"Router Event: \".concat(\n      /** @type {?} */\n      e.constructor.name));\n      dom.log(e.toString());\n      dom.log(e);\n      dom.logGroupEnd();\n    });\n  }\n\n  if (opts.onSameUrlNavigation) {\n    router.onSameUrlNavigation = opts.onSameUrlNavigation;\n  }\n\n  if (opts.paramsInheritanceStrategy) {\n    router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\n  }\n\n  if (opts.urlUpdateStrategy) {\n    router.urlUpdateStrategy = opts.urlUpdateStrategy;\n  }\n\n  if (opts.relativeLinkResolution) {\n    router.relativeLinkResolution = opts.relativeLinkResolution;\n  }\n\n  return router;\n}\n/**\n * @param {?} router\n * @return {?}\n */\n\n\nfunction rootRoute(router) {\n  return router.routerState.root;\n}\n/**\n * Router initialization requires two steps:\n *\n * First, we start the navigation in a `APP_INITIALIZER` to block the bootstrap if\n * a resolver or a guard executes asynchronously.\n *\n * Next, we actually run activation in a `BOOTSTRAP_LISTENER`, using the\n * `afterPreactivation` hook provided by the router.\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\n\n\nvar RouterInitializer = /*#__PURE__*/function () {\n  /**\n   * @param {?} injector\n   */\n  function RouterInitializer(injector) {\n    _classCallCheck(this, RouterInitializer);\n\n    this.injector = injector;\n    this.initNavigation = false;\n    this.resultOfPreactivationDone = new Subject();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(RouterInitializer, [{\n    key: \"appInitializer\",\n    value: function appInitializer() {\n      var _this43 = this;\n\n      /** @type {?} */\n      var p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));\n      return p.then(\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        var resolve =\n        /** @type {?} */\n        null;\n        /** @type {?} */\n\n        var res = new Promise(\n        /**\n        * @param {?} r\n        * @return {?}\n        */\n        function (r) {\n          return resolve = r;\n        });\n        /** @type {?} */\n\n        var router = _this43.injector.get(Router);\n        /** @type {?} */\n\n\n        var opts = _this43.injector.get(ROUTER_CONFIGURATION);\n\n        if (_this43.isLegacyDisabled(opts) || _this43.isLegacyEnabled(opts)) {\n          resolve(true);\n        } else if (opts.initialNavigation === 'disabled') {\n          router.setUpLocationChangeListener();\n          resolve(true);\n        } else if (opts.initialNavigation === 'enabled') {\n          router.hooks.afterPreactivation =\n          /**\n          * @return {?}\n          */\n          function () {\n            // only the initial navigation should be delayed\n            if (!_this43.initNavigation) {\n              _this43.initNavigation = true;\n              resolve(true);\n              return _this43.resultOfPreactivationDone; // subsequent navigations should not be delayed\n            } else {\n              return (\n                /** @type {?} */\n                of(null)\n              );\n            }\n          };\n\n          router.initialNavigation();\n        } else {\n          throw new Error(\"Invalid initialNavigation options: '\".concat(opts.initialNavigation, \"'\"));\n        }\n\n        return res;\n      });\n    }\n    /**\n     * @param {?} bootstrappedComponentRef\n     * @return {?}\n     */\n\n  }, {\n    key: \"bootstrapListener\",\n    value: function bootstrapListener(bootstrappedComponentRef) {\n      /** @type {?} */\n      var opts = this.injector.get(ROUTER_CONFIGURATION);\n      /** @type {?} */\n\n      var preloader = this.injector.get(RouterPreloader);\n      /** @type {?} */\n\n      var routerScroller = this.injector.get(RouterScroller);\n      /** @type {?} */\n\n      var router = this.injector.get(Router);\n      /** @type {?} */\n\n      var ref = this.injector.get(ApplicationRef);\n\n      if (bootstrappedComponentRef !== ref.components[0]) {\n        return;\n      }\n\n      if (this.isLegacyEnabled(opts)) {\n        router.initialNavigation();\n      } else if (this.isLegacyDisabled(opts)) {\n        router.setUpLocationChangeListener();\n      }\n\n      preloader.setUpPreloading();\n      routerScroller.init();\n      router.resetRootComponentType(ref.componentTypes[0]);\n      this.resultOfPreactivationDone.next(\n      /** @type {?} */\n      null);\n      this.resultOfPreactivationDone.complete();\n    }\n    /**\n     * @private\n     * @param {?} opts\n     * @return {?}\n     */\n\n  }, {\n    key: \"isLegacyEnabled\",\n    value: function isLegacyEnabled(opts) {\n      return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true || opts.initialNavigation === undefined;\n    }\n    /**\n     * @private\n     * @param {?} opts\n     * @return {?}\n     */\n\n  }, {\n    key: \"isLegacyDisabled\",\n    value: function isLegacyDisabled(opts) {\n      return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;\n    }\n  }]);\n\n  return RouterInitializer;\n}();\n\nRouterInitializer.decorators = [{\n  type: Injectable\n}];\n/** @nocollapse */\n\nRouterInitializer.ctorParameters = function () {\n  return [{\n    type: Injector\n  }];\n};\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  RouterInitializer.prototype.initNavigation;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterInitializer.prototype.resultOfPreactivationDone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  RouterInitializer.prototype.injector;\n}\n/**\n * @param {?} r\n * @return {?}\n */\n\n\nfunction getAppInitializer(r) {\n  return r.appInitializer.bind(r);\n}\n/**\n * @param {?} r\n * @return {?}\n */\n\n\nfunction getBootstrapListener(r) {\n  return r.bootstrapListener.bind(r);\n}\n/**\n * A [DI token](guide/glossary/#di-token) for the router initializer that\n * is called after the app is bootstrapped.\n *\n * \\@publicApi\n * @type {?}\n */\n\n\nvar ROUTER_INITIALIZER = new InjectionToken('Router Initializer');\n/**\n * @return {?}\n */\n\nfunction provideRouterInitializer() {\n  return [RouterInitializer, {\n    provide: APP_INITIALIZER,\n    multi: true,\n    useFactory: getAppInitializer,\n    deps: [RouterInitializer]\n  }, {\n    provide: ROUTER_INITIALIZER,\n    useFactory: getBootstrapListener,\n    deps: [RouterInitializer]\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useExisting: ROUTER_INITIALIZER\n  }];\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@publicApi\n * @type {?}\n */\n\n\nvar VERSION = new Version('8.2.14');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ɵEmptyOutletComponent as ɵangular_packages_router_router_l, ɵEmptyOutletComponent, ROUTER_FORROOT_GUARD as ɵangular_packages_router_router_a, RouterInitializer as ɵangular_packages_router_router_h, createRouterScroller as ɵangular_packages_router_router_c, getAppInitializer as ɵangular_packages_router_router_i, getBootstrapListener as ɵangular_packages_router_router_j, provideForRootGuard as ɵangular_packages_router_router_e, provideLocationStrategy as ɵangular_packages_router_router_d, provideRouterInitializer as ɵangular_packages_router_router_k, rootRoute as ɵangular_packages_router_router_g, routerNgProbeToken as ɵangular_packages_router_router_b, setupRouter as ɵangular_packages_router_router_f, RouterScroller as ɵangular_packages_router_router_o, Tree as ɵangular_packages_router_router_m, TreeNode as ɵangular_packages_router_router_n, RouterLink, RouterLinkWithHref, RouterLinkActive, RouterOutlet, ActivationEnd, ActivationStart, ChildActivationEnd, ChildActivationStart, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouterEvent, RoutesRecognized, Scroll, RouteReuseStrategy, Router, ROUTES, ROUTER_CONFIGURATION, ROUTER_INITIALIZER, RouterModule, provideRoutes, ChildrenOutletContexts, OutletContext, NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader, ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot, PRIMARY_OUTLET, convertToParamMap, UrlHandlingStrategy, DefaultUrlSerializer, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VERSION, ROUTER_PROVIDERS as ɵROUTER_PROVIDERS, flatten as ɵflatten };","map":{"version":3,"sources":["../src/events.ts","../src/components/empty_outlet.ts","../src/shared.ts","../src/config.ts","../src/utils/collection.ts","../src/url_tree.ts","../src/utils/tree.ts","../src/router_state.ts","../src/create_router_state.ts","../src/create_url_tree.ts","../src/operators/activate_routes.ts","../src/utils/type_guards.ts","../src/apply_redirects.ts","../src/operators/apply_redirects.ts","../src/utils/preactivation.ts","../src/operators/prioritized_guard_value.ts","../src/operators/check_guards.ts","../src/recognize.ts","../src/operators/recognize.ts","../src/operators/resolve_data.ts","../src/operators/switch_tap.ts","../src/route_reuse_strategy.ts","../src/router_config_loader.ts","../src/url_handling_strategy.ts","../src/router.ts","../src/directives/router_link.ts","../src/directives/router_link_active.ts","../src/router_outlet_context.ts","../src/directives/router_outlet.ts","../src/router_preloader.ts","../src/router_scroller.ts","../src/router_module.ts","../src/version.ts","../router.ts"],"names":["EmptyOutletComponent","lastValue","isObservable","isPromise","applyRedirects","applyRedirectsFn","NoMatch","split","match","getOutlet","recognize","recognizeFn","last","Console","getDOM"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route} from './config';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\n\n/**\n * Identifies the call or event that triggered a navigation.\n *\n * * 'imperative': Triggered by `router.navigateByUrl()` or `router.navigate()`.\n * * 'popstate' : Triggered by a `popstate` event.\n * * 'hashchange'-: Triggered by a `hashchange` event.\n *\n * @publicApi\n */\nexport type NavigationTrigger = 'imperative' | 'popstate' | 'hashchange';\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * @usageNotes\n *\n * ```ts\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.pipe(\n *       filter(e => e instanceof RouterEvent)\n *     ).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * @see `Event`\n * @publicApi\n */\nexport class RouterEvent {\n  constructor(\n      /** A unique ID that the router assigns to every router navigation. */\n      public id: number,\n      /** The URL that is the destination for this navigation. */\n      public url: string) {}\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport class NavigationStart extends RouterEvent {\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   */\n  navigationTrigger?: 'imperative'|'popstate'|'hashchange';\n\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   */\n  restoredState?: {[k: string]: any, navigationId: number}|null;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      navigationTrigger: 'imperative'|'popstate'|'hashchange' = 'imperative',\n      /** @docsNotRequired */\n      restoredState: {[k: string]: any, navigationId: number}|null = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  toString(): string { return `NavigationStart(id: ${this.id}, url: '${this.url}')`; }\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @publicApi\n */\nexport class NavigationEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n *\n * This can happen when a [route guard](guide/router#milestone-5-route-guards)\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @publicApi\n */\nexport class NavigationCancel extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public reason: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string { return `NavigationCancel(id: ${this.id}, url: '${this.url}')`; }\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @publicApi\n */\nexport class NavigationError extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public error: any) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n *An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport class RoutesRecognized extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @publicApi\n */\nexport class GuardsCheckStart extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @publicApi\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot,\n      /** @docsNotRequired */\n      public shouldActivate: boolean) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * An event triggered at the the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @publicApi\n */\nexport class ResolveStart extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see `ResolveStart`.\n *\n * @publicApi\n */\nexport class ResolveEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @publicApi\n */\nexport class RouteConfigLoadStart {\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string { return `RouteConfigLoadStart(path: ${this.route.path})`; }\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @publicApi\n */\nexport class RouteConfigLoadEnd {\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string { return `RouteConfigLoadEnd(path: ${this.route.path})`; }\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see  `ChildActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ChildActivationStart {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see `ChildActivationStart`\n * @see `ResolveStart` *\n * @publicApi\n */\nexport class ChildActivationEnd {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see ActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ActivationStart {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationStart`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ActivationEnd {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport class Scroll {\n  constructor(\n      /** @docsNotRequired */\n      readonly routerEvent: NavigationEnd,\n\n      /** @docsNotRequired */\n      readonly position: [number, number]|null,\n\n      /** @docsNotRequired */\n      readonly anchor: string|null) {}\n\n  toString(): string {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The sequence of router events is as follows:\n *\n * - `NavigationStart`,\n * - `RouteConfigLoadStart`,\n * - `RouteConfigLoadEnd`,\n * - `RoutesRecognized`,\n * - `GuardsCheckStart`,\n * - `ChildActivationStart`,\n * - `ActivationStart`,\n * - `GuardsCheckEnd`,\n * - `ResolveStart`,\n * - `ResolveEnd`,\n * - `ActivationEnd`\n * - `ChildActivationEnd`\n * - `NavigationEnd`,\n * - `NavigationCancel`,\n * - `NavigationError`\n * - `Scroll`\n *\n * @publicApi\n */\nexport type Event = RouterEvent | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivationStart |\n    ChildActivationEnd | ActivationStart | ActivationEnd | Scroll;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Component} from '@angular/core';\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\n@Component({template: `<router-outlet></router-outlet>`})\nexport class ÉµEmptyOutletComponent {\n}\n\nexport {ÉµEmptyOutletComponent as EmptyOutletComponent};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route, UrlMatchResult} from './config';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * A collection of matrix and query URL parameters.\n * @see `convertToParamMap()`\n * @see `ParamMap`\n *\n * @publicApi\n */\nexport type Params = {\n  [key: string]: any\n};\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport interface ParamMap {\n  /**\n   * Reports whether the map contains a given parameter.\n   * @param name The parameter name.\n   * @returns True if the map contains the given parameter, false otherwise.\n   */\n  has(name: string): boolean;\n  /**\n   * Retrieves a single value for a parameter.\n   * @param name The parameter name.\n   * @return The parameter's single value,\n   * or the first value if the parameter has multiple values,\n   * or `null` when there is no such parameter.\n   */\n  get(name: string): string|null;\n  /**\n   * Retrieves multiple values for a parameter.\n   * @param name The parameter name.\n   * @return An array containing one or more values,\n   * or an empty array if there is no such parameter.\n   *\n   */\n  getAll(name: string): string[];\n\n  /** Names of the parameters in the map. */\n  readonly keys: string[];\n}\n\nclass ParamsAsMap implements ParamMap {\n  private params: Params;\n\n  constructor(params: Params) { this.params = params || {}; }\n\n  has(name: string): boolean { return this.params.hasOwnProperty(name); }\n\n  get(name: string): string|null {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n\n  getAll(name: string): string[] {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n\n  get keys(): string[] { return Object.keys(this.params); }\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nexport function navigationCancelingError(message: string) {\n  const error = Error('NavigationCancelingError: ' + message);\n  (error as any)[NAVIGATION_CANCELING_ERROR] = true;\n  return error;\n}\n\nexport function isNavigationCancelingError(error: Error) {\n  return error && (error as any)[NAVIGATION_CANCELING_ERROR];\n}\n\n// Matches the route configuration (`route`) against the actual URL (`segments`).\nexport function defaultUrlMatcher(\n    segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult|null {\n  const parts = route.path !.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' &&\n      (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const posParams: {[key: string]: UrlSegment} = {};\n\n  // Check each config part against the actual URL\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part.startsWith(':');\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {consumed: segments.slice(0, parts.length), posParams};\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModuleFactory, NgModuleRef, Type} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {EmptyOutletComponent} from './components/empty_outlet';\nimport {ActivatedRouteSnapshot} from './router_state';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n\n/**\n * Represents a route configuration for the Router service.\n * An array of `Route` objects, used in `Router.config` and for nested route configurations\n * in `Route.children`.\n *\n * @see `Route`\n * @see `Router`\n * @publicApi\n */\nexport type Routes = Route[];\n\n/**\n * Represents the result of matching URLs with a custom matching function.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @see `UrlMatcher()`\n * @publicApi\n */\nexport type UrlMatchResult = {\n  consumed: UrlSegment[]; posParams?: {[name: string]: UrlSegment};\n};\n\n/**\n * A function for matching a route against URLs. Implement a custom URL matcher\n * for `Route.matcher` when a combination of `path` and `pathMatch`\n * is not expressive enough. Cannot be used together with `path` and `pathMatch`.\n *\n * @param segments An array of URL segments.\n * @param group A segment group.\n * @param route The route to match against.\n * @returns The match-result.\n *\n * @usageNotes\n *\n * The following matcher matches HTML files.\n *\n * ```\n * export function htmlFiles(url: UrlSegment[]) {\n *   return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * export const routes = [{ matcher: htmlFiles, component: AnyComponent }];\n * ```\n *\n * @publicApi\n */\nexport type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) =>\n    UrlMatchResult;\n\n/**\n *\n * Represents static data associated with a particular route.\n *\n * @see `Route#data`\n *\n * @publicApi\n */\nexport type Data = {\n  [name: string]: any\n};\n\n/**\n *\n * Represents the resolved data associated with a particular route.\n *\n * @see `Route#resolve`.\n *\n * @publicApi\n */\nexport type ResolveData = {\n  [name: string]: any\n};\n\n/**\n *\n * A function that is called to resolve a collection of lazy-loaded routes.\n *\n * Often this function will be implemented using an ES dynamic `import()` expression. For example:\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * This function _must_ match the form above: an arrow function of the form\n * `() => import('...').then(mod => mod.MODULE)`.\n *\n * @see `Route#loadChildren`.\n * @publicApi\n */\nexport type LoadChildrenCallback = () => Type<any>| NgModuleFactory<any>| Observable<Type<any>>|\n    Promise<NgModuleFactory<any>|Type<any>|any>;\n\n/**\n *\n * A string of the form `path/to/file#exportName` that acts as a URL for a set of routes to load,\n * or a function that returns such a set.\n *\n * The string form of `LoadChildren` is deprecated (see `DeprecatedLoadChildren`). The function\n * form (`LoadChildrenCallback`) should be used instead.\n *\n * @see `Route#loadChildren`.\n * @publicApi\n */\nexport type LoadChildren = LoadChildrenCallback | DeprecatedLoadChildren;\n\n/**\n * A string of the form `path/to/file#exportName` that acts as a URL for a set of routes to load.\n *\n * @see `Route#loadChildren`\n * @publicApi\n * @deprecated the `string` form of `loadChildren` is deprecated in favor of the proposed ES dynamic\n * `import()` expression, which offers a more natural and standards-based mechanism to dynamically\n * load an ES module at runtime.\n */\nexport type DeprecatedLoadChildren = string;\n\n/**\n *\n * How to handle query parameters in a router link.\n * One of:\n * - `merge` : Merge new with current parameters.\n * - `preserve` : Preserve current parameters.\n *\n * @see `NavigationExtras#queryParamsHandling`\n * @see `RouterLink`\n * @publicApi\n */\nexport type QueryParamsHandling = 'merge' | 'preserve' | '';\n\n/**\n *\n * A policy for when to run guards and resolvers on a route.\n *\n * @see `Route#runGuardsAndResolvers`\n * @publicApi\n */\nexport type RunGuardsAndResolvers = 'pathParamsChange' | 'pathParamsOrQueryParamsChange' |\n    'paramsChange' | 'paramsOrQueryParamsChange' | 'always' |\n    ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) => boolean);\n\n/**\n * A configuration object that defines a single route.\n * A set of routes are collected in a `Routes` array to define a `Router` configuration.\n * The router attempts to match segments of a given URL against each route,\n * using the configuration options defined in this object.\n *\n * Supports static, parameterized, redirect, and wildcard routes, as well as\n * custom route data and resolve methods.\n *\n * For detailed usage information, see the [Routing Guide](guide/router).\n *\n * @usageNotes\n *\n * ### Simple Configuration\n *\n * The following route specifies that when navigating to, for example,\n * `/team/11/user/bob`, the router creates the 'Team' component\n * with the 'User' child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n  *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * ### Multiple Outlets\n *\n * The following route creates sibling components with multiple outlets.\n * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to\n * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * ### Wild Cards\n *\n * The following route uses wild-card notation to specify a component\n * that is always instantiated regardless of where you navigate to.\n *\n * ```\n * [{\n *   path: '**',\n *   component: WildcardComponent\n * }]\n * ```\n *\n * ### Redirects\n *\n * The following route uses the `redirectTo` property to ignore a segment of\n * a given URL when looking for a child path.\n *\n * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment\n * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates\n * the Team component with the User child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * The redirect path can be relative, as shown in this example, or absolute.\n * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',\n * the result URL is also absolute, '/user/jim'.\n\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any URL segments.\n *\n * In the following configuration, when navigating to\n * `/team/11`, the router instantiates the 'AllUsers' component.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * Empty-path routes can have children. In the following example, when navigating\n * to `/team/11/user/jim`, the router instantiates the wrapper component with\n * the user component in it.\n *\n * Note that an empty path route inherits its parent's parameters and data.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * ### Matching Strategy\n *\n * The default path-match strategy is 'prefix', which means that the router\n * checks URL elements from the left to see if the URL matches a specified path.\n * For example, '/team/11/user' matches 'team/:id'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * You can specify the path-match strategy 'full' to make sure that the path\n * covers the whole unconsumed URL. It is important to do this when redirecting\n * empty-path routes. Otherwise, because an empty path is a prefix of any URL,\n * the router would apply the redirect even when navigating to the redirect destination,\n * creating an endless loop.\n *\n * In the following example, supplying the 'full' `pathMatch` strategy ensures\n * that the router applies the redirect if and only if navigating to '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * You can share parameters between sibling components.\n * For example, suppose that two sibling components should go next to each other,\n * and both of them require an ID parameter. You can accomplish this using a route\n * that does not specify a component at the top level.\n *\n * In the following example, 'MainChild' and 'AuxChild' are siblings.\n * When navigating to 'parent/10/(a//aux:b)', the route instantiates\n * the main child and aux child components next to each other.\n * For this to work, the application component must have the primary and aux outlets defined.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * The router merges the parameters, data, and resolve of the componentless\n * parent into the parameters, data, and resolve of the children.\n *\n * This is especially useful when child components are defined\n * with an empty path string, as in the following example.\n * With this configuration, navigating to '/parent/10' creates\n * the main child and aux components.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up application load time by splitting the application\n * into multiple bundles and loading them on demand.\n * To use lazy loading, provide the `loadChildren` property  instead of the `children` property.\n *\n * Given the following example route, the router will lazy load\n * the associated module on demand using the browser native import system.\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * @publicApi\n */\nexport interface Route {\n  /**\n   * The path to match against. Cannot be used together with a custom `matcher` function.\n   * A URL string that uses router matching notation.\n   * Can be a wild card (`**`) that matches any URL (see Usage Notes below).\n   * Default is \"/\" (the root path).\n   *\n   */\n  path?: string;\n  /**\n   * The path-matching strategy, one of 'prefix' or 'full'.\n   * Default is 'prefix'.\n   *\n   * By default, the router checks URL elements from the left to see if the URL\n   * matches a given  path, and stops when there is a match. For example,\n   * '/team/11/user' matches 'team/:id'.\n   *\n   * The path-match strategy 'full' matches against the entire URL.\n   * It is important to do this when redirecting empty-path routes.\n   * Otherwise, because an empty path is a prefix of any URL,\n   * the router would apply the redirect even when navigating\n   * to the redirect destination, creating an endless loop.\n   *\n   */\n  pathMatch?: string;\n  /**\n   * A custom URL-matching function. Cannot be used together with `path`.\n   */\n  matcher?: UrlMatcher;\n  /**\n   * The component to instantiate when the path matches.\n   * Can be empty if child routes specify components.\n   */\n  component?: Type<any>;\n  /**\n   * A URL to which to redirect when a the path matches.\n   * Absolute if the URL begins with a slash (/), otherwise relative to the path URL.\n   * When not present, router does not redirect.\n   */\n  redirectTo?: string;\n  /**\n   * Name of a `RouterOutlet` object where the component can be placed\n   * when the path matches.\n   */\n  outlet?: string;\n  /**\n   * An array of dependency-injection tokens used to look up `CanActivate()`\n   * handlers, in order to determine if the current user is allowed to\n   * activate the component. By default, any user can activate.\n   */\n  canActivate?: any[];\n  /**\n   * An array of DI tokens used to look up `CanActivateChild()` handlers,\n   * in order to determine if the current user is allowed to activate\n   * a child of the component. By default, any user can activate a child.\n   */\n  canActivateChild?: any[];\n  /**\n   * An array of DI tokens used to look up `CanDeactivate()`\n   * handlers, in order to determine if the current user is allowed to\n   * deactivate the component. By default, any user can deactivate.\n   *\n   */\n  canDeactivate?: any[];\n  /**\n   * An array of DI tokens used to look up `CanLoad()`\n   * handlers, in order to determine if the current user is allowed to\n   * load the component. By default, any user can load.\n   */\n  canLoad?: any[];\n  /**\n   * Additional developer-defined data provided to the component via\n   * `ActivatedRoute`. By default, no additional data is passed.\n   */\n  data?: Data;\n  /**\n   * A map of DI tokens used to look up data resolvers. See `Resolve`.\n   */\n  resolve?: ResolveData;\n  /**\n   * An array of child `Route` objects that specifies a nested route\n   * configuration.\n   */\n  children?: Routes;\n  /**\n   * A `LoadChildren` object specifying lazy-loaded child routes.\n   */\n  loadChildren?: LoadChildren;\n  /**\n   * Defines when guards and resolvers will be run. One of\n   * - `paramsOrQueryParamsChange` : Run when query parameters change.\n   * - `always` : Run on every execution.\n   * By default, guards and resolvers run only when the matrix\n   * parameters of the route change.\n   */\n  runGuardsAndResolvers?: RunGuardsAndResolvers;\n  /**\n   * Filled for routes with `loadChildren` once the module has been loaded\n   * @internal\n   */\n  _loadedConfig?: LoadedRouterConfig;\n}\n\nexport class LoadedRouterConfig {\n  constructor(public routes: Route[], public module: NgModuleRef<any>) {}\n}\n\nexport function validateConfig(config: Routes, parentPath: string = ''): void {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    const route: Route = config[i];\n    const fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath);\n  }\n}\n\nfunction validateNode(route: Route, fullPath: string): void {\n  if (!route) {\n    throw new Error(`\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n  }\n  if (Array.isArray(route)) {\n    throw new Error(`Invalid configuration of route '${fullPath}': Array cannot be specified`);\n  }\n  if (!route.component && !route.children && !route.loadChildren &&\n      (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n  }\n  if (route.redirectTo && route.children) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n  }\n  if (route.redirectTo && route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n  }\n  if (route.children && route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n  }\n  if (route.redirectTo && route.component) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and component cannot be used together`);\n  }\n  if (route.path && route.matcher) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n  }\n  if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, redirectTo, children or loadChildren`);\n  }\n  if (route.path === void 0 && route.matcher === void 0) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n  }\n  if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n    throw new Error(`Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n  }\n  if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n    const exp =\n        `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n    throw new Error(\n        `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n  }\n  if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': pathMatch can only be set to 'prefix' or 'full'`);\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath);\n  }\n}\n\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nexport function standardizeConfig(r: Route): Route {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {...r, children} : {...r};\n  if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {\n    c.component = EmptyOutletComponent;\n  }\n  return c;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModuleFactory, ÉµisObservable as isObservable, ÉµisPromise as isPromise} from '@angular/core';\nimport {Observable, from, of } from 'rxjs';\nimport {concatAll, last as lastValue, map} from 'rxjs/operators';\n\nimport {PRIMARY_OUTLET} from '../shared';\n\nexport function shallowEqualArrays(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(a: {[x: string]: any}, b: {[x: string]: any}): boolean {\n  // Casting Object.keys return values to include `undefined` as there are some cases\n  // in IE 11 where this can happen. Cannot provide a test because the behavior only\n  // exists in certain circumstances in IE 11, therefore doing this cast ensures the\n  // logic is correct for when this edge case is hit.\n  const k1 = Object.keys(a) as string[] | undefined;\n  const k2 = Object.keys(b) as string[] | undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key: string;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Flattens single-level nested arrays.\n */\nexport function flatten<T>(arr: T[][]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: T[]): T|null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\n/**\n * Verifys all booleans in an array are `true`.\n */\nexport function and(bools: boolean[]): boolean {\n  return !bools.some(v => !v);\n}\n\nexport function forEach<K, V>(map: {[key: string]: V}, callback: (v: V, k: string) => void): void {\n  for (const prop in map) {\n    if (map.hasOwnProperty(prop)) {\n      callback(map[prop], prop);\n    }\n  }\n}\n\nexport function waitForMap<A, B>(\n    obj: {[k: string]: A}, fn: (k: string, a: A) => Observable<B>): Observable<{[k: string]: B}> {\n  if (Object.keys(obj).length === 0) {\n    return of ({});\n  }\n\n  const waitHead: Observable<B>[] = [];\n  const waitTail: Observable<B>[] = [];\n  const res: {[k: string]: B} = {};\n\n  forEach(obj, (a: A, k: string) => {\n    const mapped = fn(k, a).pipe(map((r: B) => res[k] = r));\n    if (k === PRIMARY_OUTLET) {\n      waitHead.push(mapped);\n    } else {\n      waitTail.push(mapped);\n    }\n  });\n\n  // Closure compiler has problem with using spread operator here. So we use \"Array.concat\".\n  // Note that we also need to cast the new promise because TypeScript cannot infer the type\n  // when calling the \"of\" function through \"Function.apply\"\n  return (of .apply(null, waitHead.concat(waitTail)) as Observable<Observable<B>>)\n      .pipe(concatAll(), lastValue(), map(() => res));\n}\n\nexport function wrapIntoObservable<T>(value: T | Promise<T>| Observable<T>): Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of (value);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PRIMARY_OUTLET, ParamMap, Params, convertToParamMap} from './shared';\nimport {forEach, shallowEqual} from './utils/collection';\n\nexport function createEmptyUrlTree() {\n  return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n\nexport function containsTree(container: UrlTree, containee: UrlTree, exact: boolean): boolean {\n  if (exact) {\n    return equalQueryParams(container.queryParams, containee.queryParams) &&\n        equalSegmentGroups(container.root, containee.root);\n  }\n\n  return containsQueryParams(container.queryParams, containee.queryParams) &&\n      containsSegmentGroup(container.root, containee.root);\n}\n\nfunction equalQueryParams(container: Params, containee: Params): boolean {\n  // TODO: This does not handle array params correctly.\n  return shallowEqual(container, containee);\n}\n\nfunction equalSegmentGroups(container: UrlSegmentGroup, containee: UrlSegmentGroup): boolean {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c])) return false;\n  }\n  return true;\n}\n\nfunction containsQueryParams(container: Params, containee: Params): boolean {\n  // TODO: This does not handle array params correctly.\n  return Object.keys(containee).length <= Object.keys(container).length &&\n      Object.keys(containee).every(key => containee[key] === container[key]);\n}\n\nfunction containsSegmentGroup(container: UrlSegmentGroup, containee: UrlSegmentGroup): boolean {\n  return containsSegmentGroupHelper(container, containee, containee.segments);\n}\n\nfunction containsSegmentGroupHelper(\n    container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[]): boolean {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    return true;\n\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c])) return false;\n    }\n    return true;\n\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\n  }\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlTree {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _queryParamMap !: ParamMap;\n\n  /** @internal */\n  constructor(\n      /** The root segment group of the URL tree */\n      public root: UrlSegmentGroup,\n      /** The query params of the URL */\n      public queryParams: Params,\n      /** The fragment of the URL */\n      public fragment: string|null) {}\n\n  get queryParamMap(): ParamMap {\n    if (!this._queryParamMap) {\n      this._queryParamMap = convertToParamMap(this.queryParams);\n    }\n    return this._queryParamMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string { return DEFAULT_SERIALIZER.serialize(this); }\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport class UrlSegmentGroup {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _sourceSegment !: UrlSegmentGroup;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _segmentIndexShift !: number;\n  /** The parent node in the url tree */\n  parent: UrlSegmentGroup|null = null;\n\n  constructor(\n      /** The URL segments of this group. See `UrlSegment` for more information */\n      public segments: UrlSegment[],\n      /** The list of children of this group */\n      public children: {[key: string]: UrlSegmentGroup}) {\n    forEach(children, (v: any, k: any) => v.parent = this);\n  }\n\n  /** Whether the segment has child segments */\n  hasChildren(): boolean { return this.numberOfChildren > 0; }\n\n  /** Number of child segments */\n  get numberOfChildren(): number { return Object.keys(this.children).length; }\n\n  /** @docsNotRequired */\n  toString(): string { return serializePaths(this); }\n}\n\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n *Â ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class UrlSegment {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _parameterMap !: ParamMap;\n\n  constructor(\n      /** The path part of a URL segment */\n      public path: string,\n\n      /** The matrix parameters associated with a segment */\n      public parameters: {[name: string]: string}) {}\n\n  get parameterMap() {\n    if (!this._parameterMap) {\n      this._parameterMap = convertToParamMap(this.parameters);\n    }\n    return this._parameterMap;\n  }\n\n  /** @docsNotRequired */\n  toString(): string { return serializePath(this); }\n}\n\nexport function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\n\nexport function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\n\nexport function mapChildrenIntoArray<T>(\n    segment: UrlSegmentGroup, fn: (v: UrlSegmentGroup, k: string) => T[]): T[] {\n  let res: T[] = [];\n  forEach(segment.children, (child: UrlSegmentGroup, childOutlet: string) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  forEach(segment.children, (child: UrlSegmentGroup, childOutlet: string) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\n\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\nexport abstract class UrlSerializer {\n  /** Parse a url into a `UrlTree` */\n  abstract parse(url: string): UrlTree;\n\n  /** Converts a `UrlTree` into a url */\n  abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport class DefaultUrlSerializer implements UrlSerializer {\n  /** Parses a url into a `UrlTree` */\n  parse(url: string): UrlTree {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n\n  /** Converts a `UrlTree` into a url */\n  serialize(tree: UrlTree): string {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment =\n        typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment !)}` : '';\n\n    return `${segment}${query}${fragment}`;\n  }\n}\n\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\n\nexport function serializePaths(segment: UrlSegmentGroup): string {\n  return segment.segments.map(p => serializePath(p)).join('/');\n}\n\nfunction serializeSegment(segment: UrlSegmentGroup, root: boolean): string {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET] ?\n        serializeSegment(segment.children[PRIMARY_OUTLET], false) :\n        '';\n    const children: string[] = [];\n\n    forEach(segment.children, (v: UrlSegmentGroup, k: string) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n\n  } else {\n    const children = mapChildrenIntoArray(segment, (v: UrlSegmentGroup, k: string) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n\n      return [`${k}:${serializeSegment(v, false)}`];\n\n    });\n\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\n\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s: string): string {\n  return encodeURIComponent(s)\n      .replace(/%40/g, '@')\n      .replace(/%3A/gi, ':')\n      .replace(/%24/g, '$')\n      .replace(/%2C/gi, ',');\n}\n\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriQuery(s: string): string {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\n\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriFragment(s: string): string {\n  return encodeURI(s);\n}\n\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nexport function encodeUriSegment(s: string): string {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\n\nexport function decode(s: string): string {\n  return decodeURIComponent(s);\n}\n\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nexport function decodeQuery(s: string): string {\n  return decode(s.replace(/\\+/g, '%20'));\n}\n\nexport function serializePath(path: UrlSegment): string {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\n\nfunction serializeMatrixParams(params: {[key: string]: string}): string {\n  return Object.keys(params)\n      .map(key => `;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`)\n      .join('');\n}\n\nfunction serializeQueryParams(params: {[key: string]: any}): string {\n  const strParams: string[] = Object.keys(params).map((name) => {\n    const value = params[name];\n    return Array.isArray(value) ?\n        value.map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&') :\n        `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n  });\n\n  return strParams.length ? `?${strParams.join(\"&\")}` : '';\n}\n\nconst SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchSegments(str: string): string {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str: string): string {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\n\nconst QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str: string): string {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\n\nclass UrlParser {\n  private remaining: string;\n\n  constructor(private url: string) { this.remaining = url; }\n\n  parseRootSegment(): UrlSegmentGroup {\n    this.consumeOptional('/');\n\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n\n    // The root segment group never has segments\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n\n  parseQueryParams(): Params {\n    const params: Params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n\n  parseFragment(): string|null {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n\n  private parseChildren(): {[outlet: string]: UrlSegmentGroup} {\n    if (this.remaining === '') {\n      return {};\n    }\n\n    this.consumeOptional('/');\n\n    const segments: UrlSegment[] = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n\n    let children: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n\n    let res: {[outlet: string]: UrlSegmentGroup} = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n\n    return res;\n  }\n\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  private parseSegment(): UrlSegment {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);\n    }\n\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n\n  private parseMatrixParams(): {[key: string]: any} {\n    const params: {[key: string]: any} = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n\n  private parseParam(params: {[key: string]: any}): void {\n    const key = matchSegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    params[decode(key)] = decode(value);\n  }\n\n  // Parse a single query parameter `name[=value]`\n  private parseQueryParam(params: Params): void {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value: any = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n\n    if (params.hasOwnProperty(decodedKey)) {\n      // Append to existing values\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      // Create a new value\n      params[decodedKey] = decodedVal;\n    }\n  }\n\n  // parse `(a/b//outlet_name:c/d)`\n  private parseParens(allowPrimary: boolean): {[outlet: string]: UrlSegmentGroup} {\n    const segments: {[key: string]: UrlSegmentGroup} = {};\n    this.capture('(');\n\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n\n      const next = this.remaining[path.length];\n\n      // if is is not one of these characters, then the segment was unescaped\n      // or the group was not closed\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new Error(`Cannot parse url '${this.url}'`);\n      }\n\n      let outletName: string = undefined !;\n      if (path.indexOf(':') > -1) {\n        outletName = path.substr(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n\n      const children = this.parseChildren();\n      segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\n                                                                  new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n\n    return segments;\n  }\n\n  private peekStartsWith(str: string): boolean { return this.remaining.startsWith(str); }\n\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  private consumeOptional(str: string): boolean {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n\n  private capture(str: string): void {\n    if (!this.consumeOptional(str)) {\n      throw new Error(`Expected \"${str}\".`);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport class Tree<T> {\n  /** @internal */\n  _root: TreeNode<T>;\n\n  constructor(root: TreeNode<T>) { this._root = root; }\n\n  get root(): T { return this._root.value; }\n\n  /**\n   * @internal\n   */\n  parent(t: T): T|null {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n\n  /**\n   * @internal\n   */\n  children(t: T): T[] {\n    const n = findNode(t, this._root);\n    return n ? n.children.map(t => t.value) : [];\n  }\n\n  /**\n   * @internal\n   */\n  firstChild(t: T): T|null {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n\n  /**\n   * @internal\n   */\n  siblings(t: T): T[] {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n\n    const c = p[p.length - 2].children.map(c => c.value);\n    return c.filter(cc => cc !== t);\n  }\n\n  /**\n   * @internal\n   */\n  pathFromRoot(t: T): T[] { return findPath(t, this._root).map(s => s.value); }\n}\n\n\n// DFS for the node matching the value\nfunction findNode<T>(value: T, node: TreeNode<T>): TreeNode<T>|null {\n  if (value === node.value) return node;\n\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n\n  return null;\n}\n\n// Return the path to the node with the given value using DFS\nfunction findPath<T>(value: T, node: TreeNode<T>): TreeNode<T>[] {\n  if (value === node.value) return [node];\n\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n\n  return [];\n}\n\nexport class TreeNode<T> {\n  constructor(public value: T, public children: TreeNode<T>[]) {}\n\n  toString(): string { return `TreeNode(${this.value})`; }\n}\n\n// Return the list of T indexed by outlet name\nexport function nodeChildrenAsMap<T extends{outlet: string}>(node: TreeNode<T>| null) {\n  const map: {[outlet: string]: TreeNode<T>} = {};\n\n  if (node) {\n    node.children.forEach(child => map[child.value.outlet] = child);\n  }\n\n  return map;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\nimport {BehaviorSubject, Observable} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {Data, ResolveData, Route} from './config';\nimport {PRIMARY_OUTLET, ParamMap, Params, convertToParamMap} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlTree, equalSegments} from './url_tree';\nimport {shallowEqual, shallowEqualArrays} from './utils/collection';\nimport {Tree, TreeNode} from './utils/tree';\n\n\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see `ActivatedRoute`\n *\n * @publicApi\n */\nexport class RouterState extends Tree<ActivatedRoute> {\n  /** @internal */\n  constructor(\n      root: TreeNode<ActivatedRoute>,\n      /** The current snapshot of the router state */\n      public snapshot: RouterStateSnapshot) {\n    super(root);\n    setRouterState(<RouterState>this, root);\n  }\n\n  toString(): string { return this.snapshot.toString(); }\n}\n\nexport function createEmptyState(urlTree: UrlTree, rootComponent: Type<any>| null): RouterState {\n  const snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject('');\n  const activated = new ActivatedRoute(\n      emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent,\n      snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode<ActivatedRoute>(activated, []), snapshot);\n}\n\nexport function createEmptyStateSnapshot(\n    urlTree: UrlTree, rootComponent: Type<any>| null): RouterStateSnapshot {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot(\n      [], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null,\n      urlTree.root, -1, {});\n  return new RouterStateSnapshot('', new TreeNode<ActivatedRouteSnapshot>(activated, []));\n}\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @publicApi\n */\nexport class ActivatedRoute {\n  /** The current snapshot of this route */\n  snapshot !: ActivatedRouteSnapshot;\n  /** @internal */\n  _futureSnapshot: ActivatedRouteSnapshot;\n  /** @internal */\n  _routerState !: RouterState;\n  /** @internal */\n  _paramMap !: Observable<ParamMap>;\n  /** @internal */\n  _queryParamMap !: Observable<ParamMap>;\n\n  /** @internal */\n  constructor(\n      /** An observable of the URL segments matched by this route. */\n      public url: Observable<UrlSegment[]>,\n      /** An observable of the matrix parameters scoped to this route. */\n      public params: Observable<Params>,\n      /** An observable of the query parameters shared by all the routes. */\n      public queryParams: Observable<Params>,\n      /** An observable of the URL fragment shared by all the routes. */\n      public fragment: Observable<string>,\n      /** An observable of the static and resolved data of this route. */\n      public data: Observable<Data>,\n      /** The outlet name of the route, a constant. */\n      public outlet: string,\n      /** The component of the route, a constant. */\n      // TODO(vsavkin): remove |string\n      public component: Type<any>|string|null, futureSnapshot: ActivatedRouteSnapshot) {\n    this._futureSnapshot = futureSnapshot;\n  }\n\n  /** The configuration used to match this route. */\n  get routeConfig(): Route|null { return this._futureSnapshot.routeConfig; }\n\n  /** The root of the router state. */\n  get root(): ActivatedRoute { return this._routerState.root; }\n\n  /** The parent of this route in the router state tree. */\n  get parent(): ActivatedRoute|null { return this._routerState.parent(this); }\n\n  /** The first child of this route in the router state tree. */\n  get firstChild(): ActivatedRoute|null { return this._routerState.firstChild(this); }\n\n  /** The children of this route in the router state tree. */\n  get children(): ActivatedRoute[] { return this._routerState.children(this); }\n\n  /** The path from the root of the router state tree to this route. */\n  get pathFromRoot(): ActivatedRoute[] { return this._routerState.pathFromRoot(this); }\n\n  /** An Observable that contains a map of the required and optional parameters\n   * specific to the route.\n   * The map supports retrieving single and multiple values from the same parameter. */\n  get paramMap(): Observable<ParamMap> {\n    if (!this._paramMap) {\n      this._paramMap = this.params.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    }\n    return this._paramMap;\n  }\n\n  /**\n   * An Observable that contains a map of the query parameters available to all routes.\n   * The map supports retrieving single and multiple values from the query parameter.\n   */\n  get queryParamMap(): Observable<ParamMap> {\n    if (!this._queryParamMap) {\n      this._queryParamMap =\n          this.queryParams.pipe(map((p: Params): ParamMap => convertToParamMap(p)));\n    }\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\n\nexport type ParamsInheritanceStrategy = 'emptyOnly' | 'always';\n\n/** @internal */\nexport type Inherited = {\n  params: Params,\n  data: Data,\n  resolve: Data,\n};\n\n/**\n * Returns the inherited params, data, and resolve for a given route.\n * By default, this only inherits values up to the nearest path-less or component-less route.\n * @internal\n */\nexport function inheritedParamsDataResolve(\n    route: ActivatedRouteSnapshot,\n    paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly'): Inherited {\n  const pathFromRoot = route.pathFromRoot;\n\n  let inheritingStartingFrom = 0;\n  if (paramsInheritanceStrategy !== 'always') {\n    inheritingStartingFrom = pathFromRoot.length - 1;\n\n    while (inheritingStartingFrom >= 1) {\n      const current = pathFromRoot[inheritingStartingFrom];\n      const parent = pathFromRoot[inheritingStartingFrom - 1];\n      // current route is an empty path => inherits its parent's params and data\n      if (current.routeConfig && current.routeConfig.path === '') {\n        inheritingStartingFrom--;\n\n        // parent is componentless => current route should inherit its params and data\n      } else if (!parent.component) {\n        inheritingStartingFrom--;\n\n      } else {\n        break;\n      }\n    }\n  }\n\n  return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));\n}\n\n/** @internal */\nfunction flattenInherited(pathFromRoot: ActivatedRouteSnapshot[]): Inherited {\n  return pathFromRoot.reduce((res, curr) => {\n    const params = {...res.params, ...curr.params};\n    const data = {...res.data, ...curr.data};\n    const resolve = {...res.resolve, ...curr._resolvedData};\n    return {params, data, resolve};\n  }, <any>{params: {}, data: {}, resolve: {}});\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * ```\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class ActivatedRouteSnapshot {\n  /** The configuration used to match this route **/\n  public readonly routeConfig: Route|null;\n  /** @internal **/\n  _urlSegment: UrlSegmentGroup;\n  /** @internal */\n  _lastPathIndex: number;\n  /** @internal */\n  _resolve: ResolveData;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _resolvedData !: Data;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _routerState !: RouterStateSnapshot;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _paramMap !: ParamMap;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _queryParamMap !: ParamMap;\n\n  /** @internal */\n  constructor(\n      /** The URL segments matched by this route */\n      public url: UrlSegment[],\n      /** The matrix parameters scoped to this route */\n      public params: Params,\n      /** The query parameters shared by all the routes */\n      public queryParams: Params,\n      /** The URL fragment shared by all the routes */\n      public fragment: string,\n      /** The static and resolved data of this route */\n      public data: Data,\n      /** The outlet name of the route */\n      public outlet: string,\n      /** The component of the route */\n      public component: Type<any>|string|null, routeConfig: Route|null, urlSegment: UrlSegmentGroup,\n      lastPathIndex: number, resolve: ResolveData) {\n    this.routeConfig = routeConfig;\n    this._urlSegment = urlSegment;\n    this._lastPathIndex = lastPathIndex;\n    this._resolve = resolve;\n  }\n\n  /** The root of the router state */\n  get root(): ActivatedRouteSnapshot { return this._routerState.root; }\n\n  /** The parent of this route in the router state tree */\n  get parent(): ActivatedRouteSnapshot|null { return this._routerState.parent(this); }\n\n  /** The first child of this route in the router state tree */\n  get firstChild(): ActivatedRouteSnapshot|null { return this._routerState.firstChild(this); }\n\n  /** The children of this route in the router state tree */\n  get children(): ActivatedRouteSnapshot[] { return this._routerState.children(this); }\n\n  /** The path from the root of the router state tree to this route */\n  get pathFromRoot(): ActivatedRouteSnapshot[] { return this._routerState.pathFromRoot(this); }\n\n  get paramMap(): ParamMap {\n    if (!this._paramMap) {\n      this._paramMap = convertToParamMap(this.params);\n    }\n    return this._paramMap;\n  }\n\n  get queryParamMap(): ParamMap {\n    if (!this._queryParamMap) {\n      this._queryParamMap = convertToParamMap(this.queryParams);\n    }\n    return this._queryParamMap;\n  }\n\n  toString(): string {\n    const url = this.url.map(segment => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {\n  /** @internal */\n  constructor(\n      /** The url from which this snapshot was created */\n      public url: string, root: TreeNode<ActivatedRouteSnapshot>) {\n    super(root);\n    setRouterState(<RouterStateSnapshot>this, root);\n  }\n\n  toString(): string { return serializeNode(this._root); }\n}\n\nfunction setRouterState<U, T extends{_routerState: U}>(state: U, node: TreeNode<T>): void {\n  node.value._routerState = state;\n  node.children.forEach(c => setRouterState(state, c));\n}\n\nfunction serializeNode(node: TreeNode<ActivatedRouteSnapshot>): string {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\n\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\nexport function advanceActivatedRoute(route: ActivatedRoute): void {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      (<any>route.queryParams).next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      (<any>route.fragment).next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      (<any>route.params).next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      (<any>route.url).next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      (<any>route.data).next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n\n    // this is for resolved data\n    (<any>route.data).next(route._futureSnapshot.data);\n  }\n}\n\n\nexport function equalParamsAndUrlSegments(\n    a: ActivatedRouteSnapshot, b: ActivatedRouteSnapshot): boolean {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n\n  return equalUrlParams && !parentsMismatch &&\n      (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent !));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BehaviorSubject} from 'rxjs';\n\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from './route_reuse_strategy';\nimport {ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\nexport function createRouterState(\n    routeReuseStrategy: RouteReuseStrategy, curr: RouterStateSnapshot,\n    prevState: RouterState): RouterState {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\n\nfunction createNode(\n    routeReuseStrategy: RouteReuseStrategy, curr: TreeNode<ActivatedRouteSnapshot>,\n    prevState?: TreeNode<ActivatedRoute>): TreeNode<ActivatedRoute> {\n  // reuse an activated route that is currently displayed on the screen\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode<ActivatedRoute>(value, children);\n\n    // retrieve an activated route that is used to be displayed, but is not currently displayed\n  } else {\n    const detachedRouteHandle =\n        <DetachedRouteHandleInternal>routeReuseStrategy.retrieve(curr.value);\n    if (detachedRouteHandle) {\n      const tree: TreeNode<ActivatedRoute> = detachedRouteHandle.route;\n      setFutureSnapshotsOfActivatedRoutes(curr, tree);\n      return tree;\n\n    } else {\n      const value = createActivatedRoute(curr.value);\n      const children = curr.children.map(c => createNode(routeReuseStrategy, c));\n      return new TreeNode<ActivatedRoute>(value, children);\n    }\n  }\n}\n\nfunction setFutureSnapshotsOfActivatedRoutes(\n    curr: TreeNode<ActivatedRouteSnapshot>, result: TreeNode<ActivatedRoute>): void {\n  if (curr.value.routeConfig !== result.value.routeConfig) {\n    throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');\n  }\n  if (curr.children.length !== result.children.length) {\n    throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');\n  }\n  result.value._futureSnapshot = curr.value;\n  for (let i = 0; i < curr.children.length; ++i) {\n    setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\n  }\n}\n\nfunction createOrReuseChildren(\n    routeReuseStrategy: RouteReuseStrategy, curr: TreeNode<ActivatedRouteSnapshot>,\n    prevState: TreeNode<ActivatedRoute>) {\n  return curr.children.map(child => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\n\nfunction createActivatedRoute(c: ActivatedRouteSnapshot) {\n  return new ActivatedRoute(\n      new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams),\n      new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ActivatedRoute} from './router_state';\nimport {PRIMARY_OUTLET, Params} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\nimport {forEach, last, shallowEqual} from './utils/collection';\n\nexport function createUrlTree(\n    route: ActivatedRoute, urlTree: UrlTree, commands: any[], queryParams: Params,\n    fragment: string): UrlTree {\n  if (commands.length === 0) {\n    return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\n  }\n\n  const nav = computeNavigation(commands);\n\n  if (nav.toRoot()) {\n    return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\n  }\n\n  const startingPosition = findStartingPosition(nav, urlTree, route);\n\n  const segmentGroup = startingPosition.processChildren ?\n      updateSegmentGroupChildren(\n          startingPosition.segmentGroup, startingPosition.index, nav.commands) :\n      updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\n  return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\n}\n\nfunction isMatrixParams(command: any): boolean {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n\nfunction tree(\n    oldSegmentGroup: UrlSegmentGroup, newSegmentGroup: UrlSegmentGroup, urlTree: UrlTree,\n    queryParams: Params, fragment: string): UrlTree {\n  let qp: any = {};\n  if (queryParams) {\n    forEach(queryParams, (value: any, name: any) => {\n      qp[name] = Array.isArray(value) ? value.map((v: any) => `${v}`) : `${value}`;\n    });\n  }\n\n  if (urlTree.root === oldSegmentGroup) {\n    return new UrlTree(newSegmentGroup, qp, fragment);\n  }\n\n  return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);\n}\n\nfunction replaceSegment(\n    current: UrlSegmentGroup, oldSegment: UrlSegmentGroup,\n    newSegment: UrlSegmentGroup): UrlSegmentGroup {\n  const children: {[key: string]: UrlSegmentGroup} = {};\n  forEach(current.children, (c: UrlSegmentGroup, outletName: string) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\n\nclass Navigation {\n  constructor(\n      public isAbsolute: boolean, public numberOfDoubleDots: number, public commands: any[]) {\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new Error('Root segment cannot have matrix parameters');\n    }\n\n    const cmdWithOutlet = commands.find(c => typeof c === 'object' && c != null && c.outlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new Error('{outlets:{}} has to be the last command');\n    }\n  }\n\n  public toRoot(): boolean {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\n\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands: any[]): Navigation {\n  if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n\n  const res: any[] = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets: {[k: string]: any} = {};\n        forEach(cmd.outlets, (commands: any, name: string) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {outlets}];\n      }\n\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') {\n          // skip './a'\n        } else if (partIndex == 0 && urlPart === '') {  //  '/a'\n          isAbsolute = true;\n        } else if (urlPart === '..') {  //  '../a'\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n\n      return res;\n    }\n\n    return [...res, cmd];\n  }, []);\n\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\n\nclass Position {\n  constructor(\n      public segmentGroup: UrlSegmentGroup, public processChildren: boolean, public index: number) {\n  }\n}\n\nfunction findStartingPosition(nav: Navigation, tree: UrlTree, route: ActivatedRoute): Position {\n  if (nav.isAbsolute) {\n    return new Position(tree.root, true, 0);\n  }\n\n  if (route.snapshot._lastPathIndex === -1) {\n    return new Position(route.snapshot._urlSegment, true, 0);\n  }\n\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = route.snapshot._lastPathIndex + modifier;\n  return createPositionApplyingDoubleDots(\n      route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\n}\n\nfunction createPositionApplyingDoubleDots(\n    group: UrlSegmentGroup, index: number, numberOfDoubleDots: number): Position {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent !;\n    if (!g) {\n      throw new Error('Invalid number of \\'../\\'');\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\n\nfunction getPath(command: any): any {\n  if (typeof command === 'object' && command != null && command.outlets) {\n    return command.outlets[PRIMARY_OUTLET];\n  }\n  return `${command}`;\n}\n\nfunction getOutlets(commands: any[]): {[k: string]: any[]} {\n  if (!(typeof commands[0] === 'object')) return {[PRIMARY_OUTLET]: commands};\n  if (commands[0].outlets === undefined) return {[PRIMARY_OUTLET]: commands};\n  return commands[0].outlets;\n}\n\nfunction updateSegmentGroup(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  if (!segmentGroup) {\n    segmentGroup = new UrlSegmentGroup([], {});\n  }\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] =\n        new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\n\nfunction updateSegmentGroupChildren(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children: {[key: string]: UrlSegmentGroup} = {};\n\n    forEach(outlets, (commands: any, outlet: string) => {\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n\n    forEach(segmentGroup.children, (child: UrlSegmentGroup, childOutlet: string) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\n\nfunction prefixedWith(segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n\n  const noMatch = {match: false, pathIndex: 0, commandIndex: 0};\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const curr = getPath(commands[currentCommandIndex]);\n    const next =\n        currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n\n    if (currentPathIndex > 0 && curr === undefined) break;\n\n    if (curr && next && (typeof next === 'object') && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n\n  return {match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex};\n}\n\nfunction createNewSegmentGroup(\n    segmentGroup: UrlSegmentGroup, startIndex: number, commands: any[]): UrlSegmentGroup {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n\n  let i = 0;\n  while (i < commands.length) {\n    if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {\n      const children = createNewSegmentChildren(commands[i].outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n\n    // if we start with an object literal, we need to reuse the path part from the segment\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, commands[0]));\n      i++;\n      continue;\n    }\n\n    const curr = getPath(commands[i]);\n    const next = (i < commands.length - 1) ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\n\nfunction createNewSegmentChildren(outlets: {[name: string]: any}): any {\n  const children: {[key: string]: UrlSegmentGroup} = {};\n  forEach(outlets, (commands: any, outlet: string) => {\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\n\nfunction stringify(params: {[key: string]: any}): {[key: string]: string} {\n  const res: {[key: string]: string} = {};\n  forEach(params, (v: any, k: string) => res[k] = `${v}`);\n  return res;\n}\n\nfunction compare(path: string, params: {[key: string]: any}, segment: UrlSegment): boolean {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {LoadedRouterConfig} from '../config';\nimport {ActivationEnd, ChildActivationEnd, Event} from '../events';\nimport {DetachedRouteHandleInternal, RouteReuseStrategy} from '../route_reuse_strategy';\nimport {NavigationTransition} from '../router';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot, RouterState, advanceActivatedRoute} from '../router_state';\nimport {forEach} from '../utils/collection';\nimport {TreeNode, nodeChildrenAsMap} from '../utils/tree';\n\nexport const activateRoutes =\n    (rootContexts: ChildrenOutletContexts, routeReuseStrategy: RouteReuseStrategy,\n     forwardEvent: (evt: Event) => void): MonoTypeOperatorFunction<NavigationTransition> =>\n        map(t => {\n          new ActivateRoutes(\n              routeReuseStrategy, t.targetRouterState !, t.currentRouterState, forwardEvent)\n              .activate(rootContexts);\n          return t;\n        });\n\nexport class ActivateRoutes {\n  constructor(\n      private routeReuseStrategy: RouteReuseStrategy, private futureState: RouterState,\n      private currState: RouterState, private forwardEvent: (evt: Event) => void) {}\n\n  activate(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n\n  // De-activate the child route that are not re-used for the future state\n  private deactivateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach(futureChild => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n\n    // De-activate the routes that will not be re-used\n    forEach(children, (v: TreeNode<ActivatedRoute>, childName: string) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n\n  private deactivateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContext: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n\n  private detachAndStoreRouteSubtree(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});\n    }\n  }\n\n  private deactivateRouteAndOutlet(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n\n    if (context) {\n      const children: {[outletName: string]: any} = nodeChildrenAsMap(route);\n      const contexts = route.value.component ? context.children : parentContexts;\n\n      forEach(children, (v: any, k: string) => this.deactivateRouteAndItsChildren(v, contexts));\n\n      if (context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate();\n        // Destroy the contexts for all the outlets that were in the component\n        context.children.onOutletDeactivated();\n      }\n    }\n  }\n\n  private activateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outlet: string]: any} = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(c => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n\n  private activateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContexts: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    advanceActivatedRoute(future);\n\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored =\n              (<DetachedRouteHandleInternal>this.routeReuseStrategy.retrieve(future.snapshot));\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n          advanceActivatedRouteNodeAndItsChildren(stored.route);\n        } else {\n          const config = parentLoadedConfig(future.snapshot);\n          const cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n\n          context.attachRef = null;\n          context.route = future;\n          context.resolver = cmpFactoryResolver;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, cmpFactoryResolver);\n          }\n\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n  }\n}\n\nfunction advanceActivatedRouteNodeAndItsChildren(node: TreeNode<ActivatedRoute>): void {\n  advanceActivatedRoute(node.value);\n  node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n\nfunction parentLoadedConfig(snapshot: ActivatedRouteSnapshot): LoadedRouterConfig|null {\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n    if (route && route.component) return null;\n  }\n\n  return null;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CanActivate, CanActivateChild, CanDeactivate, CanLoad} from '../interfaces';\nimport {UrlTree} from '../url_tree';\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nexport function isFunction<T>(v: any): v is T {\n  return typeof v === 'function';\n}\n\nexport function isBoolean(v: any): v is boolean {\n  return typeof v === 'boolean';\n}\n\nexport function isUrlTree(v: any): v is UrlTree {\n  return v instanceof UrlTree;\n}\n\nexport function isCanLoad(guard: any): guard is CanLoad {\n  return guard && isFunction<CanLoad>(guard.canLoad);\n}\n\nexport function isCanActivate(guard: any): guard is CanActivate {\n  return guard && isFunction<CanActivate>(guard.canActivate);\n}\n\nexport function isCanActivateChild(guard: any): guard is CanActivateChild {\n  return guard && isFunction<CanActivateChild>(guard.canActivateChild);\n}\n\nexport function isCanDeactivate<T>(guard: any): guard is CanDeactivate<T> {\n  return guard && isFunction<CanDeactivate<T>>(guard.canDeactivate);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModuleRef} from '@angular/core';\nimport {EmptyError, Observable, Observer, from, of } from 'rxjs';\nimport {catchError, concatAll, every, first, map, mergeMap} from 'rxjs/operators';\n\nimport {LoadedRouterConfig, Route, Routes} from './config';\nimport {CanLoadFn} from './interfaces';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {PRIMARY_OUTLET, Params, defaultUrlMatcher, navigationCancelingError} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {forEach, waitForMap, wrapIntoObservable} from './utils/collection';\nimport {isCanLoad, isFunction} from './utils/type_guards';\n\nclass NoMatch {\n  public segmentGroup: UrlSegmentGroup|null;\n\n  constructor(segmentGroup?: UrlSegmentGroup) { this.segmentGroup = segmentGroup || null; }\n}\n\nclass AbsoluteRedirect {\n  constructor(public urlTree: UrlTree) {}\n}\n\nfunction noMatch(segmentGroup: UrlSegmentGroup): Observable<UrlSegmentGroup> {\n  return new Observable<UrlSegmentGroup>(\n      (obs: Observer<UrlSegmentGroup>) => obs.error(new NoMatch(segmentGroup)));\n}\n\nfunction absoluteRedirect(newTree: UrlTree): Observable<any> {\n  return new Observable<UrlSegmentGroup>(\n      (obs: Observer<UrlSegmentGroup>) => obs.error(new AbsoluteRedirect(newTree)));\n}\n\nfunction namedOutletsRedirect(redirectTo: string): Observable<any> {\n  return new Observable<UrlSegmentGroup>(\n      (obs: Observer<UrlSegmentGroup>) => obs.error(new Error(\n          `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`)));\n}\n\nfunction canLoadFails(route: Route): Observable<LoadedRouterConfig> {\n  return new Observable<LoadedRouterConfig>(\n      (obs: Observer<LoadedRouterConfig>) => obs.error(navigationCancelingError(\n          `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`)));\n}\n\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n */\nexport function applyRedirects(\n    moduleInjector: Injector, configLoader: RouterConfigLoader, urlSerializer: UrlSerializer,\n    urlTree: UrlTree, config: Routes): Observable<UrlTree> {\n  return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\n}\n\nclass ApplyRedirects {\n  private allowRedirects: boolean = true;\n  private ngModule: NgModuleRef<any>;\n\n  constructor(\n      moduleInjector: Injector, private configLoader: RouterConfigLoader,\n      private urlSerializer: UrlSerializer, private urlTree: UrlTree, private config: Routes) {\n    this.ngModule = moduleInjector.get(NgModuleRef);\n  }\n\n  apply(): Observable<UrlTree> {\n    const expanded$ =\n        this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n    const urlTrees$ = expanded$.pipe(\n        map((rootSegmentGroup: UrlSegmentGroup) => this.createUrlTree(\n                rootSegmentGroup, this.urlTree.queryParams, this.urlTree.fragment !)));\n    return urlTrees$.pipe(catchError((e: any) => {\n      if (e instanceof AbsoluteRedirect) {\n        // after an absolute redirect we do not apply any more redirects!\n        this.allowRedirects = false;\n        // we need to run matching, so we can fetch all lazy-loaded modules\n        return this.match(e.urlTree);\n      }\n\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n\n      throw e;\n    }));\n  }\n\n  private match(tree: UrlTree): Observable<UrlTree> {\n    const expanded$ =\n        this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n    const mapped$ = expanded$.pipe(\n        map((rootSegmentGroup: UrlSegmentGroup) =>\n                this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment !)));\n    return mapped$.pipe(catchError((e: any): Observable<UrlTree> => {\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n\n      throw e;\n    }));\n  }\n\n  private noMatchError(e: NoMatch): any {\n    return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`);\n  }\n\n  private createUrlTree(rootCandidate: UrlSegmentGroup, queryParams: Params, fragment: string):\n      UrlTree {\n    const root = rootCandidate.segments.length > 0 ?\n        new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate}) :\n        rootCandidate;\n    return new UrlTree(root, queryParams, fragment);\n  }\n\n  private expandSegmentGroup(\n      ngModule: NgModuleRef<any>, routes: Route[], segmentGroup: UrlSegmentGroup,\n      outlet: string): Observable<UrlSegmentGroup> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.expandChildren(ngModule, routes, segmentGroup)\n          .pipe(map((children: any) => new UrlSegmentGroup([], children)));\n    }\n\n    return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\n  }\n\n  // Recursively expand segment groups for all the child outlets\n  private expandChildren(\n      ngModule: NgModuleRef<any>, routes: Route[],\n      segmentGroup: UrlSegmentGroup): Observable<{[name: string]: UrlSegmentGroup}> {\n    return waitForMap(\n        segmentGroup.children,\n        (childOutlet, child) => this.expandSegmentGroup(ngModule, routes, child, childOutlet));\n  }\n\n  private expandSegment(\n      ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[],\n      segments: UrlSegment[], outlet: string,\n      allowRedirects: boolean): Observable<UrlSegmentGroup> {\n    return of (...routes).pipe(\n        map((r: any) => {\n          const expanded$ = this.expandSegmentAgainstRoute(\n              ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n          return expanded$.pipe(catchError((e: any) => {\n            if (e instanceof NoMatch) {\n              // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -\n              // talk to Jason\n              return of (null) as any;\n            }\n            throw e;\n          }));\n        }),\n        concatAll(), first((s: any) => !!s), catchError((e: any, _: any) => {\n          if (e instanceof EmptyError || e.name === 'EmptyError') {\n            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n              return of (new UrlSegmentGroup([], {}));\n            }\n            throw new NoMatch(segmentGroup);\n          }\n          throw e;\n        }));\n  }\n\n  private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n      boolean {\n    return segments.length === 0 && !segmentGroup.children[outlet];\n  }\n\n  private expandSegmentAgainstRoute(\n      ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      paths: UrlSegment[], outlet: string, allowRedirects: boolean): Observable<UrlSegmentGroup> {\n    if (getOutlet(route) !== outlet) {\n      return noMatch(segmentGroup);\n    }\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n    }\n\n    if (allowRedirects && this.allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n          ngModule, segmentGroup, routes, route, paths, outlet);\n    }\n\n    return noMatch(segmentGroup);\n  }\n\n  private expandSegmentAgainstRouteUsingRedirect(\n      ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n    if (route.path === '**') {\n      return this.expandWildCardWithParamsAgainstRouteUsingRedirect(\n          ngModule, routes, route, outlet);\n    }\n\n    return this.expandRegularSegmentAgainstRouteUsingRedirect(\n        ngModule, segmentGroup, routes, route, segments, outlet);\n  }\n\n  private expandWildCardWithParamsAgainstRouteUsingRedirect(\n      ngModule: NgModuleRef<any>, routes: Route[], route: Route,\n      outlet: string): Observable<UrlSegmentGroup> {\n    const newTree = this.applyRedirectCommands([], route.redirectTo !, {});\n    if (route.redirectTo !.startsWith('/')) {\n      return absoluteRedirect(newTree);\n    }\n\n    return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments: UrlSegment[]) => {\n      const group = new UrlSegmentGroup(newSegments, {});\n      return this.expandSegment(ngModule, group, routes, newSegments, outlet, false);\n    }));\n  }\n\n  private expandRegularSegmentAgainstRouteUsingRedirect(\n      ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n    const {matched, consumedSegments, lastChild, positionalParamSegments} =\n        match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n\n    const newTree = this.applyRedirectCommands(\n        consumedSegments, route.redirectTo !, <any>positionalParamSegments);\n    if (route.redirectTo !.startsWith('/')) {\n      return absoluteRedirect(newTree);\n    }\n\n    return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments: UrlSegment[]) => {\n      return this.expandSegment(\n          ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet,\n          false);\n    }));\n  }\n\n  private matchSegmentAgainstRoute(\n      ngModule: NgModuleRef<any>, rawSegmentGroup: UrlSegmentGroup, route: Route,\n      segments: UrlSegment[]): Observable<UrlSegmentGroup> {\n    if (route.path === '**') {\n      if (route.loadChildren) {\n        return this.configLoader.load(ngModule.injector, route)\n            .pipe(map((cfg: LoadedRouterConfig) => {\n              route._loadedConfig = cfg;\n              return new UrlSegmentGroup(segments, {});\n            }));\n      }\n\n      return of (new UrlSegmentGroup(segments, {}));\n    }\n\n    const {matched, consumedSegments, lastChild} = match(rawSegmentGroup, route, segments);\n    if (!matched) return noMatch(rawSegmentGroup);\n\n    const rawSlicedSegments = segments.slice(lastChild);\n    const childConfig$ = this.getChildConfig(ngModule, route, segments);\n\n    return childConfig$.pipe(mergeMap((routerConfig: LoadedRouterConfig) => {\n      const childModule = routerConfig.module;\n      const childConfig = routerConfig.routes;\n\n      const {segmentGroup, slicedSegments} =\n          split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig);\n\n      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n        const expanded$ = this.expandChildren(childModule, childConfig, segmentGroup);\n        return expanded$.pipe(\n            map((children: any) => new UrlSegmentGroup(consumedSegments, children)));\n      }\n\n      if (childConfig.length === 0 && slicedSegments.length === 0) {\n        return of (new UrlSegmentGroup(consumedSegments, {}));\n      }\n\n      const expanded$ = this.expandSegment(\n          childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n      return expanded$.pipe(\n          map((cs: UrlSegmentGroup) =>\n                  new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children)));\n    }));\n  }\n\n  private getChildConfig(ngModule: NgModuleRef<any>, route: Route, segments: UrlSegment[]):\n      Observable<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return of (new LoadedRouterConfig(route.children, ngModule));\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedConfig !== undefined) {\n        return of (route._loadedConfig);\n      }\n\n      return runCanLoadGuard(ngModule.injector, route, segments)\n          .pipe(mergeMap((shouldLoad: boolean) => {\n            if (shouldLoad) {\n              return this.configLoader.load(ngModule.injector, route)\n                  .pipe(map((cfg: LoadedRouterConfig) => {\n                    route._loadedConfig = cfg;\n                    return cfg;\n                  }));\n            }\n            return canLoadFails(route);\n          }));\n    }\n\n    return of (new LoadedRouterConfig([], ngModule));\n  }\n\n  private lineralizeSegments(route: Route, urlTree: UrlTree): Observable<UrlSegment[]> {\n    let res: UrlSegment[] = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of (res);\n      }\n\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(route.redirectTo !);\n      }\n\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n\n  private applyRedirectCommands(\n      segments: UrlSegment[], redirectTo: string, posParams: {[k: string]: UrlSegment}): UrlTree {\n    return this.applyRedirectCreatreUrlTree(\n        redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n  }\n\n  private applyRedirectCreatreUrlTree(\n      redirectTo: string, urlTree: UrlTree, segments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlTree {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(\n        newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),\n        urlTree.fragment);\n  }\n\n  private createQueryParams(redirectToParams: Params, actualParams: Params): Params {\n    const res: Params = {};\n    forEach(redirectToParams, (v: any, k: string) => {\n      const copySourceValue = typeof v === 'string' && v.startsWith(':');\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n\n  private createSegmentGroup(\n      redirectTo: string, group: UrlSegmentGroup, segments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlSegmentGroup {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\n    let children: {[n: string]: UrlSegmentGroup} = {};\n    forEach(group.children, (child: UrlSegmentGroup, name: string) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n\n  private createSegments(\n      redirectTo: string, redirectToSegments: UrlSegment[], actualSegments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlSegment[] {\n    return redirectToSegments.map(\n        s => s.path.startsWith(':') ? this.findPosParam(redirectTo, s, posParams) :\n                                      this.findOrReturn(s, actualSegments));\n  }\n\n  private findPosParam(\n      redirectTo: string, redirectToUrlSegment: UrlSegment,\n      posParams: {[k: string]: UrlSegment}): UrlSegment {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos)\n      throw new Error(\n          `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n\n  private findOrReturn(redirectToUrlSegment: UrlSegment, actualSegments: UrlSegment[]): UrlSegment {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\n\nfunction runCanLoadGuard(\n    moduleInjector: Injector, route: Route, segments: UrlSegment[]): Observable<boolean> {\n  const canLoad = route.canLoad;\n  if (!canLoad || canLoad.length === 0) return of (true);\n\n  const obs = from(canLoad).pipe(map((injectionToken: any) => {\n    const guard = moduleInjector.get(injectionToken);\n    let guardVal;\n    if (isCanLoad(guard)) {\n      guardVal = guard.canLoad(route, segments);\n    } else if (isFunction<CanLoadFn>(guard)) {\n      guardVal = guard(route, segments);\n    } else {\n      throw new Error('Invalid CanLoad guard');\n    }\n    return wrapIntoObservable(guardVal);\n  }));\n\n  return obs.pipe(concatAll(), every(result => result === true));\n}\n\nfunction match(segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): {\n  matched: boolean,\n  consumedSegments: UrlSegment[],\n  lastChild: number,\n  positionalParamSegments: {[k: string]: UrlSegment}\n} {\n  if (route.path === '') {\n    if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {}};\n    }\n\n    return {matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {}};\n  }\n\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n\n  if (!res) {\n    return {\n      matched: false,\n      consumedSegments: <any[]>[],\n      lastChild: 0,\n      positionalParamSegments: {},\n    };\n  }\n\n  return {\n    matched: true,\n    consumedSegments: res.consumed !,\n    lastChild: res.consumed.length !,\n    positionalParamSegments: res.posParams !,\n  };\n}\n\nfunction split(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n    config: Route[]) {\n  if (slicedSegments.length > 0 &&\n      containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        consumedSegments, createChildrenForEmptySegments(\n                              config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {segmentGroup: mergeTrivialChildren(s), slicedSegments: []};\n  }\n\n  if (slicedSegments.length === 0 &&\n      containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(\n                                   segmentGroup, slicedSegments, config, segmentGroup.children));\n    return {segmentGroup: mergeTrivialChildren(s), slicedSegments};\n  }\n\n  return {segmentGroup, slicedSegments};\n}\n\nfunction mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nfunction addEmptySegmentsToChildrenIfNeeded(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[],\n    children: {[name: string]: UrlSegmentGroup}): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  for (const r of routes) {\n    if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      res[getOutlet(r)] = new UrlSegmentGroup([], {});\n    }\n  }\n  return {...children, ...res};\n}\n\nfunction createChildrenForEmptySegments(\n    routes: Route[], primarySegmentGroup: UrlSegmentGroup): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  res[PRIMARY_OUTLET] = primarySegmentGroup;\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      res[getOutlet(r)] = new UrlSegmentGroup([], {});\n    }\n  }\n  return res;\n}\n\nfunction containsEmptyPathRedirectsWithNamedOutlets(\n    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(\n      r => isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\n\nfunction containsEmptyPathRedirects(\n    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(r => isEmptyPathRedirect(segmentGroup, segments, r));\n}\n\nfunction isEmptyPathRedirect(\n    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], r: Route): boolean {\n  if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo !== undefined;\n}\n\nfunction getOutlet(route: Route): string {\n  return route.outlet || PRIMARY_OUTLET;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\nimport {applyRedirects as applyRedirectsFn} from '../apply_redirects';\nimport {Routes} from '../config';\nimport {NavigationTransition} from '../router';\nimport {RouterConfigLoader} from '../router_config_loader';\nimport {UrlSerializer} from '../url_tree';\n\nexport function applyRedirects(\n    moduleInjector: Injector, configLoader: RouterConfigLoader, urlSerializer: UrlSerializer,\n    config: Routes): MonoTypeOperatorFunction<NavigationTransition> {\n  return function(source: Observable<NavigationTransition>) {\n    return source.pipe(switchMap(\n        t => applyRedirectsFn(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config)\n                 .pipe(map(urlAfterRedirects => ({...t, urlAfterRedirects})))));\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\n\nimport {LoadedRouterConfig, RunGuardsAndResolvers} from '../config';\nimport {ChildrenOutletContexts, OutletContext} from '../router_outlet_context';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot, equalParamsAndUrlSegments} from '../router_state';\nimport {equalPath} from '../url_tree';\nimport {forEach, shallowEqual} from '../utils/collection';\nimport {TreeNode, nodeChildrenAsMap} from '../utils/tree';\n\nexport class CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nexport class CanDeactivate {\n  constructor(public component: Object|null, public route: ActivatedRouteSnapshot) {}\n}\n\nexport declare type Checks = {\n  canDeactivateChecks: CanDeactivate[],\n  canActivateChecks: CanActivate[],\n};\n\nexport function getAllRouteGuards(\n    future: RouterStateSnapshot, curr: RouterStateSnapshot,\n    parentContexts: ChildrenOutletContexts) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\n\nexport function getCanActivateChild(p: ActivatedRouteSnapshot):\n    {node: ActivatedRouteSnapshot, guards: any[]}|null {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {node: p, guards: canActivateChild};\n}\n\nexport function getToken(\n    token: any, snapshot: ActivatedRouteSnapshot, moduleInjector: Injector): any {\n  const config = getClosestLoadedConfig(snapshot);\n  const injector = config ? config.module.injector : moduleInjector;\n  return injector.get(token);\n}\n\nfunction getClosestLoadedConfig(snapshot: ActivatedRouteSnapshot): LoadedRouterConfig|null {\n  if (!snapshot) return null;\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n  }\n\n  return null;\n}\n\nfunction getChildRouteGuards(\n    futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>| null,\n    contexts: ChildrenOutletContexts | null, futurePath: ActivatedRouteSnapshot[],\n    checks: Checks = {\n      canDeactivateChecks: [],\n      canActivateChecks: []\n    }): Checks {\n  const prevChildren = nodeChildrenAsMap(currNode);\n\n  // Process the children of the future route\n  futureNode.children.forEach(c => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n\n  // Process any children left from the current route (not active for the future route)\n  forEach(\n      prevChildren, (v: TreeNode<ActivatedRouteSnapshot>, k: string) =>\n                        deactivateRouteAndItsChildren(v, contexts !.getContext(k), checks));\n\n  return checks;\n}\n\nfunction getRouteGuards(\n    futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>,\n    parentContexts: ChildrenOutletContexts | null, futurePath: ActivatedRouteSnapshot[],\n    checks: Checks = {\n      canDeactivateChecks: [],\n      canActivateChecks: []\n    }): Checks {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n  // reusing the node\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun =\n        shouldRunGuardsAndResolvers(curr, future, future.routeConfig !.runGuardsAndResolvers);\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      // we need to set the data\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(\n          futureNode, currNode, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n\n    if (shouldRun) {\n      const component = context && context.outlet && context.outlet.component || null;\n      checks.canDeactivateChecks.push(new CanDeactivate(component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    // If we have a component, we need to go through an outlet.\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n\n      // if we have a componentless route, we recurse but keep the same outlet map.\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n\n  return checks;\n}\n\nfunction shouldRunGuardsAndResolvers(\n    curr: ActivatedRouteSnapshot, future: ActivatedRouteSnapshot,\n    mode: RunGuardsAndResolvers | undefined): boolean {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n\n    case 'pathParamsOrQueryParamsChange':\n      return !equalPath(curr.url, future.url) ||\n          !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'always':\n      return true;\n\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) ||\n          !shallowEqual(curr.queryParams, future.queryParams);\n\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\n\nfunction deactivateRouteAndItsChildren(\n    route: TreeNode<ActivatedRouteSnapshot>, context: OutletContext | null, checks: Checks): void {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n\n  forEach(children, (node: TreeNode<ActivatedRouteSnapshot>, childName: string) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable, OperatorFunction, combineLatest} from 'rxjs';\nimport {filter, map, scan, startWith, switchMap, take} from 'rxjs/operators';\n\nimport {UrlTree} from '../url_tree';\nimport {isUrlTree} from '../utils/type_guards';\n\nconst INITIAL_VALUE = Symbol('INITIAL_VALUE');\ndeclare type INTERIM_VALUES = typeof INITIAL_VALUE | boolean | UrlTree;\n\nexport function prioritizedGuardValue():\n    OperatorFunction<Observable<boolean|UrlTree>[], boolean|UrlTree> {\n  return switchMap(obs => {\n    return combineLatest(\n               ...obs.map(o => o.pipe(take(1), startWith(INITIAL_VALUE as INTERIM_VALUES))))\n        .pipe(\n            scan(\n                (acc: INTERIM_VALUES, list: INTERIM_VALUES[]) => {\n                  let isPending = false;\n                  return list.reduce((innerAcc, val, i: number) => {\n                    if (innerAcc !== INITIAL_VALUE) return innerAcc;\n\n                    // Toggle pending flag if any values haven't been set yet\n                    if (val === INITIAL_VALUE) isPending = true;\n\n                    // Any other return values are only valid if we haven't yet hit a pending call.\n                    // This guarantees that in the case of a guard at the bottom of the tree that\n                    // returns a redirect, we will wait for the higher priority guard at the top to\n                    // finish before performing the redirect.\n                    if (!isPending) {\n                      // Early return when we hit a `false` value as that should always cancel\n                      // navigation\n                      if (val === false) return val;\n\n                      if (i === list.length - 1 || isUrlTree(val)) {\n                        return val;\n                      }\n                    }\n\n                    return innerAcc;\n                  }, acc);\n                },\n                INITIAL_VALUE),\n            filter(item => item !== INITIAL_VALUE),\n            map(item => isUrlTree(item) ? item : item === true),  //\n            take(1)) as Observable<boolean|UrlTree>;\n  });\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable, defer, from, of } from 'rxjs';\nimport {concatAll, concatMap, first, map, mergeMap} from 'rxjs/operators';\n\nimport {ActivationStart, ChildActivationStart, Event} from '../events';\nimport {CanActivateChildFn, CanActivateFn, CanDeactivateFn} from '../interfaces';\nimport {NavigationTransition} from '../router';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from '../router_state';\nimport {UrlTree} from '../url_tree';\nimport {wrapIntoObservable} from '../utils/collection';\nimport {CanActivate, CanDeactivate, getCanActivateChild, getToken} from '../utils/preactivation';\nimport {isBoolean, isCanActivate, isCanActivateChild, isCanDeactivate, isFunction} from '../utils/type_guards';\n\nimport {prioritizedGuardValue} from './prioritized_guard_value';\n\nexport function checkGuards(moduleInjector: Injector, forwardEvent?: (evt: Event) => void):\n    MonoTypeOperatorFunction<NavigationTransition> {\n  return function(source: Observable<NavigationTransition>) {\n\n    return source.pipe(mergeMap(t => {\n      const {targetSnapshot, currentSnapshot, guards: {canActivateChecks, canDeactivateChecks}} = t;\n      if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n        return of ({...t, guardsResult: true});\n      }\n\n      return runCanDeactivateChecks(\n                 canDeactivateChecks, targetSnapshot !, currentSnapshot, moduleInjector)\n          .pipe(\n              mergeMap(canDeactivate => {\n                return canDeactivate && isBoolean(canDeactivate) ?\n                    runCanActivateChecks(\n                        targetSnapshot !, canActivateChecks, moduleInjector, forwardEvent) :\n                    of (canDeactivate);\n              }),\n              map(guardsResult => ({...t, guardsResult})));\n    }));\n  };\n}\n\nfunction runCanDeactivateChecks(\n    checks: CanDeactivate[], futureRSS: RouterStateSnapshot, currRSS: RouterStateSnapshot,\n    moduleInjector: Injector) {\n  return from(checks).pipe(\n      mergeMap(\n          check =>\n              runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector)),\n      first(result => { return result !== true; }, true as boolean | UrlTree));\n}\n\nfunction runCanActivateChecks(\n    futureSnapshot: RouterStateSnapshot, checks: CanActivate[], moduleInjector: Injector,\n    forwardEvent?: (evt: Event) => void) {\n  return from(checks).pipe(\n      concatMap((check: CanActivate) => {\n        return from([\n                 fireChildActivationStart(check.route.parent, forwardEvent),\n                 fireActivationStart(check.route, forwardEvent),\n                 runCanActivateChild(futureSnapshot, check.path, moduleInjector),\n                 runCanActivate(futureSnapshot, check.route, moduleInjector)\n               ])\n            .pipe(concatAll(), first(result => {\n                    return result !== true;\n                  }, true as boolean | UrlTree));\n      }),\n      first(result => { return result !== true; }, true as boolean | UrlTree));\n}\n\n/**\n   * This should fire off `ActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\nfunction fireActivationStart(\n    snapshot: ActivatedRouteSnapshot | null,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of (true);\n}\n\n/**\n   * This should fire off `ChildActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\nfunction fireChildActivationStart(\n    snapshot: ActivatedRouteSnapshot | null,\n    forwardEvent?: (evt: Event) => void): Observable<boolean> {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of (true);\n}\n\nfunction runCanActivate(\n    futureRSS: RouterStateSnapshot, futureARS: ActivatedRouteSnapshot,\n    moduleInjector: Injector): Observable<boolean|UrlTree> {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of (true);\n\n  const canActivateObservables = canActivate.map((c: any) => {\n    return defer(() => {\n      const guard = getToken(c, futureARS, moduleInjector);\n      let observable;\n      if (isCanActivate(guard)) {\n        observable = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));\n      } else if (isFunction<CanActivateFn>(guard)) {\n        observable = wrapIntoObservable(guard(futureARS, futureRSS));\n      } else {\n        throw new Error('Invalid CanActivate guard');\n      }\n      return observable.pipe(first());\n    });\n  });\n  return of (canActivateObservables).pipe(prioritizedGuardValue());\n}\n\nfunction runCanActivateChild(\n    futureRSS: RouterStateSnapshot, path: ActivatedRouteSnapshot[],\n    moduleInjector: Injector): Observable<boolean|UrlTree> {\n  const futureARS = path[path.length - 1];\n\n  const canActivateChildGuards = path.slice(0, path.length - 1)\n                                     .reverse()\n                                     .map(p => getCanActivateChild(p))\n                                     .filter(_ => _ !== null);\n\n  const canActivateChildGuardsMapped = canActivateChildGuards.map((d: any) => {\n    return defer(() => {\n      const guardsMapped = d.guards.map((c: any) => {\n        const guard = getToken(c, d.node, moduleInjector);\n        let observable;\n        if (isCanActivateChild(guard)) {\n          observable = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));\n        } else if (isFunction<CanActivateChildFn>(guard)) {\n          observable = wrapIntoObservable(guard(futureARS, futureRSS));\n        } else {\n          throw new Error('Invalid CanActivateChild guard');\n        }\n        return observable.pipe(first());\n      });\n      return of (guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of (canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\n\nfunction runCanDeactivate(\n    component: Object | null, currARS: ActivatedRouteSnapshot, currRSS: RouterStateSnapshot,\n    futureRSS: RouterStateSnapshot, moduleInjector: Injector): Observable<boolean|UrlTree> {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of (true);\n  const canDeactivateObservables = canDeactivate.map((c: any) => {\n    const guard = getToken(c, currARS, moduleInjector);\n    let observable;\n    if (isCanDeactivate(guard)) {\n      observable =\n          wrapIntoObservable(guard.canDeactivate(component !, currARS, currRSS, futureRSS));\n    } else if (isFunction<CanDeactivateFn<any>>(guard)) {\n      observable = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));\n    } else {\n      throw new Error('Invalid CanDeactivate guard');\n    }\n    return observable.pipe(first());\n  });\n  return of (canDeactivateObservables).pipe(prioritizedGuardValue());\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\nimport {Observable, Observer, of } from 'rxjs';\n\nimport {Data, ResolveData, Route, Routes} from './config';\nimport {ActivatedRouteSnapshot, ParamsInheritanceStrategy, RouterStateSnapshot, inheritedParamsDataResolve} from './router_state';\nimport {PRIMARY_OUTLET, defaultUrlMatcher} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlTree, mapChildrenIntoArray} from './url_tree';\nimport {forEach, last} from './utils/collection';\nimport {TreeNode} from './utils/tree';\n\nclass NoMatch {}\n\nexport function recognize(\n    rootComponentType: Type<any>| null, config: Routes, urlTree: UrlTree, url: string,\n    paramsInheritanceStrategy: ParamsInheritanceStrategy = 'emptyOnly',\n    relativeLinkResolution: 'legacy' | 'corrected' = 'legacy'): Observable<RouterStateSnapshot> {\n  return new Recognizer(\n             rootComponentType, config, urlTree, url, paramsInheritanceStrategy,\n             relativeLinkResolution)\n      .recognize();\n}\n\nclass Recognizer {\n  constructor(\n      private rootComponentType: Type<any>|null, private config: Routes, private urlTree: UrlTree,\n      private url: string, private paramsInheritanceStrategy: ParamsInheritanceStrategy,\n      private relativeLinkResolution: 'legacy'|'corrected') {}\n\n  recognize(): Observable<RouterStateSnapshot> {\n    try {\n      const rootSegmentGroup =\n          split(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\n\n      const children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n\n      const root = new ActivatedRouteSnapshot(\n          [], Object.freeze({}), Object.freeze({...this.urlTree.queryParams}),\n          this.urlTree.fragment !, {}, PRIMARY_OUTLET, this.rootComponentType, null,\n          this.urlTree.root, -1, {});\n\n      const rootNode = new TreeNode<ActivatedRouteSnapshot>(root, children);\n      const routeState = new RouterStateSnapshot(this.url, rootNode);\n      this.inheritParamsAndData(routeState._root);\n      return of (routeState);\n\n    } catch (e) {\n      return new Observable<RouterStateSnapshot>(\n          (obs: Observer<RouterStateSnapshot>) => obs.error(e));\n    }\n  }\n\n  inheritParamsAndData(routeNode: TreeNode<ActivatedRouteSnapshot>): void {\n    const route = routeNode.value;\n\n    const i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);\n    route.params = Object.freeze(i.params);\n    route.data = Object.freeze(i.data);\n\n    routeNode.children.forEach(n => this.inheritParamsAndData(n));\n  }\n\n  processSegmentGroup(config: Route[], segmentGroup: UrlSegmentGroup, outlet: string):\n      TreeNode<ActivatedRouteSnapshot>[] {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(config, segmentGroup);\n    }\n\n    return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n  }\n\n  processChildren(config: Route[], segmentGroup: UrlSegmentGroup):\n      TreeNode<ActivatedRouteSnapshot>[] {\n    const children = mapChildrenIntoArray(\n        segmentGroup, (child, childOutlet) => this.processSegmentGroup(config, child, childOutlet));\n    checkOutletNameUniqueness(children);\n    sortActivatedRouteSnapshots(children);\n    return children;\n  }\n\n  processSegment(\n      config: Route[], segmentGroup: UrlSegmentGroup, segments: UrlSegment[],\n      outlet: string): TreeNode<ActivatedRouteSnapshot>[] {\n    for (const r of config) {\n      try {\n        return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n      } catch (e) {\n        if (!(e instanceof NoMatch)) throw e;\n      }\n    }\n    if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n      return [];\n    }\n\n    throw new NoMatch();\n  }\n\n  private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n      boolean {\n    return segments.length === 0 && !segmentGroup.children[outlet];\n  }\n\n  processSegmentAgainstRoute(\n      route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[],\n      outlet: string): TreeNode<ActivatedRouteSnapshot>[] {\n    if (route.redirectTo) throw new NoMatch();\n\n    if ((route.outlet || PRIMARY_OUTLET) !== outlet) throw new NoMatch();\n\n    let snapshot: ActivatedRouteSnapshot;\n    let consumedSegments: UrlSegment[] = [];\n    let rawSlicedSegments: UrlSegment[] = [];\n\n    if (route.path === '**') {\n      const params = segments.length > 0 ? last(segments) !.parameters : {};\n      snapshot = new ActivatedRouteSnapshot(\n          segments, params, Object.freeze({...this.urlTree.queryParams}), this.urlTree.fragment !,\n          getData(route), outlet, route.component !, route, getSourceSegmentGroup(rawSegment),\n          getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n    } else {\n      const result: MatchResult = match(rawSegment, route, segments);\n      consumedSegments = result.consumedSegments;\n      rawSlicedSegments = segments.slice(result.lastChild);\n\n      snapshot = new ActivatedRouteSnapshot(\n          consumedSegments, result.parameters, Object.freeze({...this.urlTree.queryParams}),\n          this.urlTree.fragment !, getData(route), outlet, route.component !, route,\n          getSourceSegmentGroup(rawSegment),\n          getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n    }\n\n    const childConfig: Route[] = getChildConfig(route);\n\n    const {segmentGroup, slicedSegments} = split(\n        rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution);\n\n    if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n      const children = this.processChildren(childConfig, segmentGroup);\n      return [new TreeNode<ActivatedRouteSnapshot>(snapshot, children)];\n    }\n\n    if (childConfig.length === 0 && slicedSegments.length === 0) {\n      return [new TreeNode<ActivatedRouteSnapshot>(snapshot, [])];\n    }\n\n    const children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n    return [new TreeNode<ActivatedRouteSnapshot>(snapshot, children)];\n  }\n}\n\nfunction sortActivatedRouteSnapshots(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\n\nfunction getChildConfig(route: Route): Route[] {\n  if (route.children) {\n    return route.children;\n  }\n\n  if (route.loadChildren) {\n    return route._loadedConfig !.routes;\n  }\n\n  return [];\n}\n\ninterface MatchResult {\n  consumedSegments: UrlSegment[];\n  lastChild: number;\n  parameters: any;\n}\n\nfunction match(segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): MatchResult {\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      throw new NoMatch();\n    }\n\n    return {consumedSegments: [], lastChild: 0, parameters: {}};\n  }\n\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) throw new NoMatch();\n\n  const posParams: {[n: string]: string} = {};\n  forEach(res.posParams !, (v: UrlSegment, k: string) => { posParams[k] = v.path; });\n  const parameters = res.consumed.length > 0 ?\n      {...posParams, ...res.consumed[res.consumed.length - 1].parameters} :\n      posParams;\n\n  return {consumedSegments: res.consumed, lastChild: res.consumed.length, parameters};\n}\n\nfunction checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n  const names: {[k: string]: ActivatedRouteSnapshot} = {};\n  nodes.forEach(n => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');\n      const c = n.value.url.map(s => s.toString()).join('/');\n      throw new Error(`Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\n\nfunction getSourceSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n  let s = segmentGroup;\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n  }\n  return s;\n}\n\nfunction getPathIndexShift(segmentGroup: UrlSegmentGroup): number {\n  let s = segmentGroup;\n  let res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\n  while (s._sourceSegment) {\n    s = s._sourceSegment;\n    res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\n  }\n  return res - 1;\n}\n\nfunction split(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n    config: Route[], relativeLinkResolution: 'legacy' | 'corrected') {\n  if (slicedSegments.length > 0 &&\n      containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        consumedSegments, createChildrenForEmptyPaths(\n                              segmentGroup, consumedSegments, config,\n                              new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    s._sourceSegment = segmentGroup;\n    s._segmentIndexShift = consumedSegments.length;\n    return {segmentGroup: s, slicedSegments: []};\n  }\n\n  if (slicedSegments.length === 0 &&\n      containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(\n                                   segmentGroup, consumedSegments, slicedSegments, config,\n                                   segmentGroup.children, relativeLinkResolution));\n    s._sourceSegment = segmentGroup;\n    s._segmentIndexShift = consumedSegments.length;\n    return {segmentGroup: s, slicedSegments};\n  }\n\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  s._sourceSegment = segmentGroup;\n  s._segmentIndexShift = consumedSegments.length;\n  return {segmentGroup: s, slicedSegments};\n}\n\nfunction addEmptyPathsToChildrenIfNeeded(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n    routes: Route[], children: {[name: string]: UrlSegmentGroup},\n    relativeLinkResolution: 'legacy' | 'corrected'): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      s._sourceSegment = segmentGroup;\n      if (relativeLinkResolution === 'legacy') {\n        s._segmentIndexShift = segmentGroup.segments.length;\n      } else {\n        s._segmentIndexShift = consumedSegments.length;\n      }\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {...children, ...res};\n}\n\nfunction createChildrenForEmptyPaths(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], routes: Route[],\n    primarySegment: UrlSegmentGroup): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  primarySegment._sourceSegment = segmentGroup;\n  primarySegment._segmentIndexShift = consumedSegments.length;\n\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      s._sourceSegment = segmentGroup;\n      s._segmentIndexShift = consumedSegments.length;\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\n\nfunction containsEmptyPathMatchesWithNamedOutlets(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(\n      r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\n\nfunction containsEmptyPathMatches(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\n\nfunction emptyPathMatch(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], r: Route): boolean {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo === undefined;\n}\n\nfunction getOutlet(route: Route): string {\n  return route.outlet || PRIMARY_OUTLET;\n}\n\nfunction getData(route: Route): Data {\n  return route.data || {};\n}\n\nfunction getResolve(route: Route): ResolveData {\n  return route.resolve || {};\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {map, mergeMap} from 'rxjs/operators';\n\nimport {Route} from '../config';\nimport {recognize as recognizeFn} from '../recognize';\nimport {NavigationTransition} from '../router';\nimport {UrlTree} from '../url_tree';\n\nexport function recognize(\n    rootComponentType: Type<any>| null, config: Route[], serializer: (url: UrlTree) => string,\n    paramsInheritanceStrategy: 'emptyOnly' | 'always', relativeLinkResolution: 'legacy' |\n        'corrected'): MonoTypeOperatorFunction<NavigationTransition> {\n  return function(source: Observable<NavigationTransition>) {\n    return source.pipe(mergeMap(\n        t => recognizeFn(\n                 rootComponentType, config, t.urlAfterRedirects, serializer(t.urlAfterRedirects),\n                 paramsInheritanceStrategy, relativeLinkResolution)\n                 .pipe(map(targetSnapshot => ({...t, targetSnapshot})))));\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable, from, of } from 'rxjs';\nimport {concatMap, last, map, mergeMap, reduce} from 'rxjs/operators';\n\nimport {ResolveData} from '../config';\nimport {NavigationTransition} from '../router';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot, inheritedParamsDataResolve} from '../router_state';\nimport {wrapIntoObservable} from '../utils/collection';\n\nimport {getToken} from '../utils/preactivation';\n\nexport function resolveData(\n    paramsInheritanceStrategy: 'emptyOnly' | 'always',\n    moduleInjector: Injector): MonoTypeOperatorFunction<NavigationTransition> {\n  return function(source: Observable<NavigationTransition>) {\n    return source.pipe(mergeMap(t => {\n      const {targetSnapshot, guards: {canActivateChecks}} = t;\n\n      if (!canActivateChecks.length) {\n        return of (t);\n      }\n\n      return from(canActivateChecks)\n          .pipe(\n              concatMap(\n                  check => runResolve(\n                      check.route, targetSnapshot !, paramsInheritanceStrategy, moduleInjector)),\n              reduce((_: any, __: any) => _), map(_ => t));\n    }));\n  };\n}\n\nfunction runResolve(\n    futureARS: ActivatedRouteSnapshot, futureRSS: RouterStateSnapshot,\n    paramsInheritanceStrategy: 'emptyOnly' | 'always', moduleInjector: Injector) {\n  const resolve = futureARS._resolve;\n  return resolveNode(resolve, futureARS, futureRSS, moduleInjector)\n      .pipe(map((resolvedData: any) => {\n        futureARS._resolvedData = resolvedData;\n        futureARS.data = {\n            ...futureARS.data,\n            ...inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve};\n        return null;\n      }));\n}\n\nfunction resolveNode(\n    resolve: ResolveData, futureARS: ActivatedRouteSnapshot, futureRSS: RouterStateSnapshot,\n    moduleInjector: Injector): Observable<any> {\n  const keys = Object.keys(resolve);\n  if (keys.length === 0) {\n    return of ({});\n  }\n  if (keys.length === 1) {\n    const key = keys[0];\n    return getResolver(resolve[key], futureARS, futureRSS, moduleInjector)\n        .pipe(map((value: any) => { return {[key]: value}; }));\n  }\n  const data: {[k: string]: any} = {};\n  const runningResolvers$ = from(keys).pipe(mergeMap((key: string) => {\n    return getResolver(resolve[key], futureARS, futureRSS, moduleInjector)\n        .pipe(map((value: any) => {\n          data[key] = value;\n          return value;\n        }));\n  }));\n  return runningResolvers$.pipe(last(), map(() => data));\n}\n\nfunction getResolver(\n    injectionToken: any, futureARS: ActivatedRouteSnapshot, futureRSS: RouterStateSnapshot,\n    moduleInjector: Injector): Observable<any> {\n  const resolver = getToken(injectionToken, futureARS, moduleInjector);\n  return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) :\n                            wrapIntoObservable(resolver(futureARS, futureRSS));\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MonoTypeOperatorFunction, ObservableInput, from} from 'rxjs';\nimport {map, switchMap} from 'rxjs/operators';\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nexport function switchTap<T>(next: (x: T) => void|ObservableInput<any>):\n    MonoTypeOperatorFunction<T> {\n  return function(source) {\n    return source.pipe(switchMap(v => {\n      const nextResult = next(v);\n      if (nextResult) {\n        return from(nextResult).pipe(map(() => v));\n      }\n      return from([v]);\n    }));\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentRef} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>,\n  componentRef: ComponentRef<any>,\n  route: TreeNode<ActivatedRoute>,\n};\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle|null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\nexport class DefaultRouteReuseStrategy implements RouteReuseStrategy {\n  shouldDetach(route: ActivatedRouteSnapshot): boolean { return false; }\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n  shouldAttach(route: ActivatedRouteSnapshot): boolean { return false; }\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null { return null; }\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Compiler, InjectionToken, Injector, NgModuleFactory, NgModuleFactoryLoader} from '@angular/core';\nimport {Observable, from, of } from 'rxjs';\nimport {map, mergeMap} from 'rxjs/operators';\nimport {LoadChildren, LoadedRouterConfig, Route, standardizeConfig} from './config';\nimport {flatten, wrapIntoObservable} from './utils/collection';\n\n/**\n * The [DI token](guide/glossary/#di-token) for a router configuration.\n * @see `ROUTES`\n * @publicApi\n */\nexport const ROUTES = new InjectionToken<Route[][]>('ROUTES');\n\nexport class RouterConfigLoader {\n  constructor(\n      private loader: NgModuleFactoryLoader, private compiler: Compiler,\n      private onLoadStartListener?: (r: Route) => void,\n      private onLoadEndListener?: (r: Route) => void) {}\n\n  load(parentInjector: Injector, route: Route): Observable<LoadedRouterConfig> {\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n\n    const moduleFactory$ = this.loadModuleFactory(route.loadChildren !);\n\n    return moduleFactory$.pipe(map((factory: NgModuleFactory<any>) => {\n      if (this.onLoadEndListener) {\n        this.onLoadEndListener(route);\n      }\n\n      const module = factory.create(parentInjector);\n\n      return new LoadedRouterConfig(\n          flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);\n    }));\n  }\n\n  private loadModuleFactory(loadChildren: LoadChildren): Observable<NgModuleFactory<any>> {\n    if (typeof loadChildren === 'string') {\n      return from(this.loader.load(loadChildren));\n    } else {\n      return wrapIntoObservable(loadChildren()).pipe(mergeMap((t: any) => {\n        if (t instanceof NgModuleFactory) {\n          return of (t);\n        } else {\n          return from(this.compiler.compileModuleAsync(t));\n        }\n      }));\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {UrlTree} from './url_tree';\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\nexport abstract class UrlHandlingStrategy {\n  /**\n   * Tells the router if this URL should be processed.\n   *\n   * When it returns true, the router will execute the regular navigation.\n   * When it returns false, the router will set the router state to an empty state.\n   * As a result, all the active components will be destroyed.\n   *\n   */\n  abstract shouldProcessUrl(url: UrlTree): boolean;\n\n  /**\n   * Extracts the part of the URL that should be handled by the router.\n   * The rest of the URL will remain untouched.\n   */\n  abstract extract(url: UrlTree): UrlTree;\n\n  /**\n   * Merges the URL fragment with the rest of the URL.\n   */\n  abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * @publicApi\n */\nexport class DefaultUrlHandlingStrategy implements UrlHandlingStrategy {\n  shouldProcessUrl(url: UrlTree): boolean { return true; }\n  extract(url: UrlTree): UrlTree { return url; }\n  merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree { return newUrlPart; }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Location} from '@angular/common';\nimport {Compiler, Injector, NgModuleFactoryLoader, NgModuleRef, NgZone, Type, isDevMode, ÉµConsole as Console} from '@angular/core';\nimport {BehaviorSubject, EMPTY, Observable, Subject, Subscription, defer, of } from 'rxjs';\nimport {catchError, filter, finalize, map, switchMap, tap} from 'rxjs/operators';\n\nimport {QueryParamsHandling, Route, Routes, standardizeConfig, validateConfig} from './config';\nimport {createRouterState} from './create_router_state';\nimport {createUrlTree} from './create_url_tree';\nimport {Event, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, NavigationTrigger, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RoutesRecognized} from './events';\nimport {activateRoutes} from './operators/activate_routes';\nimport {applyRedirects} from './operators/apply_redirects';\nimport {checkGuards} from './operators/check_guards';\nimport {recognize} from './operators/recognize';\nimport {resolveData} from './operators/resolve_data';\nimport {switchTap} from './operators/switch_tap';\nimport {DefaultRouteReuseStrategy, RouteReuseStrategy} from './route_reuse_strategy';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {ActivatedRoute, RouterState, RouterStateSnapshot, createEmptyState} from './router_state';\nimport {Params, isNavigationCancelingError, navigationCancelingError} from './shared';\nimport {DefaultUrlHandlingStrategy, UrlHandlingStrategy} from './url_handling_strategy';\nimport {UrlSerializer, UrlTree, containsTree, createEmptyUrlTree} from './url_tree';\nimport {Checks, getAllRouteGuards} from './utils/preactivation';\nimport {isUrlTree} from './utils/type_guards';\n\n\n\n/**\n * @description\n *\n * Options that modify the navigation strategy.\n *\n * @publicApi\n */\nexport interface NavigationExtras {\n  /**\n   * Specifies a root URI to use for relative navigation.\n   *\n   * For example, consider the following route configuration where the parent route\n   * has two children.\n   *\n   * ```\n   * [{\n  *   path: 'parent',\n  *   component: ParentComponent,\n  *   children: [{\n  *     path: 'list',\n  *     component: ListComponent\n  *   },{\n  *     path: 'child',\n  *     component: ChildComponent\n  *   }]\n  * }]\n   * ```\n   *\n   * The following `go()` function navigates to the `list` route by\n   * interpreting the destination URI as relative to the activated `child`  route\n   *\n   * ```\n   *  @Component({...})\n   *  class ChildComponent {\n  *    constructor(private router: Router, private route: ActivatedRoute) {}\n  *\n  *    go() {\n  *      this.router.navigate(['../list'], { relativeTo: this.route });\n  *    }\n  *  }\n   * ```\n   */\n  relativeTo?: ActivatedRoute|null;\n\n  /**\n   * Sets query parameters to the URL.\n   *\n   * ```\n   * // Navigate to /results?page=1\n   * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n   * ```\n   */\n  queryParams?: Params|null;\n\n  /**\n   * Sets the hash fragment for the URL.\n   *\n   * ```\n   * // Navigate to /results#top\n   * this.router.navigate(['/results'], { fragment: 'top' });\n   * ```\n   */\n  fragment?: string;\n\n  /**\n   * **DEPRECATED**: Use `queryParamsHandling: \"preserve\"` instead to preserve\n   * query parameters for the next navigation.\n   *\n   * @deprecated since v4\n   */\n  preserveQueryParams?: boolean;\n\n  /**\n   * How to handle query parameters in the router link for the next navigation.\n   * One of:\n   * * `merge` : Merge new with current parameters.\n   * * `preserve` : Preserve current parameters.\n   *\n   * ```\n   * // from /results?page=1 to /view?page=1&page=2\n   * this.router.navigate(['/view'], { queryParams: { page: 2 },  queryParamsHandling: \"merge\" });\n   * ```\n   */\n  queryParamsHandling?: QueryParamsHandling|null;\n  /**\n   * When true, preserves the URL fragment for the next navigation\n   *\n   * ```\n   * // Preserve fragment from /results#top to /view#top\n   * this.router.navigate(['/view'], { preserveFragment: true });\n   * ```\n   */\n  preserveFragment?: boolean;\n  /**\n   * When true, navigates without pushing a new state into history.\n   *\n   * ```\n   * // Navigate silently to /view\n   * this.router.navigate(['/view'], { skipLocationChange: true });\n   * ```\n   */\n  skipLocationChange?: boolean;\n  /**\n   * When true, navigates while replacing the current state in history.\n   *\n   * ```\n   * // Navigate to /view\n   * this.router.navigate(['/view'], { replaceUrl: true });\n   * ```\n   */\n  replaceUrl?: boolean;\n  /**\n   * Developer-defined state that can be passed to any navigation.\n   * Access this value through the `Navigation.extras` object\n   * returned from `router.getCurrentNavigation()` while a navigation is executing.\n   *\n   * After a navigation completes, the router writes an object containing this\n   * value together with a `navigationId` to `history.state`.\n   * The value is written when `location.go()` or `location.replaceState()`\n   * is called before activating this route.\n   *\n   * Note that `history.state` does not pass an object equality test because\n   * the router adds the `navigationId` on each navigation.\n   */\n  state?: {[k: string]: any};\n}\n\n/**\n * Error handler that is invoked when a navigation error occurs.\n *\n * If the handler returns a value, the navigation promise is resolved with this value.\n * If the handler throws an exception, the navigation promise is rejected with\n * the exception.\n *\n * @publicApi\n */\nexport type ErrorHandler = (error: any) => any;\n\nfunction defaultErrorHandler(error: any): any {\n  throw error;\n}\n\nfunction defaultMalformedUriErrorHandler(\n    error: URIError, urlSerializer: UrlSerializer, url: string): UrlTree {\n  return urlSerializer.parse('/');\n}\n\nexport type RestoredState = {\n  [k: string]: any; navigationId: number;\n};\n\n/**\n * Information about a navigation operation. Retrieve the most recent\n * navigation object with the `router.getCurrentNavigation()` method.\n *\n * @publicApi\n */\nexport type Navigation = {\n  /**\n   * The ID of the current navigation.\n   */\n  id: number;\n  /**\n   * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n   * the value before the router has parsed or applied redirects to it.\n   */\n  initialUrl: string | UrlTree;\n  /**\n   * The initial target URL after being parsed with `UrlSerializer.extract()`.\n   */\n  extractedUrl: UrlTree;\n  /**\n   * The extracted URL after redirects have been applied.\n   * This URL may not be available immediately, therefore this property can be `undefined`.\n   * It is guaranteed to be set after the `RoutesRecognized` event fires.\n   */\n  finalUrl?: UrlTree;\n  /**\n   * Identifies how this navigation was triggered.\n   *\n   * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n   * * 'popstate'--Triggered by a popstate event.\n   * * 'hashchange'--Triggered by a hashchange event.\n   */\n  trigger: 'imperative' | 'popstate' | 'hashchange';\n  /**\n   * Options that controlled the strategy used for this navigation.\n   * See `NavigationExtras`.\n   */\n  extras: NavigationExtras;\n  /**\n   * The previously successful `Navigation` object. Only one previous navigation\n   * is available, therefore this previous `Navigation` object has a `null` value\n   * for its own `previousNavigation`.\n   */\n  previousNavigation: Navigation | null;\n};\n\nexport type NavigationTransition = {\n  id: number,\n  currentUrlTree: UrlTree,\n  currentRawUrl: UrlTree,\n  extractedUrl: UrlTree,\n  urlAfterRedirects: UrlTree,\n  rawUrl: UrlTree,\n  extras: NavigationExtras,\n  resolve: any,\n  reject: any,\n  promise: Promise<boolean>,\n  source: NavigationTrigger,\n  restoredState: RestoredState | null,\n  currentSnapshot: RouterStateSnapshot,\n  targetSnapshot: RouterStateSnapshot | null,\n  currentRouterState: RouterState,\n  targetRouterState: RouterState | null,\n  guards: Checks,\n  guardsResult: boolean | UrlTree | null,\n};\n\n/**\n * @internal\n */\nexport type RouterHook = (snapshot: RouterStateSnapshot, runExtras: {\n  appliedUrlTree: UrlTree,\n  rawUrlTree: UrlTree,\n  skipLocationChange: boolean,\n  replaceUrl: boolean,\n  navigationId: number\n}) => Observable<void>;\n\n/**\n * @internal\n */\nfunction defaultRouterHook(snapshot: RouterStateSnapshot, runExtras: {\n  appliedUrlTree: UrlTree,\n  rawUrlTree: UrlTree,\n  skipLocationChange: boolean,\n  replaceUrl: boolean,\n  navigationId: number\n}): Observable<void> {\n  return of (null) as any;\n}\n\n/**\n * @description\n *\n * A service that provides navigation and URL manipulation capabilities.\n *\n * @see `Route`.\n * @see [Routing and Navigation Guide](guide/router).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport class Router {\n  private currentUrlTree: UrlTree;\n  private rawUrlTree: UrlTree;\n  private browserUrlTree: UrlTree;\n  private readonly transitions: BehaviorSubject<NavigationTransition>;\n  private navigations: Observable<NavigationTransition>;\n  private lastSuccessfulNavigation: Navigation|null = null;\n  private currentNavigation: Navigation|null = null;\n\n  // TODO(issue/24571): remove '!'.\n  private locationSubscription !: Subscription;\n  private navigationId: number = 0;\n  private configLoader: RouterConfigLoader;\n  private ngModule: NgModuleRef<any>;\n  private console: Console;\n  private isNgZoneEnabled: boolean = false;\n\n  /**\n   * An event stream for routing events in this NgModule.\n   */\n  public readonly events: Observable<Event> = new Subject<Event>();\n  /**\n   * The current state of routing in this NgModule.\n   */\n  public readonly routerState: RouterState;\n\n  /**\n   * A handler for navigation errors in this NgModule.\n   */\n  errorHandler: ErrorHandler = defaultErrorHandler;\n\n  /**\n   * A handler for errors thrown by `Router.parseUrl(url)`\n   * when `url` contains an invalid character.\n   * The most common case is a `%` sign\n   * that's not encoded and is not part of a percent encoded sequence.\n   */\n  malformedUriErrorHandler:\n      (error: URIError, urlSerializer: UrlSerializer,\n       url: string) => UrlTree = defaultMalformedUriErrorHandler;\n\n  /**\n   * True if at least one navigation event has occurred,\n   * false otherwise.\n   */\n  navigated: boolean = false;\n  private lastSuccessfulId: number = -1;\n\n  /**\n   * Hooks that enable you to pause navigation,\n   * either before or after the preactivation phase.\n   * Used by `RouterModule`.\n   *\n   * @internal\n   */\n  hooks: {beforePreactivation: RouterHook, afterPreactivation: RouterHook} = {\n    beforePreactivation: defaultRouterHook,\n    afterPreactivation: defaultRouterHook\n  };\n\n  /**\n   * A strategy for extracting and merging URLs.\n   * Used for AngularJS to Angular migrations.\n   */\n  urlHandlingStrategy: UrlHandlingStrategy = new DefaultUrlHandlingStrategy();\n\n  /**\n   * A strategy for re-using routes.\n   */\n  routeReuseStrategy: RouteReuseStrategy = new DefaultRouteReuseStrategy();\n\n  /**\n   * How to handle a navigation request to the current URL. One of:\n   * - `'ignore'` :  The router ignores the request.\n   * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\n   */\n  onSameUrlNavigation: 'reload'|'ignore' = 'ignore';\n\n  /**\n   * How to merge parameters, data, and resolved data from parent to child\n   * routes. One of:\n   *\n   * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\n   * for path-less or component-less routes.\n   * - `'always'` : Inherit parent parameters, data, and resolved data\n   * for all child routes.\n   */\n  paramsInheritanceStrategy: 'emptyOnly'|'always' = 'emptyOnly';\n\n  /**\n   * Determines when the router updates the browser URL.\n   * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\n   * Set to `'eager'` to update the browser URL at the beginning of navigation.\n   * You can choose to update early so that, if navigation fails,\n   * you can show an error message with the URL that failed.\n   */\n  urlUpdateStrategy: 'deferred'|'eager' = 'deferred';\n\n  /**\n   * Enables a bug fix that corrects relative link resolution in components with empty paths.\n   * @see `RouterModule`\n   */\n  relativeLinkResolution: 'legacy'|'corrected' = 'legacy';\n\n  /**\n   * Creates the router service.\n   */\n  // TODO: vsavkin make internal after the final is out.\n  constructor(\n      private rootComponentType: Type<any>|null, private urlSerializer: UrlSerializer,\n      private rootContexts: ChildrenOutletContexts, private location: Location, injector: Injector,\n      loader: NgModuleFactoryLoader, compiler: Compiler, public config: Routes) {\n    const onLoadStart = (r: Route) => this.triggerEvent(new RouteConfigLoadStart(r));\n    const onLoadEnd = (r: Route) => this.triggerEvent(new RouteConfigLoadEnd(r));\n\n    this.ngModule = injector.get(NgModuleRef);\n    this.console = injector.get(Console);\n    const ngZone = injector.get(NgZone);\n    this.isNgZoneEnabled = ngZone instanceof NgZone;\n\n    this.resetConfig(config);\n    this.currentUrlTree = createEmptyUrlTree();\n    this.rawUrlTree = this.currentUrlTree;\n    this.browserUrlTree = this.currentUrlTree;\n\n    this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\n    this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n\n    this.transitions = new BehaviorSubject<NavigationTransition>({\n      id: 0,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.currentUrlTree,\n      extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),\n      urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),\n      rawUrl: this.currentUrlTree,\n      extras: {},\n      resolve: null,\n      reject: null,\n      promise: Promise.resolve(true),\n      source: 'imperative',\n      restoredState: null,\n      currentSnapshot: this.routerState.snapshot,\n      targetSnapshot: null,\n      currentRouterState: this.routerState,\n      targetRouterState: null,\n      guards: {canActivateChecks: [], canDeactivateChecks: []},\n      guardsResult: null,\n    });\n    this.navigations = this.setupNavigations(this.transitions);\n\n    this.processNavigations();\n  }\n\n  private setupNavigations(transitions: Observable<NavigationTransition>):\n      Observable<NavigationTransition> {\n    const eventsSubject = (this.events as Subject<Event>);\n    return transitions.pipe(\n        filter(t => t.id !== 0),\n\n        // Extract URL\n        map(t => ({\n              ...t, extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl)\n            } as NavigationTransition)),\n\n        // Using switchMap so we cancel executing navigations when a new one comes in\n        switchMap(t => {\n          let completed = false;\n          let errored = false;\n          return of (t).pipe(\n              // Store the Navigation object\n              tap(t => {\n                this.currentNavigation = {\n                  id: t.id,\n                  initialUrl: t.currentRawUrl,\n                  extractedUrl: t.extractedUrl,\n                  trigger: t.source,\n                  extras: t.extras,\n                  previousNavigation: this.lastSuccessfulNavigation ?\n                      {...this.lastSuccessfulNavigation, previousNavigation: null} :\n                      null\n                };\n              }),\n              switchMap(t => {\n                const urlTransition =\n                    !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString();\n                const processCurrentUrl =\n                    (this.onSameUrlNavigation === 'reload' ? true : urlTransition) &&\n                    this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);\n\n                if (processCurrentUrl) {\n                  return of (t).pipe(\n                      // Fire NavigationStart event\n                      switchMap(t => {\n                        const transition = this.transitions.getValue();\n                        eventsSubject.next(new NavigationStart(\n                            t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState));\n                        if (transition !== this.transitions.getValue()) {\n                          return EMPTY;\n                        }\n                        return [t];\n                      }),\n\n                      // This delay is required to match old behavior that forced navigation to\n                      // always be async\n                      switchMap(t => Promise.resolve(t)),\n\n                      // ApplyRedirects\n                      applyRedirects(\n                          this.ngModule.injector, this.configLoader, this.urlSerializer,\n                          this.config),\n\n                      // Update the currentNavigation\n                      tap(t => {\n                        this.currentNavigation = {\n                          ...this.currentNavigation !,\n                          finalUrl: t.urlAfterRedirects\n                        };\n                      }),\n\n                      // Recognize\n                      recognize(\n                          this.rootComponentType, this.config, (url) => this.serializeUrl(url),\n                          this.paramsInheritanceStrategy, this.relativeLinkResolution),\n\n                      // Update URL if in `eager` update mode\n                      tap(t => {\n                        if (this.urlUpdateStrategy === 'eager') {\n                          if (!t.extras.skipLocationChange) {\n                            this.setBrowserUrl(\n                                t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state);\n                          }\n                          this.browserUrlTree = t.urlAfterRedirects;\n                        }\n                      }),\n\n                      // Fire RoutesRecognized\n                      tap(t => {\n                        const routesRecognized = new RoutesRecognized(\n                            t.id, this.serializeUrl(t.extractedUrl),\n                            this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot !);\n                        eventsSubject.next(routesRecognized);\n                      }));\n                } else {\n                  const processPreviousUrl = urlTransition && this.rawUrlTree &&\n                      this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree);\n                  /* When the current URL shouldn't be processed, but the previous one was, we\n                   * handle this \"error condition\" by navigating to the previously successful URL,\n                   * but leaving the URL intact.*/\n                  if (processPreviousUrl) {\n                    const {id, extractedUrl, source, restoredState, extras} = t;\n                    const navStart = new NavigationStart(\n                        id, this.serializeUrl(extractedUrl), source, restoredState);\n                    eventsSubject.next(navStart);\n                    const targetSnapshot =\n                        createEmptyState(extractedUrl, this.rootComponentType).snapshot;\n\n                    return of ({\n                      ...t,\n                      targetSnapshot,\n                      urlAfterRedirects: extractedUrl,\n                      extras: {...extras, skipLocationChange: false, replaceUrl: false},\n                    });\n                  } else {\n                    /* When neither the current or previous URL can be processed, do nothing other\n                     * than update router's internal reference to the current \"settled\" URL. This\n                     * way the next navigation will be coming from the current URL in the browser.\n                     */\n                    this.rawUrlTree = t.rawUrl;\n                    this.browserUrlTree = t.urlAfterRedirects;\n                    t.resolve(null);\n                    return EMPTY;\n                  }\n                }\n              }),\n\n              // Before Preactivation\n              switchTap(t => {\n                const {\n                  targetSnapshot,\n                  id: navigationId,\n                  extractedUrl: appliedUrlTree,\n                  rawUrl: rawUrlTree,\n                  extras: {skipLocationChange, replaceUrl}\n                } = t;\n                return this.hooks.beforePreactivation(targetSnapshot !, {\n                  navigationId,\n                  appliedUrlTree,\n                  rawUrlTree,\n                  skipLocationChange: !!skipLocationChange,\n                  replaceUrl: !!replaceUrl,\n                });\n              }),\n\n              // --- GUARDS ---\n              tap(t => {\n                const guardsStart = new GuardsCheckStart(\n                    t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects),\n                    t.targetSnapshot !);\n                this.triggerEvent(guardsStart);\n              }),\n\n              map(t => ({\n                    ...t,\n                    guards:\n                        getAllRouteGuards(t.targetSnapshot !, t.currentSnapshot, this.rootContexts)\n                  })),\n\n              checkGuards(this.ngModule.injector, (evt: Event) => this.triggerEvent(evt)),\n              tap(t => {\n                if (isUrlTree(t.guardsResult)) {\n                  const error: Error&{url?: UrlTree} = navigationCancelingError(\n                      `Redirecting to \"${this.serializeUrl(t.guardsResult)}\"`);\n                  error.url = t.guardsResult;\n                  throw error;\n                }\n              }),\n\n              tap(t => {\n                const guardsEnd = new GuardsCheckEnd(\n                    t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects),\n                    t.targetSnapshot !, !!t.guardsResult);\n                this.triggerEvent(guardsEnd);\n              }),\n\n              filter(t => {\n                if (!t.guardsResult) {\n                  this.resetUrlToCurrentUrlTree();\n                  const navCancel =\n                      new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), '');\n                  eventsSubject.next(navCancel);\n                  t.resolve(false);\n                  return false;\n                }\n                return true;\n              }),\n\n              // --- RESOLVE ---\n              switchTap(t => {\n                if (t.guards.canActivateChecks.length) {\n                  return of (t).pipe(\n                      tap(t => {\n                        const resolveStart = new ResolveStart(\n                            t.id, this.serializeUrl(t.extractedUrl),\n                            this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot !);\n                        this.triggerEvent(resolveStart);\n                      }),\n                      resolveData(\n                          this.paramsInheritanceStrategy,\n                          this.ngModule.injector),  //\n                      tap(t => {\n                        const resolveEnd = new ResolveEnd(\n                            t.id, this.serializeUrl(t.extractedUrl),\n                            this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot !);\n                        this.triggerEvent(resolveEnd);\n                      }));\n                }\n                return undefined;\n              }),\n\n              // --- AFTER PREACTIVATION ---\n              switchTap((t: NavigationTransition) => {\n                const {\n                  targetSnapshot,\n                  id: navigationId,\n                  extractedUrl: appliedUrlTree,\n                  rawUrl: rawUrlTree,\n                  extras: {skipLocationChange, replaceUrl}\n                } = t;\n                return this.hooks.afterPreactivation(targetSnapshot !, {\n                  navigationId,\n                  appliedUrlTree,\n                  rawUrlTree,\n                  skipLocationChange: !!skipLocationChange,\n                  replaceUrl: !!replaceUrl,\n                });\n              }),\n\n              map((t: NavigationTransition) => {\n                const targetRouterState = createRouterState(\n                    this.routeReuseStrategy, t.targetSnapshot !, t.currentRouterState);\n                return ({...t, targetRouterState});\n              }),\n\n              /* Once here, we are about to activate syncronously. The assumption is this will\n                 succeed, and user code may read from the Router service. Therefore before\n                 activation, we need to update router properties storing the current URL and the\n                 RouterState, as well as updated the browser URL. All this should happen *before*\n                 activating. */\n              tap((t: NavigationTransition) => {\n                this.currentUrlTree = t.urlAfterRedirects;\n                this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);\n\n                (this as{routerState: RouterState}).routerState = t.targetRouterState !;\n\n                if (this.urlUpdateStrategy === 'deferred') {\n                  if (!t.extras.skipLocationChange) {\n                    this.setBrowserUrl(\n                        this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state);\n                  }\n                  this.browserUrlTree = t.urlAfterRedirects;\n                }\n              }),\n\n              activateRoutes(\n                  this.rootContexts, this.routeReuseStrategy,\n                  (evt: Event) => this.triggerEvent(evt)),\n\n              tap({next() { completed = true; }, complete() { completed = true; }}),\n              finalize(() => {\n                /* When the navigation stream finishes either through error or success, we set the\n                 * `completed` or `errored` flag. However, there are some situations where we could\n                 * get here without either of those being set. For instance, a redirect during\n                 * NavigationStart. Therefore, this is a catch-all to make sure the NavigationCancel\n                 * event is fired when a navigation gets cancelled but not caught by other means. */\n                if (!completed && !errored) {\n                  // Must reset to current URL tree here to ensure history.state is set. On a fresh\n                  // page load, if a new navigation comes in before a successful navigation\n                  // completes, there will be nothing in history.state.navigationId. This can cause\n                  // sync problems with AngularJS sync code which looks for a value here in order\n                  // to determine whether or not to handle a given popstate event or to leave it\n                  // to the Angualr router.\n                  this.resetUrlToCurrentUrlTree();\n                  const navCancel = new NavigationCancel(\n                      t.id, this.serializeUrl(t.extractedUrl),\n                      `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);\n                  eventsSubject.next(navCancel);\n                  t.resolve(false);\n                }\n                // currentNavigation should always be reset to null here. If navigation was\n                // successful, lastSuccessfulTransition will have already been set. Therefore we\n                // can safely set currentNavigation to null here.\n                this.currentNavigation = null;\n              }),\n              catchError((e) => {\n                errored = true;\n                /* This error type is issued during Redirect, and is handled as a cancellation\n                 * rather than an error. */\n                if (isNavigationCancelingError(e)) {\n                  const redirecting = isUrlTree(e.url);\n                  if (!redirecting) {\n                    // Set property only if we're not redirecting. If we landed on a page and\n                    // redirect to `/` route, the new navigation is going to see the `/` isn't\n                    // a change from the default currentUrlTree and won't navigate. This is\n                    // only applicable with initial navigation, so setting `navigated` only when\n                    // not redirecting resolves this scenario.\n                    this.navigated = true;\n                    this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);\n                  }\n                  const navCancel =\n                      new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), e.message);\n                  eventsSubject.next(navCancel);\n                  t.resolve(false);\n\n                  if (redirecting) {\n                    this.navigateByUrl(e.url);\n                  }\n\n                  /* All other errors should reset to the router's internal URL reference to the\n                   * pre-error state. */\n                } else {\n                  this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);\n                  const navError = new NavigationError(t.id, this.serializeUrl(t.extractedUrl), e);\n                  eventsSubject.next(navError);\n                  try {\n                    t.resolve(this.errorHandler(e));\n                  } catch (ee) {\n                    t.reject(ee);\n                  }\n                }\n                return EMPTY;\n              }));\n          // TODO(jasonaden): remove cast once g3 is on updated TypeScript\n        })) as any as Observable<NavigationTransition>;\n  }\n\n  /**\n   * @internal\n   * TODO: this should be removed once the constructor of the router made internal\n   */\n  resetRootComponentType(rootComponentType: Type<any>): void {\n    this.rootComponentType = rootComponentType;\n    // TODO: vsavkin router 4.0 should make the root component set to null\n    // this will simplify the lifecycle of the router.\n    this.routerState.root.component = this.rootComponentType;\n  }\n\n  private getTransition(): NavigationTransition {\n    const transition = this.transitions.value;\n    // This value needs to be set. Other values such as extractedUrl are set on initial navigation\n    // but the urlAfterRedirects may not get set if we aren't processing the new URL *and* not\n    // processing the previous URL.\n    transition.urlAfterRedirects = this.browserUrlTree;\n    return transition;\n  }\n\n  private setTransition(t: Partial<NavigationTransition>): void {\n    this.transitions.next({...this.getTransition(), ...t});\n  }\n\n  /**\n   * Sets up the location change listener and performs the initial navigation.\n   */\n  initialNavigation(): void {\n    this.setUpLocationChangeListener();\n    if (this.navigationId === 0) {\n      this.navigateByUrl(this.location.path(true), {replaceUrl: true});\n    }\n  }\n\n  /**\n   * Sets up the location change listener.\n   */\n  setUpLocationChangeListener(): void {\n    // Don't need to use Zone.wrap any more, because zone.js\n    // already patch onPopState, so location change callback will\n    // run into ngZone\n    if (!this.locationSubscription) {\n      this.locationSubscription = <any>this.location.subscribe((change: any) => {\n        let rawUrlTree = this.parseUrl(change['url']);\n        const source: NavigationTrigger = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n        // Navigations coming from Angular router have a navigationId state property. When this\n        // exists, restore the state.\n        const state = change.state && change.state.navigationId ? change.state : null;\n        setTimeout(\n            () => { this.scheduleNavigation(rawUrlTree, source, state, {replaceUrl: true}); }, 0);\n      });\n    }\n  }\n\n  /** The current URL. */\n  get url(): string { return this.serializeUrl(this.currentUrlTree); }\n\n  /** The current Navigation object if one exists */\n  getCurrentNavigation(): Navigation|null { return this.currentNavigation; }\n\n  /** @internal */\n  triggerEvent(event: Event): void { (this.events as Subject<Event>).next(event); }\n\n  /**\n   * Resets the configuration used for navigation and generating links.\n   *\n   * @param config The route array for the new configuration.\n   *\n   * @usageNotes\n   *\n   * ```\n   * router.resetConfig([\n   *  { path: 'team/:id', component: TeamCmp, children: [\n   *    { path: 'simple', component: SimpleCmp },\n   *    { path: 'user/:name', component: UserCmp }\n   *  ]}\n   * ]);\n   * ```\n   */\n  resetConfig(config: Routes): void {\n    validateConfig(config);\n    this.config = config.map(standardizeConfig);\n    this.navigated = false;\n    this.lastSuccessfulId = -1;\n  }\n\n  /** @docsNotRequired */\n  ngOnDestroy(): void { this.dispose(); }\n\n  /** Disposes of the router. */\n  dispose(): void {\n    if (this.locationSubscription) {\n      this.locationSubscription.unsubscribe();\n      this.locationSubscription = null !;\n    }\n  }\n\n  /**\n   * Applies an array of commands to the current URL tree and creates a new URL tree.\n   *\n   * When given an activated route, applies the given commands starting from the route.\n   * Otherwise, applies the given command starting from the root.\n   *\n   * @param commands An array of commands to apply.\n   * @param navigationExtras Options that control the navigation strategy.\n   * @returns The new URL tree.\n   *\n   * @usageNotes\n   *\n   * ```\n   * // create /team/33/user/11\n   * router.createUrlTree(['/team', 33, 'user', 11]);\n   *\n   * // create /team/33;expand=true/user/11\n   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n   *\n   * // you can collapse static segments like this (this works only with the first passed-in value):\n   * router.createUrlTree(['/team/33/user', userId]);\n   *\n   * // If the first segment can contain slashes, and you do not want the router to split it,\n   * // you can do the following:\n   * router.createUrlTree([{segmentPath: '/one/two'}]);\n   *\n   * // create /team/33/(user/11//right:chat)\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n   *\n   * // remove the right secondary node\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n   *\n   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n   *\n   * // navigate to /team/33/user/11/details\n   * router.createUrlTree(['details'], {relativeTo: route});\n   *\n   * // navigate to /team/33/user/22\n   * router.createUrlTree(['../22'], {relativeTo: route});\n   *\n   * // navigate to /team/44/user/22\n   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n   * ```\n   */\n  createUrlTree(commands: any[], navigationExtras: NavigationExtras = {}): UrlTree {\n    const {relativeTo,          queryParams,         fragment,\n           preserveQueryParams, queryParamsHandling, preserveFragment} = navigationExtras;\n    if (isDevMode() && preserveQueryParams && <any>console && <any>console.warn) {\n      console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n    }\n    const a = relativeTo || this.routerState.root;\n    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n    let q: Params|null = null;\n    if (queryParamsHandling) {\n      switch (queryParamsHandling) {\n        case 'merge':\n          q = {...this.currentUrlTree.queryParams, ...queryParams};\n          break;\n        case 'preserve':\n          q = this.currentUrlTree.queryParams;\n          break;\n        default:\n          q = queryParams || null;\n      }\n    } else {\n      q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\n    }\n    if (q !== null) {\n      q = this.removeEmptyProps(q);\n    }\n    return createUrlTree(a, this.currentUrlTree, commands, q !, f !);\n  }\n\n  /**\n   * Navigate based on the provided URL, which must be absolute.\n   *\n   * @param url An absolute URL. The function does not apply any delta to the current URL.\n   * @param extras An object containing properties that modify the navigation strategy.\n   * The function ignores any properties in the `NavigationExtras` that would change the\n   * provided URL.\n   *\n   * @returns A Promise that resolves to 'true' when navigation succeeds,\n   * to 'false' when navigation fails, or is rejected on error.\n   *\n   * @usageNotes\n   *\n   * ```\n   * router.navigateByUrl(\"/team/33/user/11\");\n   *\n   * // Navigate without updating the URL\n   * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n   * ```\n   *\n   */\n  navigateByUrl(url: string|UrlTree, extras: NavigationExtras = {skipLocationChange: false}):\n      Promise<boolean> {\n    if (isDevMode() && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {\n      this.console.warn(\n          `Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?`);\n    }\n\n    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n\n    return this.scheduleNavigation(mergedTree, 'imperative', null, extras);\n  }\n\n  /**\n   * Navigate based on the provided array of commands and a starting point.\n   * If no starting route is provided, the navigation is absolute.\n   *\n   * Returns a promise that:\n   * - resolves to 'true' when navigation succeeds,\n   * - resolves to 'false' when navigation fails,\n   * - is rejected when an error happens.\n   *\n   * @usageNotes\n   *\n   * ```\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n   *\n   * // Navigate without updating the URL\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n   * ```\n   *\n   * The first parameter of `navigate()` is a delta to be applied to the current URL\n   * or the one provided in the `relativeTo` property of the second parameter (the\n   * `NavigationExtras`).\n   *\n   * In order to affect this browser's `history.state` entry, the `state`\n   * parameter can be passed. This must be an object because the router\n   * will add the `navigationId` property to this object before creating\n   * the new history item.\n   */\n  navigate(commands: any[], extras: NavigationExtras = {skipLocationChange: false}):\n      Promise<boolean> {\n    validateCommands(commands);\n    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n  }\n\n  /** Serializes a `UrlTree` into a string */\n  serializeUrl(url: UrlTree): string { return this.urlSerializer.serialize(url); }\n\n  /** Parses a string into a `UrlTree` */\n  parseUrl(url: string): UrlTree {\n    let urlTree: UrlTree;\n    try {\n      urlTree = this.urlSerializer.parse(url);\n    } catch (e) {\n      urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);\n    }\n    return urlTree;\n  }\n\n  /** Returns whether the url is activated */\n  isActive(url: string|UrlTree, exact: boolean): boolean {\n    if (isUrlTree(url)) {\n      return containsTree(this.currentUrlTree, url, exact);\n    }\n\n    const urlTree = this.parseUrl(url);\n    return containsTree(this.currentUrlTree, urlTree, exact);\n  }\n\n  private removeEmptyProps(params: Params): Params {\n    return Object.keys(params).reduce((result: Params, key: string) => {\n      const value: any = params[key];\n      if (value !== null && value !== undefined) {\n        result[key] = value;\n      }\n      return result;\n    }, {});\n  }\n\n  private processNavigations(): void {\n    this.navigations.subscribe(\n        t => {\n          this.navigated = true;\n          this.lastSuccessfulId = t.id;\n          (this.events as Subject<Event>)\n              .next(new NavigationEnd(\n                  t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree)));\n          this.lastSuccessfulNavigation = this.currentNavigation;\n          this.currentNavigation = null;\n          t.resolve(true);\n        },\n        e => { this.console.warn(`Unhandled Navigation Error: `); });\n  }\n\n  private scheduleNavigation(\n      rawUrl: UrlTree, source: NavigationTrigger, restoredState: RestoredState|null,\n      extras: NavigationExtras): Promise<boolean> {\n    const lastNavigation = this.getTransition();\n    // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n    // and that navigation results in 'replaceState' that leads to the same URL,\n    // we should skip those.\n    if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&\n        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n      return Promise.resolve(true);  // return value is not used\n    }\n\n    // Because of a bug in IE and Edge, the location class fires two events (popstate and\n    // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n    // flicker. Handles the case when a popstate was emitted first.\n    if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&\n        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n      return Promise.resolve(true);  // return value is not used\n    }\n    // Because of a bug in IE and Edge, the location class fires two events (popstate and\n    // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n    // flicker. Handles the case when a hashchange was emitted first.\n    if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' &&\n        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n      return Promise.resolve(true);  // return value is not used\n    }\n\n    let resolve: any = null;\n    let reject: any = null;\n\n    const promise = new Promise<boolean>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    const id = ++this.navigationId;\n    this.setTransition({\n      id,\n      source,\n      restoredState,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.rawUrlTree, rawUrl, extras, resolve, reject, promise,\n      currentSnapshot: this.routerState.snapshot,\n      currentRouterState: this.routerState\n    });\n\n    // Make sure that the error is propagated even though `processNavigations` catch\n    // handler does not rethrow\n    return promise.catch((e: any) => { return Promise.reject(e); });\n  }\n\n  private setBrowserUrl(\n      url: UrlTree, replaceUrl: boolean, id: number, state?: {[key: string]: any}) {\n    const path = this.urlSerializer.serialize(url);\n    state = state || {};\n    if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {\n      // TODO(jasonaden): Remove first `navigationId` and rely on `ng` namespace.\n      this.location.replaceState(path, '', {...state, navigationId: id});\n    } else {\n      this.location.go(path, '', {...state, navigationId: id});\n    }\n  }\n\n  private resetStateAndUrl(storedState: RouterState, storedUrl: UrlTree, rawUrl: UrlTree): void {\n    (this as{routerState: RouterState}).routerState = storedState;\n    this.currentUrlTree = storedUrl;\n    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\n    this.resetUrlToCurrentUrlTree();\n  }\n\n  private resetUrlToCurrentUrlTree(): void {\n    this.location.replaceState(\n        this.urlSerializer.serialize(this.rawUrlTree), '', {navigationId: this.lastSuccessfulId});\n  }\n}\n\nfunction validateCommands(commands: string[]): void {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new Error(`The requested path contains ${cmd} segment at index ${i}`);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LocationStrategy} from '@angular/common';\nimport {Attribute, Directive, ElementRef, HostBinding, HostListener, Input, OnChanges, OnDestroy, Renderer2, isDevMode} from '@angular/core';\nimport {Subscription} from 'rxjs';\n\nimport {QueryParamsHandling} from '../config';\nimport {Event, NavigationEnd} from '../events';\nimport {Router} from '../router';\nimport {ActivatedRoute} from '../router_state';\nimport {UrlTree} from '../url_tree';\n\n\n/**\n * @description\n *\n * Lets you link to specific routes in your app.\n *\n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`.\n * When linking to this `user/:name` route, you use the `RouterLink` directive.\n *\n * If the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n *\n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n *\n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n *\n * You can set query params and fragment as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n *\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n *\n * You can tell the directive how to handle queryParams. Available options are:\n *  - `'merge'`: merge the queryParams into the current queryParams\n *  - `'preserve'`: preserve the current queryParams\n *  - default/`''`: use the queryParams only\n *\n * Same options for {@link NavigationExtras#queryParamsHandling\n * NavigationExtras#queryParamsHandling}.\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * You can provide a `state` value to be persisted to the browser's History.state\n * property (See https://developer.mozilla.org/en-US/docs/Web/API/History#Properties). It's\n * used as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * And later the value can be read from the router through `router.getCurrentNavigation`.\n * For example, to capture the `tracingId` above during the `NavigationStart` event:\n *\n * ```\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * The router link directive always treats the provided input as a delta to the current url.\n *\n * For instance, if the current url is `/user/(box//aux:team)`.\n *\n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n *\n * See {@link Router#createUrlTree createUrlTree} for more information.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({selector: ':not(a):not(area)[routerLink]'})\nexport class RouterLink {\n  // TODO(issue/24571): remove '!'.\n  @Input() queryParams !: {[k: string]: any};\n  // TODO(issue/24571): remove '!'.\n  @Input() fragment !: string;\n  // TODO(issue/24571): remove '!'.\n  @Input() queryParamsHandling !: QueryParamsHandling;\n  // TODO(issue/24571): remove '!'.\n  @Input() preserveFragment !: boolean;\n  // TODO(issue/24571): remove '!'.\n  @Input() skipLocationChange !: boolean;\n  // TODO(issue/24571): remove '!'.\n  @Input() replaceUrl !: boolean;\n  @Input() state?: {[k: string]: any};\n  private commands: any[] = [];\n  // TODO(issue/24571): remove '!'.\n  private preserve !: boolean;\n\n  constructor(\n      private router: Router, private route: ActivatedRoute,\n      @Attribute('tabindex') tabIndex: string, renderer: Renderer2, el: ElementRef) {\n    if (tabIndex == null) {\n      renderer.setAttribute(el.nativeElement, 'tabindex', '0');\n    }\n  }\n\n  @Input()\n  set routerLink(commands: any[]|string) {\n    if (commands != null) {\n      this.commands = Array.isArray(commands) ? commands : [commands];\n    } else {\n      this.commands = [];\n    }\n  }\n\n  /**\n   * @deprecated 4.0.0 use `queryParamsHandling` instead.\n   */\n  @Input()\n  set preserveQueryParams(value: boolean) {\n    if (isDevMode() && <any>console && <any>console.warn) {\n      console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');\n    }\n    this.preserve = value;\n  }\n\n  @HostListener('click')\n  onClick(): boolean {\n    const extras = {\n      skipLocationChange: attrBoolValue(this.skipLocationChange),\n      replaceUrl: attrBoolValue(this.replaceUrl),\n    };\n    this.router.navigateByUrl(this.urlTree, extras);\n    return true;\n  }\n\n  get urlTree(): UrlTree {\n    return this.router.createUrlTree(this.commands, {\n      relativeTo: this.route,\n      queryParams: this.queryParams,\n      fragment: this.fragment,\n      preserveQueryParams: attrBoolValue(this.preserve),\n      queryParamsHandling: this.queryParamsHandling,\n      preserveFragment: attrBoolValue(this.preserveFragment),\n    });\n  }\n}\n\n/**\n * @description\n *\n * Lets you link to specific routes in your app.\n *\n * See `RouterLink` for more information.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({selector: 'a[routerLink],area[routerLink]'})\nexport class RouterLinkWithHref implements OnChanges, OnDestroy {\n  // TODO(issue/24571): remove '!'.\n  @HostBinding('attr.target') @Input() target !: string;\n  // TODO(issue/24571): remove '!'.\n  @Input() queryParams !: {[k: string]: any};\n  // TODO(issue/24571): remove '!'.\n  @Input() fragment !: string;\n  // TODO(issue/24571): remove '!'.\n  @Input() queryParamsHandling !: QueryParamsHandling;\n  // TODO(issue/24571): remove '!'.\n  @Input() preserveFragment !: boolean;\n  // TODO(issue/24571): remove '!'.\n  @Input() skipLocationChange !: boolean;\n  // TODO(issue/24571): remove '!'.\n  @Input() replaceUrl !: boolean;\n  @Input() state?: {[k: string]: any};\n  private commands: any[] = [];\n  private subscription: Subscription;\n  // TODO(issue/24571): remove '!'.\n  private preserve !: boolean;\n\n  // the url displayed on the anchor element.\n  // TODO(issue/24571): remove '!'.\n  @HostBinding() href !: string;\n\n  constructor(\n      private router: Router, private route: ActivatedRoute,\n      private locationStrategy: LocationStrategy) {\n    this.subscription = router.events.subscribe((s: Event) => {\n      if (s instanceof NavigationEnd) {\n        this.updateTargetUrlAndHref();\n      }\n    });\n  }\n\n  @Input()\n  set routerLink(commands: any[]|string) {\n    if (commands != null) {\n      this.commands = Array.isArray(commands) ? commands : [commands];\n    } else {\n      this.commands = [];\n    }\n  }\n\n  @Input()\n  set preserveQueryParams(value: boolean) {\n    if (isDevMode() && <any>console && <any>console.warn) {\n      console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n    }\n    this.preserve = value;\n  }\n\n  ngOnChanges(changes: {}): any { this.updateTargetUrlAndHref(); }\n  ngOnDestroy(): any { this.subscription.unsubscribe(); }\n\n  @HostListener('click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'])\n  onClick(button: number, ctrlKey: boolean, metaKey: boolean, shiftKey: boolean): boolean {\n    if (button !== 0 || ctrlKey || metaKey || shiftKey) {\n      return true;\n    }\n\n    if (typeof this.target === 'string' && this.target != '_self') {\n      return true;\n    }\n\n    const extras = {\n      skipLocationChange: attrBoolValue(this.skipLocationChange),\n      replaceUrl: attrBoolValue(this.replaceUrl),\n      state: this.state\n    };\n    this.router.navigateByUrl(this.urlTree, extras);\n    return false;\n  }\n\n  private updateTargetUrlAndHref(): void {\n    this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\n  }\n\n  get urlTree(): UrlTree {\n    return this.router.createUrlTree(this.commands, {\n      relativeTo: this.route,\n      queryParams: this.queryParams,\n      fragment: this.fragment,\n      preserveQueryParams: attrBoolValue(this.preserve),\n      queryParamsHandling: this.queryParamsHandling,\n      preserveFragment: attrBoolValue(this.preserveFragment),\n    });\n  }\n}\n\nfunction attrBoolValue(s: any): boolean {\n  return s === '' || !!s;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AfterContentInit, ContentChildren, Directive, ElementRef, Input, OnChanges, OnDestroy, Optional, QueryList, Renderer2, SimpleChanges} from '@angular/core';\nimport {Subscription} from 'rxjs';\n\nimport {Event, NavigationEnd} from '../events';\nimport {Router} from '../router';\n\nimport {RouterLink, RouterLinkWithHref} from './router_link';\n\n\n/**\n *\n * @description\n *\n * Lets you add a CSS class to an element when the link's route becomes active.\n *\n * This directive lets you add a CSS class to an element when the link's route\n * becomes active.\n *\n * Consider the following example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n *\n * You can set more than one class, as follows:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({\n  selector: '[routerLinkActive]',\n  exportAs: 'routerLinkActive',\n})\nexport class RouterLinkActive implements OnChanges,\n    OnDestroy, AfterContentInit {\n  // TODO(issue/24571): remove '!'.\n  @ContentChildren(RouterLink, {descendants: true})\n  links !: QueryList<RouterLink>;\n  // TODO(issue/24571): remove '!'.\n  @ContentChildren(RouterLinkWithHref, {descendants: true})\n  linksWithHrefs !: QueryList<RouterLinkWithHref>;\n\n  private classes: string[] = [];\n  private subscription: Subscription;\n  public readonly isActive: boolean = false;\n\n  @Input() routerLinkActiveOptions: {exact: boolean} = {exact: false};\n\n  constructor(\n      private router: Router, private element: ElementRef, private renderer: Renderer2,\n      @Optional() private link?: RouterLink,\n      @Optional() private linkWithHref?: RouterLinkWithHref) {\n    this.subscription = router.events.subscribe((s: Event) => {\n      if (s instanceof NavigationEnd) {\n        this.update();\n      }\n    });\n  }\n\n\n  ngAfterContentInit(): void {\n    this.links.changes.subscribe(_ => this.update());\n    this.linksWithHrefs.changes.subscribe(_ => this.update());\n    this.update();\n  }\n\n  @Input()\n  set routerLinkActive(data: string[]|string) {\n    const classes = Array.isArray(data) ? data : data.split(' ');\n    this.classes = classes.filter(c => !!c);\n  }\n\n  ngOnChanges(changes: SimpleChanges): void { this.update(); }\n  ngOnDestroy(): void { this.subscription.unsubscribe(); }\n\n  private update(): void {\n    if (!this.links || !this.linksWithHrefs || !this.router.navigated) return;\n    Promise.resolve().then(() => {\n      const hasActiveLinks = this.hasActiveLinks();\n      if (this.isActive !== hasActiveLinks) {\n        (this as any).isActive = hasActiveLinks;\n        this.classes.forEach((c) => {\n          if (hasActiveLinks) {\n            this.renderer.addClass(this.element.nativeElement, c);\n          } else {\n            this.renderer.removeClass(this.element.nativeElement, c);\n          }\n        });\n      }\n    });\n  }\n\n  private isLinkActive(router: Router): (link: (RouterLink|RouterLinkWithHref)) => boolean {\n    return (link: RouterLink | RouterLinkWithHref) =>\n               router.isActive(link.urlTree, this.routerLinkActiveOptions.exact);\n  }\n\n  private hasActiveLinks(): boolean {\n    const isActiveCheckFn = this.isLinkActive(this.router);\n    return this.link && isActiveCheckFn(this.link) ||\n        this.linkWithHref && isActiveCheckFn(this.linkWithHref) ||\n        this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentFactoryResolver, ComponentRef} from '@angular/core';\n\nimport {RouterOutlet} from './directives/router_outlet';\nimport {ActivatedRoute} from './router_state';\n\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport class OutletContext {\n  outlet: RouterOutlet|null = null;\n  route: ActivatedRoute|null = null;\n  resolver: ComponentFactoryResolver|null = null;\n  children = new ChildrenOutletContexts();\n  attachRef: ComponentRef<any>|null = null;\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\nexport class ChildrenOutletContexts {\n  // contexts for child outlets, by name.\n  private contexts = new Map<string, OutletContext>();\n\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName: string, outlet: RouterOutlet): void {\n    const context = this.getOrCreateContext(childName);\n    context.outlet = outlet;\n    this.contexts.set(childName, context);\n  }\n\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName: string): void {\n    const context = this.getContext(childName);\n    if (context) {\n      context.outlet = null;\n    }\n  }\n\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated(): Map<string, OutletContext> {\n    const contexts = this.contexts;\n    this.contexts = new Map();\n    return contexts;\n  }\n\n  onOutletReAttached(contexts: Map<string, OutletContext>) { this.contexts = contexts; }\n\n  getOrCreateContext(childName: string): OutletContext {\n    let context = this.getContext(childName);\n\n    if (!context) {\n      context = new OutletContext();\n      this.contexts.set(childName, context);\n    }\n\n    return context;\n  }\n\n  getContext(childName: string): OutletContext|null { return this.contexts.get(childName) || null; }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Attribute, ChangeDetectorRef, ComponentFactoryResolver, ComponentRef, Directive, EventEmitter, Injector, OnDestroy, OnInit, Output, ViewContainerRef} from '@angular/core';\n\nimport {Data} from '../config';\nimport {ChildrenOutletContexts} from '../router_outlet_context';\nimport {ActivatedRoute} from '../router_state';\nimport {PRIMARY_OUTLET} from '../shared';\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * and a deactivate event when a component is destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * @ngModule RouterModule\n *\n * @publicApi\n */\n@Directive({selector: 'router-outlet', exportAs: 'outlet'})\nexport class RouterOutlet implements OnDestroy, OnInit {\n  private activated: ComponentRef<any>|null = null;\n  private _activatedRoute: ActivatedRoute|null = null;\n  private name: string;\n\n  @Output('activate') activateEvents = new EventEmitter<any>();\n  @Output('deactivate') deactivateEvents = new EventEmitter<any>();\n\n  constructor(\n      private parentContexts: ChildrenOutletContexts, private location: ViewContainerRef,\n      private resolver: ComponentFactoryResolver, @Attribute('name') name: string,\n      private changeDetector: ChangeDetectorRef) {\n    this.name = name || PRIMARY_OUTLET;\n    parentContexts.onChildOutletCreated(this.name, this);\n  }\n\n  ngOnDestroy(): void { this.parentContexts.onChildOutletDestroyed(this.name); }\n\n  ngOnInit(): void {\n    if (!this.activated) {\n      // If the outlet was not instantiated at the time the route got activated we need to populate\n      // the outlet when it is initialized (ie inside a NgIf)\n      const context = this.parentContexts.getContext(this.name);\n      if (context && context.route) {\n        if (context.attachRef) {\n          // `attachRef` is populated when there is an existing component to mount\n          this.attach(context.attachRef, context.route);\n        } else {\n          // otherwise the component defined in the configuration is created\n          this.activateWith(context.route, context.resolver || null);\n        }\n      }\n    }\n  }\n\n  get isActivated(): boolean { return !!this.activated; }\n\n  get component(): Object {\n    if (!this.activated) throw new Error('Outlet is not activated');\n    return this.activated.instance;\n  }\n\n  get activatedRoute(): ActivatedRoute {\n    if (!this.activated) throw new Error('Outlet is not activated');\n    return this._activatedRoute as ActivatedRoute;\n  }\n\n  get activatedRouteData(): Data {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  detach(): ComponentRef<any> {\n    if (!this.activated) throw new Error('Outlet is not activated');\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    return cmp;\n  }\n\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute) {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n  }\n\n  deactivate(): void {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n\n  activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver|null) {\n    if (this.isActivated) {\n      throw new Error('Cannot activate an already activated outlet');\n    }\n    this._activatedRoute = activatedRoute;\n    const snapshot = activatedRoute._futureSnapshot;\n    const component = <any>snapshot.routeConfig !.component;\n    resolver = resolver || this.resolver;\n    const factory = resolver.resolveComponentFactory(component);\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\n    this.activated = this.location.createComponent(factory, this.location.length, injector);\n    // Calling `markForCheck` to make sure we will run the change detection when the\n    // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n    this.changeDetector.markForCheck();\n    this.activateEvents.emit(this.activated.instance);\n  }\n}\n\nclass OutletInjector implements Injector {\n  constructor(\n      private route: ActivatedRoute, private childContexts: ChildrenOutletContexts,\n      private parent: Injector) {}\n\n  get(token: any, notFoundValue?: any): any {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n\n    return this.parent.get(token, notFoundValue);\n  }\n}\n","/**\n*@license\n*Copyright Google Inc. All Rights Reserved.\n*\n*Use of this source code is governed by an MIT-style license that can be\n*found in the LICENSE file at https://angular.io/license\n*/\n\nimport {Compiler, Injectable, Injector, NgModuleFactoryLoader, NgModuleRef, OnDestroy} from '@angular/core';\nimport {Observable, Subscription, from, of } from 'rxjs';\nimport {catchError, concatMap, filter, map, mergeAll, mergeMap} from 'rxjs/operators';\n\nimport {LoadedRouterConfig, Route, Routes} from './config';\nimport {Event, NavigationEnd, RouteConfigLoadEnd, RouteConfigLoadStart} from './events';\nimport {Router} from './router';\nimport {RouterConfigLoader} from './router_config_loader';\n\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\nexport abstract class PreloadingStrategy {\n  abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\nexport class PreloadAllModules implements PreloadingStrategy {\n  preload(route: Route, fn: () => Observable<any>): Observable<any> {\n    return fn().pipe(catchError(() => of (null)));\n  }\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\nexport class NoPreloading implements PreloadingStrategy {\n  preload(route: Route, fn: () => Observable<any>): Observable<any> { return of (null); }\n}\n\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\n@Injectable()\nexport class RouterPreloader implements OnDestroy {\n  private loader: RouterConfigLoader;\n  // TODO(issue/24571): remove '!'.\n  private subscription !: Subscription;\n\n  constructor(\n      private router: Router, moduleLoader: NgModuleFactoryLoader, compiler: Compiler,\n      private injector: Injector, private preloadingStrategy: PreloadingStrategy) {\n    const onStartLoad = (r: Route) => router.triggerEvent(new RouteConfigLoadStart(r));\n    const onEndLoad = (r: Route) => router.triggerEvent(new RouteConfigLoadEnd(r));\n\n    this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\n  }\n\n  setUpPreloading(): void {\n    this.subscription =\n        this.router.events\n            .pipe(filter((e: Event) => e instanceof NavigationEnd), concatMap(() => this.preload()))\n            .subscribe(() => {});\n  }\n\n  preload(): Observable<any> {\n    const ngModule = this.injector.get(NgModuleRef);\n    return this.processRoutes(ngModule, this.router.config);\n  }\n\n  // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If\n  // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This\n  // should be refactored.\n  ngOnDestroy(): void { this.subscription.unsubscribe(); }\n\n  private processRoutes(ngModule: NgModuleRef<any>, routes: Routes): Observable<void> {\n    const res: Observable<any>[] = [];\n    for (const route of routes) {\n      // we already have the config loaded, just recurse\n      if (route.loadChildren && !route.canLoad && route._loadedConfig) {\n        const childConfig = route._loadedConfig;\n        res.push(this.processRoutes(childConfig.module, childConfig.routes));\n\n        // no config loaded, fetch the config\n      } else if (route.loadChildren && !route.canLoad) {\n        res.push(this.preloadConfig(ngModule, route));\n\n        // recurse into children\n      } else if (route.children) {\n        res.push(this.processRoutes(ngModule, route.children));\n      }\n    }\n    return from(res).pipe(mergeAll(), map((_) => void 0));\n  }\n\n  private preloadConfig(ngModule: NgModuleRef<any>, route: Route): Observable<void> {\n    return this.preloadingStrategy.preload(route, () => {\n      const loaded$ = this.loader.load(ngModule.injector, route);\n      return loaded$.pipe(mergeMap((config: LoadedRouterConfig) => {\n        route._loadedConfig = config;\n        return this.processRoutes(config.module, config.routes);\n      }));\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewportScroller} from '@angular/common';\nimport {OnDestroy} from '@angular/core';\nimport {Unsubscribable} from 'rxjs';\n\nimport {NavigationEnd, NavigationStart, Scroll} from './events';\nimport {Router} from './router';\n\nexport class RouterScroller implements OnDestroy {\n  // TODO(issue/24571): remove '!'.\n  private routerEventsSubscription !: Unsubscribable;\n  // TODO(issue/24571): remove '!'.\n  private scrollEventsSubscription !: Unsubscribable;\n\n  private lastId = 0;\n  private lastSource: 'imperative'|'popstate'|'hashchange'|undefined = 'imperative';\n  private restoredId = 0;\n  private store: {[key: string]: [number, number]} = {};\n\n  constructor(\n      private router: Router,\n      /** @docsNotRequired */ public readonly viewportScroller: ViewportScroller, private options: {\n        scrollPositionRestoration?: 'disabled' | 'enabled' | 'top',\n        anchorScrolling?: 'disabled'|'enabled'\n      } = {}) {\n    // Default both options to 'disabled'\n    options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';\n    options.anchorScrolling = options.anchorScrolling || 'disabled';\n  }\n\n  init(): void {\n    // we want to disable the automatic scrolling because having two places\n    // responsible for scrolling results race conditions, especially given\n    // that browser don't implement this behavior consistently\n    if (this.options.scrollPositionRestoration !== 'disabled') {\n      this.viewportScroller.setHistoryScrollRestoration('manual');\n    }\n    this.routerEventsSubscription = this.createScrollEvents();\n    this.scrollEventsSubscription = this.consumeScrollEvents();\n  }\n\n  private createScrollEvents() {\n    return this.router.events.subscribe(e => {\n      if (e instanceof NavigationStart) {\n        // store the scroll position of the current stable navigations.\n        this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n        this.lastSource = e.navigationTrigger;\n        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n      } else if (e instanceof NavigationEnd) {\n        this.lastId = e.id;\n        this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment);\n      }\n    });\n  }\n\n  private consumeScrollEvents() {\n    return this.router.events.subscribe(e => {\n      if (!(e instanceof Scroll)) return;\n      // a popstate event. The pop state event will always ignore anchor scrolling.\n      if (e.position) {\n        if (this.options.scrollPositionRestoration === 'top') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        } else if (this.options.scrollPositionRestoration === 'enabled') {\n          this.viewportScroller.scrollToPosition(e.position);\n        }\n        // imperative navigation \"forward\"\n      } else {\n        if (e.anchor && this.options.anchorScrolling === 'enabled') {\n          this.viewportScroller.scrollToAnchor(e.anchor);\n        } else if (this.options.scrollPositionRestoration !== 'disabled') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        }\n      }\n    });\n  }\n\n  private scheduleScrollEvent(routerEvent: NavigationEnd, anchor: string|null): void {\n    this.router.triggerEvent(new Scroll(\n        routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));\n  }\n\n  ngOnDestroy() {\n    if (this.routerEventsSubscription) {\n      this.routerEventsSubscription.unsubscribe();\n    }\n    if (this.scrollEventsSubscription) {\n      this.scrollEventsSubscription.unsubscribe();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {APP_BASE_HREF, HashLocationStrategy, LOCATION_INITIALIZED, Location, LocationStrategy, PathLocationStrategy, PlatformLocation, ViewportScroller} from '@angular/common';\nimport {ANALYZE_FOR_ENTRY_COMPONENTS, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Compiler, ComponentRef, Inject, Injectable, InjectionToken, Injector, ModuleWithProviders, NgModule, NgModuleFactoryLoader, NgProbeToken, Optional, Provider, SkipSelf, SystemJsNgModuleLoader} from '@angular/core';\nimport {ÉµgetDOM as getDOM} from '@angular/platform-browser';\nimport {Subject, of } from 'rxjs';\n\nimport {EmptyOutletComponent} from './components/empty_outlet';\nimport {Route, Routes} from './config';\nimport {RouterLink, RouterLinkWithHref} from './directives/router_link';\nimport {RouterLinkActive} from './directives/router_link_active';\nimport {RouterOutlet} from './directives/router_outlet';\nimport {Event} from './events';\nimport {RouteReuseStrategy} from './route_reuse_strategy';\nimport {ErrorHandler, Router} from './router';\nimport {ROUTES} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader} from './router_preloader';\nimport {RouterScroller} from './router_scroller';\nimport {ActivatedRoute} from './router_state';\nimport {UrlHandlingStrategy} from './url_handling_strategy';\nimport {DefaultUrlSerializer, UrlSerializer, UrlTree} from './url_tree';\nimport {flatten} from './utils/collection';\n\n\n\n/**\n * The directives defined in the `RouterModule`.\n */\nconst ROUTER_DIRECTIVES =\n    [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, EmptyOutletComponent];\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router service.\n *\n * @publicApi\n */\nexport const ROUTER_CONFIGURATION = new InjectionToken<ExtraOptions>('ROUTER_CONFIGURATION');\n\n/**\n * @docsNotRequired\n */\nexport const ROUTER_FORROOT_GUARD = new InjectionToken<void>('ROUTER_FORROOT_GUARD');\n\nexport const ROUTER_PROVIDERS: Provider[] = [\n  Location,\n  {provide: UrlSerializer, useClass: DefaultUrlSerializer},\n  {\n    provide: Router,\n    useFactory: setupRouter,\n    deps: [\n      ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector,\n      NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION,\n      [UrlHandlingStrategy, new Optional()], [RouteReuseStrategy, new Optional()]\n    ]\n  },\n  ChildrenOutletContexts,\n  {provide: ActivatedRoute, useFactory: rootRoute, deps: [Router]},\n  {provide: NgModuleFactoryLoader, useClass: SystemJsNgModuleLoader},\n  RouterPreloader,\n  NoPreloading,\n  PreloadAllModules,\n  {provide: ROUTER_CONFIGURATION, useValue: {enableTracing: false}},\n];\n\nexport function routerNgProbeToken() {\n  return new NgProbeToken('Router', Router);\n}\n\n/**\n * @usageNotes\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * @description\n *\n * Adds router directives and providers.\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router service solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * @see [Routing and Navigation](guide/router.html) for an\n * overview of how the router service should be used.\n *\n * @publicApi\n */\n@NgModule({\n  declarations: ROUTER_DIRECTIVES,\n  exports: ROUTER_DIRECTIVES,\n  entryComponents: [EmptyOutletComponent]\n})\nexport class RouterModule {\n  // Note: We are injecting the Router so it gets created eagerly...\n  constructor(@Optional() @Inject(ROUTER_FORROOT_GUARD) guard: any, @Optional() router: Router) {}\n\n  /**\n   * Creates and configures a module with all the router providers and directives.\n   * Optionally sets up an application listener to perform an initial navigation.\n   *\n   * @param routes An array of `Route` objects that define the navigation paths for the application.\n   * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n   * @return The new router module.\n  */\n  static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule> {\n    return {\n      ngModule: RouterModule,\n      providers: [\n        ROUTER_PROVIDERS,\n        provideRoutes(routes),\n        {\n          provide: ROUTER_FORROOT_GUARD,\n          useFactory: provideForRootGuard,\n          deps: [[Router, new Optional(), new SkipSelf()]]\n        },\n        {provide: ROUTER_CONFIGURATION, useValue: config ? config : {}},\n        {\n          provide: LocationStrategy,\n          useFactory: provideLocationStrategy,\n          deps: [\n            PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION\n          ]\n        },\n        {\n          provide: RouterScroller,\n          useFactory: createRouterScroller,\n          deps: [Router, ViewportScroller, ROUTER_CONFIGURATION]\n        },\n        {\n          provide: PreloadingStrategy,\n          useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\n                                                             NoPreloading\n        },\n        {provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken},\n        provideRouterInitializer(),\n      ],\n    };\n  }\n\n  /**\n   * Creates a module with all the router directives and a provider registering routes.\n   */\n  static forChild(routes: Routes): ModuleWithProviders<RouterModule> {\n    return {ngModule: RouterModule, providers: [provideRoutes(routes)]};\n  }\n}\n\nexport function createRouterScroller(\n    router: Router, viewportScroller: ViewportScroller, config: ExtraOptions): RouterScroller {\n  if (config.scrollOffset) {\n    viewportScroller.setOffset(config.scrollOffset);\n  }\n  return new RouterScroller(router, viewportScroller, config);\n}\n\nexport function provideLocationStrategy(\n    platformLocationStrategy: PlatformLocation, baseHref: string, options: ExtraOptions = {}) {\n  return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) :\n                           new PathLocationStrategy(platformLocationStrategy, baseHref);\n}\n\nexport function provideForRootGuard(router: Router): any {\n  if (router) {\n    throw new Error(\n        `RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.`);\n  }\n  return 'guarded';\n}\n\n/**\n * Registers a [DI provider](guide/glossary#provider) for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * @publicApi\n */\nexport function provideRoutes(routes: Routes): any {\n  return [\n    {provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes},\n    {provide: ROUTES, multi: true, useValue: routes},\n  ];\n}\n\n/**\n * Allowed values in an `ExtraOptions` object that configure\n * when the router performs the initial navigation operation.\n *\n * * 'enabled' - The initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete. This value is required\n * for [server-side rendering](guide/universal) to work.\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\n * the root component gets created. Use if there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic.\n * * 'legacy_enabled'- (Default, for compatibility.) The initial navigation starts after the root component has been created.\n * The bootstrap is not blocked until the initial navigation is complete. @deprecated\n * * 'legacy_disabled'- The initial navigation is not performed. The location listener is set up\n * after the root component gets created. @deprecated since v4\n * * `true` - same as 'legacy_enabled'. @deprecated since v4\n * * `false` - same as 'legacy_disabled'. @deprecated since v4\n *\n * The 'legacy_enabled' and 'legacy_disabled' should not be used for new applications.\n *\n * @see `forRoot()`\n *\n * @publicApi\n */\nexport type InitialNavigation =\n    true | false | 'enabled' | 'disabled' | 'legacy_enabled' | 'legacy_disabled';\n\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * @publicApi\n */\nexport interface ExtraOptions {\n  /**\n   * When true, log all internal navigation events to the console.\n   * Use for debugging.\n   */\n  enableTracing?: boolean;\n\n  /**\n   * When true, enable the location strategy that uses the URL fragment\n   * instead of the history API.\n   */\n  useHash?: boolean;\n\n  /**\n   * One of `enabled` or `disabled`.\n   * When set to `enabled`, the initial navigation starts before the root component is created.\n   * The bootstrap is blocked until the initial navigation is complete. This value is required for\n   * [server-side rendering](guide/universal) to work.\n   * When set to `disabled`, the initial navigation is not performed.\n   * The location listener is set up before the root component gets created.\n   * Use if there is a reason to have more control over when the router\n   * starts its initial navigation due to some complex initialization logic.\n   *\n   * Legacy values are deprecated since v4 and should not be used for new applications:\n   *\n   * * `legacy_enabled` - Default for compatibility.\n   * The initial navigation starts after the root component has been created,\n   * but the bootstrap is not blocked until the initial navigation is complete.\n   * * `legacy_disabled` - The initial navigation is not performed.\n   * The location listener is set up after the root component gets created.\n   * * `true` - same as `legacy_enabled`.\n   * * `false` - same as `legacy_disabled`.\n   */\n  initialNavigation?: InitialNavigation;\n\n  /**\n   * A custom error handler for failed navigations.\n   */\n  errorHandler?: ErrorHandler;\n\n  /**\n   * Configures a preloading strategy.\n   * One of `PreloadAllModules` or `NoPreloading` (the default).\n   */\n  preloadingStrategy?: any;\n\n  /**\n   * Define what the router should do if it receives a navigation request to the current URL.\n   * Default is `ignore`, which causes the router ignores the navigation.\n   * This can disable features such as a \"refresh\" button.\n   * Use this option to configure the behavior when navigating to the\n   * current URL. Default is 'ignore'.\n   */\n  onSameUrlNavigation?: 'reload'|'ignore';\n\n  /**\n   * Configures if the scroll position needs to be restored when navigating back.\n   *\n   * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n   * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n   * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n   * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n   * navigation). This option will be the default in the future.\n   *\n   * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n   * in the following example.\n   *\n   * ```typescript\n   * class AppModule {\n   *   constructor(router: Router, viewportScroller: ViewportScroller) {\n   *     router.events.pipe(\n   *       filter((e: Event): e is Scroll => e instanceof Scroll)\n   *     ).subscribe(e => {\n   *       if (e.position) {\n   *         // backward navigation\n   *         viewportScroller.scrollToPosition(e.position);\n   *       } else if (e.anchor) {\n   *         // anchor navigation\n   *         viewportScroller.scrollToAnchor(e.anchor);\n   *       } else {\n   *         // forward navigation\n   *         viewportScroller.scrollToPosition([0, 0]);\n   *       }\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  scrollPositionRestoration?: 'disabled'|'enabled'|'top';\n\n  /**\n   * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n   * Anchor scrolling is disabled by default.\n   *\n   * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n   * that we stored or scroll to the top.\n   */\n  anchorScrolling?: 'disabled'|'enabled';\n\n  /**\n   * Configures the scroll offset the router will use when scrolling to an element.\n   *\n   * When given a tuple with x and y position value,\n   * the router uses that offset each time it scrolls.\n   * When given a function, the router invokes the function every time\n   * it restores scroll position.\n   */\n  scrollOffset?: [number, number]|(() => [number, number]);\n\n  /**\n   * Defines how the router merges parameters, data, and resolved data from parent to child\n   * routes. By default ('emptyOnly'), inherits parent parameters only for\n   * path-less or component-less routes.\n   * Set to 'always' to enable unconditional inheritance of parent parameters.\n   */\n  paramsInheritanceStrategy?: 'emptyOnly'|'always';\n\n  /**\n   * A custom handler for malformed URI errors. The handler is invoked when `encodedURI` contains\n   * invalid character sequences.\n   * The default implementation is to redirect to the root URL, dropping\n   * any path or parameter information. The function takes three parameters:\n   *\n   * - `'URIError'` - Error thrown when parsing a bad URL.\n   * - `'UrlSerializer'` - UrlSerializer thatâs configured with the router.\n   * - `'url'` -  The malformed URL that caused the URIError\n   * */\n  malformedUriErrorHandler?:\n      (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\n\n  /**\n   * Defines when the router updates the browser URL. By default ('deferred'),\n   * update after successful navigation.\n   * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n   * Updating the URL early allows you to handle a failure of navigation by\n   * showing an error message with the URL that failed.\n   */\n  urlUpdateStrategy?: 'deferred'|'eager';\n\n  /**\n   * Enables a bug fix that corrects relative link resolution in components with empty paths.\n   * Example:\n   *\n   * ```\n   * const routes = [\n   *   {\n   *     path: '',\n   *     component: ContainerComponent,\n   *     children: [\n   *       { path: 'a', component: AComponent },\n   *       { path: 'b', component: BComponent },\n   *     ]\n   *   }\n   * ];\n   * ```\n   *\n   * From the `ContainerComponent`, this will not work:\n   *\n   * `<a [routerLink]=\"['./a']\">Link to A</a>`\n   *\n   * However, this will work:\n   *\n   * `<a [routerLink]=\"['../a']\">Link to A</a>`\n   *\n   * In other words, you're required to use `../` rather than `./`. This is currently the default\n   * behavior. Setting this option to `corrected` enables the fix.\n   */\n  relativeLinkResolution?: 'legacy'|'corrected';\n}\n\nexport function setupRouter(\n    ref: ApplicationRef, urlSerializer: UrlSerializer, contexts: ChildrenOutletContexts,\n    location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler,\n    config: Route[][], opts: ExtraOptions = {}, urlHandlingStrategy?: UrlHandlingStrategy,\n    routeReuseStrategy?: RouteReuseStrategy) {\n  const router = new Router(\n      null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\n\n  if (urlHandlingStrategy) {\n    router.urlHandlingStrategy = urlHandlingStrategy;\n  }\n\n  if (routeReuseStrategy) {\n    router.routeReuseStrategy = routeReuseStrategy;\n  }\n\n  if (opts.errorHandler) {\n    router.errorHandler = opts.errorHandler;\n  }\n\n  if (opts.malformedUriErrorHandler) {\n    router.malformedUriErrorHandler = opts.malformedUriErrorHandler;\n  }\n\n  if (opts.enableTracing) {\n    const dom = getDOM();\n    router.events.subscribe((e: Event) => {\n      dom.logGroup(`Router Event: ${(<any>e.constructor).name}`);\n      dom.log(e.toString());\n      dom.log(e);\n      dom.logGroupEnd();\n    });\n  }\n\n  if (opts.onSameUrlNavigation) {\n    router.onSameUrlNavigation = opts.onSameUrlNavigation;\n  }\n\n  if (opts.paramsInheritanceStrategy) {\n    router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\n  }\n\n  if (opts.urlUpdateStrategy) {\n    router.urlUpdateStrategy = opts.urlUpdateStrategy;\n  }\n\n  if (opts.relativeLinkResolution) {\n    router.relativeLinkResolution = opts.relativeLinkResolution;\n  }\n\n  return router;\n}\n\nexport function rootRoute(router: Router): ActivatedRoute {\n  return router.routerState.root;\n}\n\n/**\n * Router initialization requires two steps:\n *\n * First, we start the navigation in a `APP_INITIALIZER` to block the bootstrap if\n * a resolver or a guard executes asynchronously.\n *\n * Next, we actually run activation in a `BOOTSTRAP_LISTENER`, using the\n * `afterPreactivation` hook provided by the router.\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\n@Injectable()\nexport class RouterInitializer {\n  private initNavigation: boolean = false;\n  private resultOfPreactivationDone = new Subject<void>();\n\n  constructor(private injector: Injector) {}\n\n  appInitializer(): Promise<any> {\n    const p: Promise<any> = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));\n    return p.then(() => {\n      let resolve: Function = null !;\n      const res = new Promise(r => resolve = r);\n      const router = this.injector.get(Router);\n      const opts = this.injector.get(ROUTER_CONFIGURATION);\n\n      if (this.isLegacyDisabled(opts) || this.isLegacyEnabled(opts)) {\n        resolve(true);\n\n      } else if (opts.initialNavigation === 'disabled') {\n        router.setUpLocationChangeListener();\n        resolve(true);\n\n      } else if (opts.initialNavigation === 'enabled') {\n        router.hooks.afterPreactivation = () => {\n          // only the initial navigation should be delayed\n          if (!this.initNavigation) {\n            this.initNavigation = true;\n            resolve(true);\n            return this.resultOfPreactivationDone;\n\n            // subsequent navigations should not be delayed\n          } else {\n            return of (null) as any;\n          }\n        };\n        router.initialNavigation();\n\n      } else {\n        throw new Error(`Invalid initialNavigation options: '${opts.initialNavigation}'`);\n      }\n\n      return res;\n    });\n  }\n\n  bootstrapListener(bootstrappedComponentRef: ComponentRef<any>): void {\n    const opts = this.injector.get(ROUTER_CONFIGURATION);\n    const preloader = this.injector.get(RouterPreloader);\n    const routerScroller = this.injector.get(RouterScroller);\n    const router = this.injector.get(Router);\n    const ref = this.injector.get<ApplicationRef>(ApplicationRef);\n\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n\n    if (this.isLegacyEnabled(opts)) {\n      router.initialNavigation();\n    } else if (this.isLegacyDisabled(opts)) {\n      router.setUpLocationChangeListener();\n    }\n\n    preloader.setUpPreloading();\n    routerScroller.init();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    this.resultOfPreactivationDone.next(null !);\n    this.resultOfPreactivationDone.complete();\n  }\n\n  private isLegacyEnabled(opts: ExtraOptions): boolean {\n    return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||\n        opts.initialNavigation === undefined;\n  }\n\n  private isLegacyDisabled(opts: ExtraOptions): boolean {\n    return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;\n  }\n}\n\nexport function getAppInitializer(r: RouterInitializer) {\n  return r.appInitializer.bind(r);\n}\n\nexport function getBootstrapListener(r: RouterInitializer) {\n  return r.bootstrapListener.bind(r);\n}\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router initializer that\n * is called after the app is bootstrapped.\n *\n * @publicApi\n */\nexport const ROUTER_INITIALIZER =\n    new InjectionToken<(compRef: ComponentRef<any>) => void>('Router Initializer');\n\nexport function provideRouterInitializer() {\n  return [\n    RouterInitializer,\n    {\n      provide: APP_INITIALIZER,\n      multi: true,\n      useFactory: getAppInitializer,\n      deps: [RouterInitializer]\n    },\n    {provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer]},\n    {provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER},\n  ];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n\nimport {Version} from '@angular/core';\n\n/**\n * @publicApi\n */\nexport const VERSION = new Version('8.2.14');\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n\nexport {EmptyOutletComponent as Éµangular_packages_router_router_l} from './src/components/empty_outlet';\nexport {ROUTER_FORROOT_GUARD as Éµangular_packages_router_router_a,RouterInitializer as Éµangular_packages_router_router_h,createRouterScroller as Éµangular_packages_router_router_c,getAppInitializer as Éµangular_packages_router_router_i,getBootstrapListener as Éµangular_packages_router_router_j,provideForRootGuard as Éµangular_packages_router_router_e,provideLocationStrategy as Éµangular_packages_router_router_d,provideRouterInitializer as Éµangular_packages_router_router_k,rootRoute as Éµangular_packages_router_router_g,routerNgProbeToken as Éµangular_packages_router_router_b,setupRouter as Éµangular_packages_router_router_f} from './src/router_module';\nexport {RouterScroller as Éµangular_packages_router_router_o} from './src/router_scroller';\nexport {Tree as Éµangular_packages_router_router_m,TreeNode as Éµangular_packages_router_router_n} from './src/utils/tree';"]},"metadata":{},"sourceType":"module"}